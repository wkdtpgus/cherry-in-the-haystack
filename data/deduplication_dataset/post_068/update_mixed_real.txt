오늘날 대부분의 에이전트는 피상적입니다. 이들은 길고 여러 단계로 이루어진 문제(예: 심층 연구 또는 에이전트 기반 코딩(agentic coding))에서 쉽게 무너집니다. 하지만 AI 기술의 발전 속도는 매우 빨라지고 있으며, 이러한 한계는 빠르게 변화하고 있습니다! 우리는 매우 복잡한 문제를 해결하기 위해 전략적으로 계획하고, 기억하며, 지능적으로 위임하는 AI 시스템인 "딥 에이전트(Deep Agents)"의 시대에 진입하고 있습니다. 이는 단순한 도구 사용을 넘어, 자율적인 문제 해결 능력을 갖춘 에이전트의 등장을 의미합니다. DAIR.AI Academy는 LangChain, Claude Code, 그리고 최근에는 Philipp Schmid와 같은 개인들과 함께 이 아이디어를 문서화해왔습니다. 다음은 딥 에이전트의 핵심 아이디어입니다(저의 생각과 다른 사람들에게서 얻은 메모를 바탕으로).

딥 에이전트의 개념을 더 명확하게 이해하기 위해, DAIR.AI Academy의 고객 지원 시스템을 구동하도록 구축된 최소한의 딥 에이전트의 실제 적용 사례를 소개합니다. 이 시스템은 학생들이 저희 과정에 대해 질문하고 필요한 정보를 얻을 수 있도록 고안되었습니다.

**계획(Planning)**
단일 컨텍스트(context) 창 내에서 즉흥적으로 추론하는 대신, 딥 에이전트는 업데이트하고, 재시도하며, 복구할 수 있는 구조화된 작업 계획을 유지합니다. 이를 에이전트를 장기 목표로 이끄는 동적으로 변화하는 작업 목록이라고 생각해보세요. 최신 연구에서는 Tree-of-Thought나 Graph-of-Thought와 같은 고급 계획 기술이 에이전트의 문제 해결 능력을 한층 더 향상시키고 있음을 보여줍니다. 이러한 기술을 경험하려면 Claude Code나 Codex와 같은 강력한 LLM을 사용하여 계획을 세워보세요. 어떤 작업을 실행하기 전에 이 기능을 활성화하면 결과가 훨씬 더 좋습니다. 저희는 최근 Claude Code를 이용한 장기 브레인스토밍(brainstorming)의 힘에 대해서도 글을 썼는데, 이는 계획, 전문가 컨텍스트(expert context), 그리고 인간 개입(human-in-the-loop)(딥 에이전트와 작업할 때 여러분의 전문 지식은 중요한 우위를 제공합니다)의 힘을 보여줍니다. 계획은 또한 장기적인 문제(다음으로 다룰 과학적 발견을 위한 에이전트를 생각해보세요)에도 중요할 것입니다.

**오케스트레이터(Orchestrator) 및 서브 에이전트(Sub-agent) 아키텍처(Architecture)**
하나의 거대한 에이전트(일반적으로 매우 긴 컨텍스트(context)를 가짐)만으로는 복잡한 문제를 해결하기에 더 이상 충분하지 않습니다. 저는 다중 에이전트(multi-agent) 시스템에 반대하고 모놀리식(monolithic) 시스템을 선호하는 주장을 보았지만, 이에 대해 회의적입니다. 오케스트레이터-서브 에이전트 아키텍처는 오늘날 상상할 수 있는 모든 도메인(domain)에 활용할 수 있는 가장 강력한 LLM 기반 에이전트 아키텍처 중 하나입니다. 오케스트레이터는 검색 에이전트(search agents), 코더(coders), KB 검색기(KB retrievers), 분석가(analysts), 검증자(verifiers), 작가(writers)와 같은 전문 서브 에이전트를 지능적으로 관리하며, 각 서브 에이전트는 자체적인 깨끗한 컨텍스트와 도메인(domain) 초점을 가집니다. 오케스트레이터는 지능적으로 작업을 위임하고, 서브 에이전트는 해당 전문 영역에서 효율적으로 작업을 실행합니다. 최종적으로 오케스트레이터는 이들의 출력을 통합하여 일관된 최종 결과물을 도출합니다. AutoGen이나 CrewAI와 같은 최신 프레임워크는 이러한 다중 에이전트 협업의 가능성을 더욱 확장하며, 복잡한 워크플로우를 자동화하는 데 탁월한 성능을 보여주고 있습니다. Claude Code는 코딩 및 서브 에이전트에 이 접근 방식을 대중화했으며, 이는 컨텍스트를 효율적으로 관리하는 데(관심사 분리(separation of concerns)를 통해) 특히 유용하다는 것이 밝혀졌습니다. 저는 오케스트레이터와 서브 에이전트 사용의 힘에 대한 몇 가지 메모를 [여기](https://dair.ai/blog/orchestrator-subagents)와 [여기](https://dair.ai/blog/orchestrator-subagents-2)에 작성했습니다.

**컨텍스트 검색(Context Retrieval) 및 에이전트 기반 검색(Agentic Search)**
딥 에이전트는 단순히 대화 기록에만 의존하지 않습니다. 이들은 파일, 메모, 벡터(vectors) 또는 데이터베이스(databases)와 같은 외부 메모리에 중간 작업을 저장하여, 모델의 컨텍스트를 과부하하지 않고 중요한 것을 참조할 수 있도록 합니다. 효율적이고 구조화된 메모리 관리는 딥 에이전트의 성능을 극대화하는 핵심 요소입니다. 메모리 구축 및 검색을 더 잘 최적화하는 방법에 대한 정말 멋진 아이디어를 얻으려면 ReasoningBank 및 Agentic Context Engineering과 같은 최근 연구들을 살펴보세요. 특히, 동적 지식 그래프(Knowledge Graph) 통합이나 자기 개선 검색(Self-improving Retrieval)과 같은 고급 RAG(Retrieval-Augmented Generation) 기술은 에이전트가 필요한 정보를 더욱 정확하고 유연하게 찾아 활용하도록 돕습니다. 오케스트레이터-서브 에이전트 아키텍처로 구축한다는 것은 하이브리드 메모리 기술(예: 에이전트 기반 검색(agentic search) + 의미론적 검색(semantic search))을 활용할 수 있으며, 에이전트가 어떤 전략을 사용할지 결정하도록 할 수 있다는 것을 의미합니다.

**컨텍스트 엔지니어링(Context Engineering)**
딥 에이전트의 잠재력을 최대한 발휘하려면, 명확하고 상세한 지침 제공이 필수적입니다. 프롬프트 엔지니어링(prompt engineering)은 중요했고 지금도 중요하지만, 에이전트를 위한 컨텍스트 구축의 중요성을 강조하기 위해 새로운 용어인 컨텍스트 엔지니어링을 사용할 것입니다. 지침은 언제 계획할지, 언제 서브 에이전트를 사용할지, 파일 이름을 어떻게 지정할지, 그리고 인간과 어떻게 협력할지를 정의하기 위해 더 명시적이고, 상세하며, 의도적이어야 합니다. 이는 단순히 초기 프롬프트를 넘어, 에이전트의 실행 과정 전반에 걸쳐 동적으로 컨텍스트를 조율하는 "컨텍스트 오케스트레이션(Context Orchestration)"의 개념으로 발전하고 있습니다. 컨텍스트 엔지니어링의 일부는 또한 구조화된 출력(structured outputs), 시스템 프롬프트 최적화(system prompt optimization), 컨텍스트 압축(compacting context), 컨텍스트 효율성 평가(evaluating context effectiveness), 그리고 도구 정의 최적화(optimizing tool definitions)와 관련된 노력을 포함합니다. 더 자세히 알아보려면 컨텍스트 엔지니어링에 대한 저희의 이전 가이드를 읽어보세요: [컨텍스트 엔지니어링 심층 분석(Context Engineering Deep Dive)](https://dair.ai/blog/context-engineering-deep-dive)

**검증(Verification)**
컨텍스트 엔지니어링 다음으로, 검증은 에이전트 시스템의 가장 중요한 구성 요소 중 하나입니다(비록 덜 자주 논의되지만). 검증은 에이전트의 출력(outputs)을 검증하는 것으로 귀결되며, 이는 자동화되거나(LLM-as-a-Judge) 인간에 의해 수행될 수 있습니다. 최신 LLM들이 뛰어난 성능을 보이지만, 여전히 환각(hallucination), 편향(bias), 프롬프트 주입(prompt injection)과 같은 고질적인 문제에서 완전히 자유롭지 않습니다. 검증은 에이전트를 더 신뢰할 수 있고 프로덕션(production) 준비가 된 상태로 만드는 데 도움이 됩니다. 최근에는 다중 에이전트 간의 합의(multi-agent consensus)나 자체 반성 루프(self-reflection loops)를 통해 검증의 신뢰성을 높이는 연구도 활발히 진행되고 있습니다. 체계적인 평가 파이프라인(evaluation pipelines)을 활용하여 좋은 검증자를 구축할 수 있습니다.

**마지막 말**
이는 AI 에이전트를 구축하는 방식에 있어 거대한 변화입니다. 딥 에이전트는 사용자를 대신하여 능동적으로 작업을 수행하는 차세대 개인화된 에이전트 개발을 위한 핵심 기반을 제공합니다. 저는 미래 게시물에서 능동적 에이전트 및 그 너머의 개념에 대해 더 많이 쓸 것입니다. AI 에이전트를 효과적으로 구축하는 방법에 대한 다가오는 게시물을 놓치고 싶지 않다면, 유료 등급으로 업그레이드하는 것을 고려해보세요: [구독(Subscribe)](https://dair.ai/subscribe)

저는 지난 몇 달 동안 에이전트 개발자들에게 이러한 아이디어를 가르쳐왔습니다. 딥 에이전트를 구축하는 방법에 대한 더 많은 실습 경험에 관심이 있다면, 저희 아카데미의 최신 과정을 확인해보세요: [https://dair-ai.thinkific.com/courses/agents-with-n8n](https://dair-ai.thinkific.com/courses/agents-with-n8n) 이 게시물에서 볼 수 있는 그림들은 학생들이 과정 최종 프로젝트를 위해 구축해야 하는 에이전트 기반 RAG(Retrieval-Augmented Generation) 시스템을 설명합니다. 이 게시물은 딥 에이전트를 설계하고 구현하기 위한 포괄적인 통찰력, 다운로드 가능한 템플릿(templates), 프롬프트, 그리고 고급 팁을 제공하는 저희의 새로운 과정 “ [n8n으로 강력한 AI 에이전트 구축하기(Building Robust AI Agents with n8n)](https://dair-ai.thinkific.com/courses/agents-with-n8n) ”를 기반으로 합니다. 이 과정은 2025년 최신 기술 트렌드를 반영하여 업데이트되었습니다. [지금 등록하기(Enroll Now)](https://dair-ai.thinkific.com/courses/agents-with-n8n)