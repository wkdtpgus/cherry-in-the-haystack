데이터 과학자를 위한 파이썬 성능 최적화: 핵심 데이터프레임 연산 심층 분석

1년 동안 50% 할인

이번 연재에서는 데이터프레임(DataFrame)을 다루는 데 필수적인 두 가지 핵심 처리 기법, 즉 데이터 요소를 효과적으로 지정하고 그 내용을 변경하는 방법에 대해 상세히 탐구할 것입니다. 우리는 pandas 라이브러리를 활용하여 특정 위치나 조건에 따라 행(row)과 열(column)을 정밀하게 선택하는 실용적인 방법과, `replace()` 함수를 포함한 다양한 전략을 통해 단일 값 또는 여러 값을 목록(list)이나 사전(dictionary) 형태로 일괄 수정하는 기법을 학습합니다. 이러한 지식은 모든 데이터 분석 워크플로우(workflow)의 데이터 전처리(data preprocessing) 단계에서 필수적이며, 더욱 간결하고 신속하며 자원 효율적인 코드를 작성하는 데 기여할 것입니다.

**목차:**
*   최적화된 코드 작성의 중요성
*   `.iloc[]` 및 `.loc[]`를 활용한 데이터프레임의 행과 열 선택 기법
*   데이터프레임 내 값 변경의 효율적인 전략
*   데이터 선택 및 대체 작업의 최적 관행 요약

1년 동안 50% 할인

### 내 모든 책을 40% 할인된 가격으로 한 번의 클릭으로 구매하세요

**유세프 호스니(Youssef Hosni) · 6월 17일**

제 저서들과 학습 로드맵(roadmap)을 묶은 특별 패키지(bundle)를 마련했습니다. 단 한 번의 클릭으로 모든 콘텐츠를 정가보다 40% 저렴하게 소장하실 수 있습니다. 이 패키지에는 다음을 포함한 8권의 전자책(eBook)이 포함되어 있습니다:

[전체 이야기 읽기](https://medium.com/@youssefhosni/get-all-my-books-one-button-away-with-40-off-221295324150)

### 1. 최적화된 코드 작성의 중요성

최적화된 프로그램은 실행 속도가 빠르고 시스템 자원 소모가 적은 특징을 지닙니다. 본 글에서는 코드의 수행 시간을 측정하기 위해 파이썬의 `time()` 모듈 기능을 활용할 것입니다. 이 모듈은 현재 시각을 반환하므로, 특정 코드 블록의 실행 전후에 변수에 시간을 기록한 다음, 그 차이를 계산하여 해당 코드의 처리 시간을 파악할 수 있습니다.

아래 코드에서 간단한 예시를 확인할 수 있습니다:

```python
import time

# record time before execution
start_time = time.time()

# execute operation
result = 5 + 2

# record time after execution
end_time = time.time()

print("Result calculated in {} sec".format(end_time - start_time))
```

이제 최적화된 코딩 방식을 적용하는 것이 프로그램의 실행 속도(runtime)를 어떻게 향상시키고 계산 복잡도(computational complexity)를 줄이는지 몇 가지 사례를 통해 살펴보겠습니다. 특히 대규모 데이터 처리 시 이러한 최적화는 단순히 속도 개선을 넘어 비용 절감 및 사용자 경험 향상으로 이어질 수 있습니다.

0부터 100만까지 각 숫자의 제곱을 계산하는 작업을 예로 들어보겠습니다. 먼저, 리스트 내포(list comprehension) 방식을 사용하여 이 연산을 수행한 다음, 전통적인 반복문(for loop)을 활용하여 동일한 절차를 반복하여 비교할 것입니다.

**첫째, 리스트 내포 사용:**

```python
#using List comprehension
list_comp_start_time = time.time()
result = [i*i for i in range(0,1000000)]
list_comp_end_time = time.time()
print("Time using the list_comprehension: {} sec".format(list_comp_end_time - list_comp_start_time))
```

이어서 일반적인 반복문을 사용하여 동일한 연산을 실행할 것입니다:

```python
# Using For loop
for_loop_start_time= time.time()
result=[]
for i in range(0,1000000):
    result.append(i*i)
for_loop_end_time= time.time()
print("Time using the for loop: {} sec".format(for_loop_end_time - for_loop_start_time))
```

두 방법 간에 상당한 성능 격차가 있음을 관찰할 수 있습니다. 이 차이를 백분율로 산출해 봅시다:

```python
list_comp_time = list_comp_end_time - list_comp_start_time
for_loop_time = for_loop_end_time - for_loop_start_time

print("Difference in time: {} %".format((for_loop_time - list_comp_time)/ list_comp_time*100))
```

효율적인 코드 작성의 효과를 보여주는 또 다른 예시는 1부터 100만까지의 모든 연속된 숫자의 합을 계산하는 경우입니다. 여기에는 두 가지 접근 방식이 있습니다. 첫 번째는 무차별 대입(brute force) 방식으로, 1부터 100만까지 숫자를 하나씩 순차적으로 더하는 것입니다.

```python
def sum_brute_force(N):
    res = 0
    for i in range(1,N+1):
        res+=i
    return res

# Using brute force
bf_start_time = time.time()
bf_result = sum_brute_force(1000000)
bf_end_time = time.time()
print("Time using brute force: {} sec".format(bf_end_time - bf_start_time))
```

더욱 능률적인 대안은 수학적 공식을 활용하는 것입니다. 1부터 N까지의 모든 정수(integer)의 합은 N에 N+1을 곱한 후 2로 나누면 얻을 수 있습니다. 이 문제는 실제로 19세기 독일의 일부 학생들에게 제시되었는데, 칼 프리드리히 가우스(Carl-Friedrich Gauss)라는 영리한 학생이 이 공식을 고안하여 문제를 단 몇 초 만에 해결했다고 전해집니다.

```python
def sum_formula(N):
    return N*(N+1)/2

# Using the formula
formula_start_time = time.time()
formula_result = sum_formula(1000000)
formula_end_time = time.time()
print("Time using the formula: {} sec".format(formula_end_time - formula_start_time))
```

두 가지 방법을 모두 실행한 결과, 우리는 무려 160,000%가 넘는 엄청난 성능 향상을 이룰 수 있었습니다. 이는 아무리 사소해 보이는 작업이라도 효율적이고 최적화된 구현이 얼마나 중요한지를 명확히 보여줍니다. 특히 빅데이터(big data) 환경에서는 이러한 작은 차이가 전체 시스템의 처리 능력에 막대한 영향을 미칠 수 있습니다.

### 2. `.iloc[]` 및 `.loc[]`를 활용한 데이터프레임의 행과 열 선택 기법

이 하위 섹션에서는 pandas의 `.iloc[]` 및 `.loc[]` 접근자를 사용하여 데이터프레임에서 행을 효과적으로 식별하고 추출하는 방법을 소개할 것입니다. `.iloc[]`는 위치 기반 인덱싱(position-based indexing)에, `.loc[]`는 레이블 기반 인덱싱(label-based indexing)에 주로 활용됩니다.

아래 예시에서는 포커 데이터셋(dataset)의 첫 500개 행을 선택하는 시나리오를 다룰 것입니다. 먼저 `.loc[]`를 사용하고, 이어서 `.iloc[]`를 적용하여 두 방식의 성능을 비교합니다.

```python
# Specify the range of rows to select
rows = range(0, 500)

# Time selecting rows using .loc[]
loc_start_time = time.time()
poker_data.loc[rows]
loc_end_time = time.time()
print("Time using .loc[] : {} sec".format(loc_end_time - loc_start_time))

# Specify the range of rows to select
rows = range(0, 500)

# Time selecting rows using .iloc[]
iloc_start_time = time.time()
poker_data.iloc[rows]
iloc_end_time = time.time()
print("Time using .iloc[]: {} sec".format(iloc_end_time - iloc_start_time))

loc_comp_time = loc_end_time - loc_start_time
iloc_comp_time = iloc_end_time - iloc_start_time
print("Difference in time: {} %".format((loc_comp_time - iloc_comp_time)/ iloc_comp_time*100))
```

두 접근 방식은 구문(syntax)상 유사해 보이지만, `.iloc[]`가 `.loc[]`보다 약 70% 더 빠른 속도로 동작함을 알 수 있습니다. 이는 `.iloc[]`가 내부적으로 인덱스(index)의 순서 정보를 직접 활용하여 데이터에 접근하기 때문에 더 효율적이기 때문입니다. 또한, 단일 요소 접근에 특화된 `.at[]`와 `.iat[]`는 각각 레이블 기반 및 위치 기반으로 특정 셀(cell)에 매우 빠르게 접근할 수 있어, 반복적인 단일 값 조회 및 수정 시 유용합니다.

이러한 인덱서들은 행뿐만 아니라 열을 선택하는 데에도 사용될 수 있습니다. 다음 예시에서는 두 가지 방법을 모두 사용하여 처음 세 개의 열을 선택할 것입니다.

```python
iloc_start_time = time.time()
poker_data.iloc[:,:3]
iloc_end_time = time.time()
print("Time using .iloc[]: {} sec".format(iloc_end_time - iloc_start_time))

names_start_time = time.time()
poker_data[['S1', 'R1', 'S2']]
names_end_time = time.time()
print("Time using selection by name: {} sec".format(names_end_time - names_start_time))

loc_comp_time = names_end_time - names_start_time
iloc_comp_time = iloc_end_time - iloc_start_time
print("Difference in time: {} %".format((loc_comp_time - iloc_comp_time)/ loc_comp_time*100))
```

여기서도 `.iloc[]`를 사용한 열 인덱싱(column indexing)이 이름으로 직접 선택하는 방식보다 약 80% 더 신속하다는 것을 확인할 수 있습니다. 따라서 특정 열을 레이블(label)로 선택하는 것이 더 직관적이거나 편리한 경우가 아니라면, 일반적으로는 성능이 더 우수한 `.iloc[]`를 사용하는 것이 권장됩니다. 또한, 데이터프레임에서 선택된 부분이 원본의 "뷰(view)"인지 "복사본(copy)"인지에 대한 이해는 `SettingWithCopyWarning`과 같은 잠재적 문제를 방지하는 데 중요합니다.

### 3. 데이터프레임 내 값 변경의 효율적인 전략

데이터프레임 내 항목을 변경하는 것은 필수적인 과정이며, 특히 데이터 전처리(data preprocessing) 시 일관된 값 표현을 유지하는 데 핵심적입니다. 예를 들어, 동일한 개념을 나타내는 다양한 표기법을 표준화해야 할 때 이 작업이 중요합니다.

이전에 불러왔던 인기 아기 이름 데이터셋을 다시 살펴보겠습니다:

`Gender` (성별) 특성(feature)을 자세히 분석하고 포함된 고유한 값(unique values)을 확인해 봅시다:

```python
names['Gender'].unique()
```

여기서 여성 성별이 대문자와 소문자 두 가지 형태로 표현되어 있음을 알 수 있습니다. 이는 실제 데이터에서 흔히 발생하는 불일치이며, 이를 해결하는 간단한 방법은 데이터셋 전체의 일관성을 위해 한 값을 다른 값으로 통일하는 것입니다.

이러한 값 변경을 수행하는 두 가지 주요 방법이 있습니다. 첫 번째는 `.loc[]` 인덱서를 사용하여 변경할 값을 지정한 다음, 새로운 값을 할당하는 방식입니다. 이는 아래 코드에 나타나 있습니다:

```python
start_time = time.time()
names['Gender'].loc[names.Gender=='female'] = 'FEMALE'
end_time = time.time()
pandas_time = end_time - start_time
print("Replace values using .loc[]: {} sec".format(pandas_time))
```

두 번째 방법은 아래 코드에 나와 있는 것처럼 pandas 라이브러리에 내장된 `.replace()` 함수를 활용하는 것입니다:

```python
start_time = time.time()
names['Gender'].replace('female', 'FEMALE', inplace=True)
end_time = time.time()
replace_time = end_time - start_time
print("Time using replace(): {} sec".format(replace_time))
```

내장 함수를 사용하는 것이 성능 면에서 큰 차이를 만들어냄을 알 수 있습니다. `.loc()` 메서드를 사용하여 값의 행과 열 인덱스를 찾아 변경하는 것보다 `.replace()` 함수가 약 157% 더 빠르게 동작합니다. 이는 대규모 데이터 처리 시 상당한 시간 절약으로 이어집니다.

```python
print('The differnce: {} %'.format((pandas_time- replace_time )/replace_time*100))
```

여러 값을 한 번에 변경해야 할 때는 목록(list)을 활용할 수도 있습니다. 우리의 목표는 'WHITE NON-HISPANIC' 또는 'WHITE NON-HISP'로 분류된 모든 민족을 'WNH'로 변경하는 것입니다. `.loc[]` 함수를 사용하여, 파이썬의 논리 연산자 `or` (파이프 `|`로 표현)를 통해 우리가 찾고 있는 민족의 아기들을 식별할 것입니다. 그런 다음 새로운 값을 할당하고, 이 연산에 소요되는 CPU 시간도 측정합니다.

```python
start_time = time.time()
names['Ethnicity'].loc[(names["Ethnicity"] == 'WHITE NON HISPANIC') | (names["Ethnicity"] == 'WHITE NON HISP')] = 'WNH'
end_time = time.time()
pandas_time= end_time - start_time
print("Results from the above operation calculated in %s seconds" %(pandas_time))
```

아래와 같이 `.replace()` pandas 내장 함수를 사용하면 동일한 연산을 더욱 간결하게 수행할 수 있습니다:

```python
start_time = time.time()
names['Ethnicity'].replace(['WHITE NON HISPANIC','WHITE NON HISP'], 'WNH', inplace=True)
end_time = time.time()
replace_time = end_time - start_time
print("Time using .replace(): {} sec".format(replace_time))
```

여기서도 `.replace()` 메서드가 `.loc[]` 메서드에 비해 훨씬 더 신속하게 작업을 처리함을 확인할 수 있습니다. 얼마나 빠른지 더 명확하게 이해하기 위해 다음 코드를 실행해 봅시다:

```python
print('The differnce: {} %'.format((pandas_time- replace_time )/replace_time*100))
```

`.replace()` 메서드는 `.loc[]` 메서드보다 약 87% 더 빠른 성능을 보입니다. 방대한 양의 데이터에 대한 정제(data cleaning) 작업이 필요한 경우, 이 팁은 데이터 전처리 시간을 크게 단축시키고 pandas 코드의 효율성을 대폭 향상시킬 수 있습니다. 또한, `regex=True` 옵션을 활용하면 정규 표현식(regular expression) 기반의 복잡한 패턴 매칭을 통한 값 변경도 가능합니다.

마지막으로, 사전(dictionary)을 활용하여 데이터프레임 내의 단일 값과 여러 값을 동시에 변경할 수 있습니다. 이는 하나의 명령으로 여러 변경 사항을 적용하고 싶을 때 매우 유용합니다. 여기서는 모든 남성 성별을 'BOY'로, 모든 여성 성별을 'GIRL'로 변경하고, 소문자 'female'도 'girl'로 통일하는 예시를 보여줍니다.

```python
names = pd.read_csv('Popular_Baby_Names.csv')
start_time = time.time()
names['Gender'].replace({'MALE':'BOY', 'FEMALE':'GIRL', 'female': 'girl'}, inplace=True)
end_time = time.time()
dict_time = end_time - start_time
print("Time using .replace() with dictionary: {} sec".format(dict_time))

names = pd.read_csv('Popular_Baby_Names.csv')
start_time = time.time()
names['Gender'].replace('MALE', 'BOY', inplace=True)
names['Gender'].replace('FEMALE', 'GIRL', inplace=True)
names['Gender'].replace('female', 'girl', inplace=True)
end_time = time.time()
list_time = end_time - start_time
print("Time using multiple .replace(): {} sec".format(list_time))

print('The differnce: {} %'.format((list_time- dict_time )/dict_time*100))
```

목록을 사용해서도 동일한 작업을 수행할 수 있지만, 코드가 더 장황해집니다. 두 가지 방법을 비교해 보면 사전 방식이 약 22% 더 빠르게 실행된다는 것을 알 수 있습니다. 일반적으로 파이썬에서 사전(dictionary)은 해시 테이블(hash table) 기반의 빠른 탐색 덕분에 목록(list)에 비해 조회 및 매핑 작업에서 매우 효율적입니다. 목록은 순차적으로 모든 요소를 탐색해야 하는 반면, 사전은 키(key)를 통해 해당 값에 즉시 접근하기 때문입니다. 다만 두 자료구조는 본질적인 목적이 다르므로 직접적인 성능 비교는 상황에 따라 다소 불공평할 수 있습니다.

사전 방식을 사용하면 여러 다른 열에서도 동일한 값을 변경할 수 있습니다. 이전의 모든 예시에서는 변경할 값이 있는 특정 열을 지정했습니다. 이제 동일한 열의 여러 값을 하나의 공통 값으로 분류하는 시나리오를 다루겠습니다. 모든 민족을 흑인(Black), 아시아인(Asian), 백인(White)의 세 가지 큰 범주로 재분류하고자 합니다. 구문은 다시 한번 매우 직관적입니다. 여기서는 중첩 사전(nested dictionary)을 사용합니다. 외부 키(outer key)는 값을 변경하려는 열의 이름이며, 이 외부 키의 값은 또 다른 사전입니다. 이 내부 사전에서는 원래의 민족 이름이 키가 되고, 새로운 민족 범주(흑인, 아시아인 또는 백인)가 값이 됩니다.

```python
start_time = time.time()
names.replace({'Ethnicity': {'ASIAN AND PACI': 'ASIAN', 'ASIAN AND PACIFIC ISLANDER': 'ASIAN',
                             'BLACK NON HISPANIC': 'BLACK', 'BLACK NON HISP': 'BLACK',
                             'WHITE NON HISPANIC': 'WHITE', 'WHITE NON HISP': 'WHITE'}})
print("Time using .replace() with dictionary: {} sec".format (time.time() - start_time))
```

### 4. 데이터 선택 및 대체 작업의 최적 관행 요약

*   데이터프레임의 행과 열을 지정하는 데는 `.iloc[]` 함수가 일반적으로 더 신속합니다. 따라서 `.loc[]`를 사용하는 것이 가독성이나 편의성 면에서 더 유리하거나, 성능이 최우선 고려 사항이 아니거나, 단발성 작업인 경우가 아니라면 `.iloc[]`를 활용하는 것이 바람직합니다.
*   pandas 내장 `replace()` 함수를 사용하는 것이 수동으로 `.loc[]` 등을 이용해 값을 변경하는 기존 방식보다 훨씬 더 빠른 성능을 제공합니다. 이는 특히 대규모 데이터셋에서 두드러집니다.
*   여러 값을 변경할 때 파이썬 사전을 활용하는 것이 목록을 사용하는 것보다 빠르게 작업을 처리합니다. 이는 사전의 효율적인 키-값 조회 메커니즘 덕분입니다.
*   가능한 한 명시적인 반복문(loop) 대신 벡터화된(vectorized) pandas 연산을 사용하는 것이 성능 향상에 크게 기여합니다.
*   데이터 타입(data type)을 적절하게 선택하고 메모리 효율적인 구조를 사용하는 것도 코드의 전반적인 성능에 긍정적인 영향을 미칩니다.

이 뉴스레터(newsletter)는 저의 개인적인 열정 프로젝트이며, 여러분의 성원이 이를 지속하는 데 큰 힘이 됩니다. 기여하고 싶으시다면 몇 가지 좋은 방법이 있습니다:

*   **구독(Subscribe)**해 주세요. 유료 구독은 제 글쓰기를 지속 가능하게 하고 추가 콘텐츠에 대한 접근 권한을 제공합니다.
*   제 책 **패키지(Bundle)**를 구매하세요. 저의 실용적인 책 7권과 로드맵을 단 40% 할인된 가격으로 만나보세요.

읽어주셔서 감사하며, 독립적인 글쓰기와 연구를 지원해 주셔서 진심으로 감사드립니다!