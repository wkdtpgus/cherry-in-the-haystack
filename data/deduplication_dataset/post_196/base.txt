# **데이터 과학자를 위한 효율적인 파이썬 강좌 [9/14]: Pandas 데이터프레임(DataFrame)에서 값 효과적으로 선택 및 교체하기**

Author: Youssef Hosni
URL: https://youssefh.substack.com/p/efficient-python-for-data-scientists-d44

============================================================

**데이터 과학자를 위한 효율적인 파이썬(Efficient Python for Data Scientists) 강좌의 아홉 번째 강의에서, 우리는 pandas를 사용하여 값을 효율적으로 선택하고 교체하는 두 가지 필수적인 DataFrame 연산에 대해 깊이 있게 다룰 것입니다.**

1년 동안 50% 할인

특정 또는 무작위 행(row)과 열(column)을 효율적으로 선택하는 실용적인 기술과, replace() 함수를 사용하여 하나 또는 여러 값을 리스트(list)와 딕셔너리(dictionary)로 수정하는 방법을 배울 것입니다. 이러한 기술은 모든 데이터 과학 워크플로우(workflow)의 데이터 조작 단계에서 필수적이며, 더 깔끔하고 빠르며 효율적인 코드를 작성하는 데 도움이 됩니다.

**목차:**
*   왜 효율적인 코딩이 필요한가?
*   .iloc[ ] 및 .loc[ ]를 사용하여 행과 열을 효율적으로 선택하기
*   DataFrame에서 값을 효과적으로 교체하기
*   값 선택 및 교체를 위한 모범 사례 요약

1년 동안 50% 할인

### 내 모든 책을 40% 할인된 가격으로 한 번의 클릭으로 구매하세요

**유세프 호스니(Youssef Hosni) · 6월 17일**

제 책과 로드맵(roadmap)을 묶은 번들(bundle)을 만들었으니, 단 한 번의 클릭으로 모든 것을 원래 가격보다 40% 저렴하게 구매할 수 있습니다. 이 번들에는 다음을 포함한 8개의 전자책(eBook)이 포함되어 있습니다:

[전체 이야기 읽기](https://medium.com/@youssefhosni/get-all-my-books-one-button-away-with-40-off-221295324150)

### 1. 왜 효율적인 코딩이 필요한가?

효율적인 코드(Efficient code)는 더 빠르게 실행되고 더 적은 계산 메모리(computational memory)를 사용하는 코드입니다. 이 글에서는 time() 함수를 사용하여 계산 시간(computational time)을 측정할 것입니다. 이 함수는 현재 시간을 측정하므로, 코드 실행 전과 후에 변수에 할당한 다음, 그 차이를 계산하여 코드의 계산 시간을 알 수 있습니다.

간단한 예시는 아래 코드에 나와 있습니다:

```python
import time

# record time before execution
start_time = time.time()

# execute operation
result = 5 + 2

# record time after execution
end_time = time.time()

print("Result calculated in {} sec".format(end_time - start_time))
```

효율적인 코드 방법을 적용하는 것이 어떻게 코드 실행 시간(runtime)을 개선하고 계산 시간 복잡도(computational time complexity)를 줄이는지 몇 가지 예시를 살펴보겠습니다:

0부터 100만까지 각 숫자의 제곱을 계산할 것입니다. 먼저, 리스트 컴프리헨션(list comprehension)을 사용하여 이 연산을 실행한 다음, for 루프(loop)를 사용하여 동일한 절차를 반복할 것입니다.

**첫째, 리스트 컴프리헨션 사용:**

1년 동안 50% 할인

```python
#using List comprehension
list_comp_start_time = time.time()
result = [i*i for i in range(0,1000000)]
list_comp_end_time = time.time()
print("Time using the list_comprehension: {} sec".format(list_comp_end_time - list_comp_start_time))
```

이제 for 루프를 사용하여 동일한 연산을 실행할 것입니다:

```python
# Using For loop
for_loop_start_time= time.time()
result=[]
for i in range(0,1000000):
    result.append(i*i)
for_loop_end_time= time.time()
print("Time using the for loop: {} sec".format(for_loop_end_time - for_loop_start_time))
```

둘 사이에 큰 차이가 있음을 알 수 있습니다. 둘 사이의 차이를 백분율로 계산할 수 있습니다:

```python
list_comp_time = list_comp_end_time - list_comp_start_time
for_loop_time = for_loop_end_time - for_loop_start_time

print("Difference in time: {} %".format((for_loop_time - list_comp_time)/ list_comp_time*100))
```

효율적인 코드를 작성하는 효과를 보여주는 또 다른 예시입니다. 1부터 100만까지의 모든 연속된 숫자의 합을 계산하려고 합니다. 두 가지 방법이 있습니다: 첫 번째는 무차별 대입(brute force) 방식을 사용하는 것으로, 1부터 100만까지 하나씩 더하는 것입니다.

```python
def sum_brute_force(N):
    res = 0
    for i in range(1,N+1):
        res+=i
    return res

# Using brute force
bf_start_time = time.time()
bf_result = sum_brute_force(1000000)
bf_end_time = time.time()
print("Time using brute force: {} sec".format(bf_end_time - bf_start_time))
```

더 효율적인 또 다른 방법은 공식을 사용하여 계산하는 것입니다. 1부터 N까지의 모든 정수(integer number)의 합을 계산하려면, N에 N+1을 곱한 다음 2로 나누면 원하는 결과를 얻을 수 있습니다. 이 문제는 실제로 19세기 독일의 일부 학생들에게 주어졌으며, 칼 프리드리히 가우스(Carl-Friedrich Gauss)라는 영리한 학생이 이 공식을 고안하여 문제를 몇 초 만에 해결했습니다.

1년 동안 50% 할인

```python
def sum_formula(N):
    return N*(N+1)/2

# Using the formula
formula_start_time = time.time()
formula_result = sum_formula(1000000)
formula_end_time = time.time()
print("Time using the formula: {} sec".format(formula_end_time - formula_start_time))
```

두 가지 방법을 모두 실행한 후, 우리는 160,000%가 넘는 엄청난 개선을 달성했으며, 이는 간단한 작업에도 효율적이고 최적화된 코드(optimized code)가 필요한 이유를 명확히 보여줍니다.

### 2. .iloc[ ] 및 .loc[ ]를 사용하여 행과 열을 효율적으로 선택하기

### 내 모든 책을 40% 할인된 가격으로 구매하세요

이 하위 섹션에서는 pandas의 .iloc[] 및 .loc[] 함수를 사용하여 데이터프레임(DataFrame)에서 행을 효율적으로 찾고 선택하는 방법을 소개할 것입니다. iloc[]는 인덱스 번호 로케이터(index number locator)로, loc[]는 인덱스 이름 로케이터(index name locator)로 사용할 것입니다.

아래 예시에서는 포커 데이터셋(dataset)의 첫 500개 행을 선택할 것입니다. 먼저 .loc[] 함수를 사용하고, 그 다음 .iloc[] 함수를 사용할 것입니다.

```python
# Specify the range of rows to select
rows = range(0, 500)

# Time selecting rows using .loc[]
loc_start_time = time.time()
poker_data.loc[rows]
loc_end_time = time.time()
print("Time using .loc[] : {} sec".format(loc_end_time - loc_start_time))

# Specify the range of rows to select
rows = range(0, 500)

# Time selecting rows using .iloc[]
iloc_start_time = time.time()
poker_data.iloc[rows]
iloc_end_time = time.time()
print("Time using .iloc[]: {} sec".format(iloc_end_time - iloc_start_time))

loc_comp_time = loc_end_time - loc_start_time
iloc_comp_time = iloc_end_time - iloc_start_time
print("Difference in time: {} %".format((loc_comp_time - iloc_comp_time)/ iloc_comp_time*100))
```

이 두 방법은 구문(syntax)이 동일하지만, iloc[]는 loc[]보다 거의 70% 더 빠르게 작동합니다. .iloc[] 함수는 이미 정렬된 인덱스(index)의 순서를 활용하므로 더 빠릅니다.

1년 동안 50% 할인

행뿐만 아니라 열을 선택하는 데에도 사용할 수 있습니다. 다음 예시에서는 두 가지 방법을 모두 사용하여 처음 세 개의 열을 선택할 것입니다.

```python
iloc_start_time = time.time()
poker_data.iloc[:,:3]
iloc_end_time = time.time()
print("Time using .iloc[]: {} sec".format(iloc_end_time - iloc_start_time))

names_start_time = time.time()
poker_data[['S1', 'R1', 'S2']]
names_end_time = time.time()
print("Time using selection by name: {} sec".format(names_end_time - names_start_time))

loc_comp_time = names_end_time - names_start_time
iloc_comp_time = iloc_end_time - iloc_start_time
print("Difference in time: {} %".format((loc_comp_time - iloc_comp_time)/ loc_comp_time*100))
```

iloc[]를 사용한 열 인덱싱(column indexing)이 여전히 80% 더 빠르다는 것을 알 수 있습니다. 따라서 특정 열을 이름으로 선택하기 위해 loc[]를 사용하는 것이 더 쉽지 않은 한, 더 빠른 iloc[]를 사용하는 것이 좋습니다.

### 3. DataFrame에서 값을 효과적으로 교체하기

1년 동안 50% 할인

DataFrame에서 값을 교체하는 것은 매우 중요한 작업이며, 특히 데이터 정제(data cleaning) 단계에서는 동일한 객체를 나타내는 모든 값을 유지해야 하므로 더욱 그렇습니다.

이전에 로드했던 인기 아기 이름 데이터셋을 살펴보겠습니다:

Gender(성별) 특성(feature)을 자세히 살펴보고 고유한 값(unique values)을 확인해 봅시다:

```python
names['Gender'].unique()
```

여성 성별이 대문자와 소문자 두 가지 값으로 표현되어 있음을 알 수 있습니다. 이는 실제 데이터에서 매우 흔한 일이며, 이를 해결하는 쉬운 방법은 전체 데이터셋에서 일관성을 유지하기 위해 한 값을 다른 값으로 교체하는 것입니다.

이를 수행하는 두 가지 방법이 있습니다. 첫 번째는 단순히 교체하려는 값을 정의한 다음, 무엇으로 교체할지 정의하는 것입니다. 이는 아래 코드에 나와 있습니다:

```python
start_time = time.time()
names['Gender'].loc[names.Gender=='female'] = 'FEMALE'
end_time = time.time()
pandas_time = end_time - start_time
print("Replace values using .loc[]: {} sec".format(pandas_time))
```

두 번째 방법은 아래 코드에 나와 있는 것처럼 pandas의 내장 함수인 .replace()를 사용하는 것입니다:

### 내 모든 책을 40% 할인된 가격으로 구매하세요

```python
start_time = time.time()
names['Gender'].replace('female', 'FEMALE', inplace=True)
end_time = time.time()
replace_time = end_time - start_time
print("Time using replace(): {} sec".format(replace_time))
```

내장 함수를 사용하면 시간 복잡도(time complexity)에 차이가 있으며, .loc() 메서드를 사용하여 값의 행과 열 인덱스를 찾아 교체하는 것보다 157% 더 빠르다는 것을 알 수 있습니다.

```python
print('The differnce: {} %'.format((pandas_time- replace_time )/replace_time*100))
```

리스트를 사용하여 여러 값을 교체할 수도 있습니다. 우리의 목표는 WHITE NON-HISPANIC 또는 WHITE NON-HISP로 분류된 모든 민족을 WNH로 변경하는 것입니다. .loc[] 함수를 사용하여, 'or' 문(파이썬에서는 파이프(|)로 상징됨)을 이용하여 우리가 찾고 있는 민족의 아기들을 찾을 것입니다. 그런 다음 새 값을 할당할 것입니다. 항상 그렇듯이, 이 연산에 필요한 CPU 시간도 측정합니다.

```python
start_time = time.time()
names['Ethnicity'].loc[(names["Ethnicity"] == 'WHITE NON HISPANIC') | (names["Ethnicity"] == 'WHITE NON HISP')] = 'WNH'
end_time = time.time()
pandas_time= end_time - start_time
print("Results from the above operation calculated in %s seconds" %(pandas_time))
```

다음과 같이 .replace() pandas 내장 함수를 사용하여 동일한 연산을 수행할 수도 있습니다:

```python
start_time = time.time()
names['Ethnicity'].replace(['WHITE NON HISPANIC','WHITE NON HISP'], 'WNH', inplace=True)
end_time = time.time()
replace_time = end_time - start_time
print("Time using .replace(): {} sec".format(replace_time))
```

다시 한번 .replace() 메서드를 사용하는 것이 .loc[] 메서드를 사용하는 것보다 훨씬 빠르다는 것을 알 수 있습니다. 얼마나 빠른지 더 잘 이해하기 위해 아래 코드를 실행해 봅시다:

```python
print('The differnce: {} %'.format((pandas_time- replace_time )/replace_time*100))
```

.replace() 메서드는 .loc[] 메서드를 사용하는 것보다 87% 더 빠릅니다. 데이터가 방대하고 많은 정제가 필요한 경우, 이 팁은 데이터 정제(data cleaning)의 계산 시간을 줄이고 pandas 코드를 훨씬 더 빠르고 효율적으로 만들 것입니다.

마지막으로, 딕셔너리(dictionary)를 사용하여 DataFrame에서 단일 값과 여러 값을 모두 교체할 수도 있습니다. 하나의 명령으로 여러 함수를 교체하고 싶을 때 매우 유용할 것입니다. 딕셔너리를 사용하여 모든 남성 성별을 BOY로, 모든 여성 성별을 GIRL로 교체할 것입니다.

```python
names = pd.read_csv('Popular_Baby_Names.csv')
start_time = time.time()
names['Gender'].replace({'MALE':'BOY', 'FEMALE':'GIRL', 'female': 'girl'}, inplace=True)
end_time = time.time()
dict_time = end_time - start_time
print("Time using .replace() with dictionary: {} sec".format(dict_time))

names = pd.read_csv('Popular_Baby_Names.csv')
start_time = time.time()
names['Gender'].replace('MALE', 'BOY', inplace=True)
names['Gender'].replace('FEMALE', 'GIRL', inplace=True)
names['Gender'].replace('female', 'girl', inplace=True)
end_time = time.time()
list_time = end_time - start_time
print("Time using multiple .replace(): {} sec".format(list_time))

print('The differnce: {} %'.format((list_time- dict_time )/dict_time*100))
```

리스트로도 같은 작업을 할 수 있지만, 더 장황합니다. 두 가지 방법을 비교하면 딕셔너리가 약 22% 더 빠르게 실행된다는 것을 알 수 있습니다. 일반적으로 파이썬에서 딕셔너리를 사용하는 것은 리스트에 비해 매우 효율적입니다. 리스트를 탐색하는 것은 리스트의 모든 요소를 통과해야 하는 반면, 딕셔너리를 탐색하는 것은 항목과 일치하는 키(key)로 즉시 이동합니다. 하지만 두 구조는 목적이 다르기 때문에 비교가 다소 불공평합니다.

딕셔너리를 사용하면 여러 다른 열에서 동일한 값을 교체할 수 있습니다. 이전의 모든 예시에서는 교체할 값이 있는 열을 지정했습니다. 이제 동일한 열의 여러 값을 하나의 공통 값으로 교체할 것입니다. 모든 민족을 흑인(Black), 아시아인(Asian), 백인(White)의 세 가지 큰 범주로 분류하고자 합니다. 구문은 다시 한번 매우 간단합니다. 여기서는 중첩 딕셔너리(nested dictionary)를 사용합니다. 외부 키(outer key)는 값을 교체하려는 열입니다. 이 외부 키의 값은 또 다른 딕셔너리이며, 여기서 키는 교체할 민족이고 값은 새로운 민족(흑인, 아시아인 또는 백인)입니다.

```python
start_time = time.time()
names.replace({'Ethnicity': {'ASIAN AND PACI': 'ASIAN', 'ASIAN AND PACIFIC ISLANDER': 'ASIAN',
                             'BLACK NON HISPANIC': 'BLACK', 'BLACK NON HISP': 'BLACK',
                             'WHITE NON HISPANIC': 'WHITE', 'WHITE NON HISP': 'WHITE'}})
print("Time using .replace() with dictionary: {} sec".format (time.time() - start_time))
```

### 4. 값 선택 및 교체를 위한 모범 사례 요약

### 내 모든 책을 40% 할인된 가격으로 구매하세요

*   .iloc[] 함수를 사용하면 행과 열을 선택하는 것이 더 빠릅니다. 따라서 .loc[]를 사용하는 것이 더 쉽거나 편리하고, 속도가 우선순위가 아니거나, 한 번만 수행하는 경우가 아니라면 .iloc[]를 사용하는 것이 좋습니다.
*   내장 replace() 함수를 사용하는 것이 기존 방법을 사용하는 것보다 훨씬 빠릅니다.
*   파이썬 딕셔너리를 사용하여 여러 값을 교체하는 것이 리스트를 사용하는 것보다 빠릅니다.

이 뉴스레터(newsletter)는 개인적인 열정 프로젝트이며, 여러분의 지원이 이를 유지하는 데 도움이 됩니다. 기여하고 싶다면 몇 가지 좋은 방법이 있습니다:

*   **구독(Subscribe)**하세요. 유료 구독은 제 글쓰기를 지속 가능하게 하고 추가 콘텐츠에 대한 접근 권한을 제공합니다.
*   제 책 **번들(Bundle)**을 구매하세요. 제 실용적인 책 7권과 로드맵을 단 40% 가격으로 만나보세요.

읽어주셔서 감사하며, 독립적인 글쓰기와 연구를 지원해 주셔서 감사합니다!