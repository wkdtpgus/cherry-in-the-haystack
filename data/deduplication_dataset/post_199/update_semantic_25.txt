## AI 코딩 에이전트 성능 향상을 위한 DSPy 기반 GEPA 프롬프트 최적화 전략

이 기술 블로그 게시물은 GEPA를 활용한 DSPy 프롬프트(prompt) 최적화를 통해 인공지능(AI) 데이터 과학 분야에서 활용되는 AI 코딩 에이전트(AI coding agents)의 역량을 증진하는 방안에 대한 심층적인 분석을 제공합니다. 본 글은 다음과 같은 핵심 주제들을 다룹니다:

*   **데이터 준비 및 분석:** AI 에이전트 학습을 위한 자료 구성
*   **GEPA 메커니즘 설명:** 진화형 프롬프트 최적화 기법의 원리
*   **DSPy를 통한 GEPA 적용:** 실제 프롬프트 최적화 과정
*   **결과 및 시사점:** 최적화된 에이전트의 성능 개선 효과

Youssef Hosni · 6월 17일

저는 독자 여러분의 AI 학습 여정을 지원하고자 제 저서와 학습 로드맵을 통합한 특별 패키지를 구성했습니다. 지금 바로 이 번들 상품을 구매하시면, 인공지능 개발의 필수 지침서 8권을 단 한 번의 클릭으로 정가 대비 40% 할인된 가격에 소장하실 수 있습니다. 이 패키지에는 다음을 포함한 다양한 주제의 전자책(eBooks)이 포함되어 있습니다.

전체 스토리 읽기

---

### 1. 데이터 준비 및 분석

훈련에 사용될 자료 집합(dataset)은 당사 솔루션에서 처리된 파이썬(Python) 스크립트의 작동 이력으로 이루어져 있습니다. 이러한 실사용 데이터는 에이전트의 실제 성능을 평가하고 개선하는 데 필수적인 기반이 됩니다. 자율 분석 시스템(auto-analyst system)은 다양한 인공지능 모듈로 구성되며, 각 모듈은 특정 프로그래밍 작업을 수행하도록 설계되었습니다. 예를 들어, 전처리 담당 에이전트(pre-processing agent)는 판다스(pandas) 라이브러리를 활용하여 원시 데이터를 정제하고 가공하는 역할을 맡습니다. 또 다른 모듈인 데이터 시각화 에이전트(data visualization agent)는 플로틀리(plotly)를 이용해 다양한 형태의 도표와 그림을 만들어냅니다.

이 시스템에는 총 열두 가지의 독특한 기능 정의(signature)가 존재하며, 각 기능은 두 가지 운용 방식을 가집니다. 하나는 플래너(planner)의 지시에 따라 작동하는 버전이고, 다른 하나는 '@agent' 쿼리(query)를 통해 직접 호출되어 자체적으로 실행되는 버전입니다. 하지만 이 블로그 게시물에서는 이 기능 정의 중 네 가지와 그 두 가지 변형에만 초점을 맞출 것입니다. 이 네 가지 핵심 기능 정의만으로도 전체 코드 실행량의 대략 90%를 차지하며, 이는 무료 사용자든 유료 사용자든 대부분의 사용자가 기본적으로 활용하는 기능이기 때문입니다.

*   `preprocessing_agent` (데이터 전처리 에이전트)
*   `data_viz_agent` (데이터 시각화 에이전트)
*   `statistical_analytics_agent` (통계 분석 에이전트)
*   `sk_learn_agent` (Scikit-learn 에이전트)

자료 집합은 시스템에 내장된 기본 자료와 사용자가 직접 업로드한 자료로 구분됩니다. 저희의 목표는 어떤 최적화 방안이든 이 두 가지 유형의 데이터 모두에서 성능을 향상시키는 것입니다. 즉, 내장된 기본 데이터뿐만 아니라 사용자가 직접 올린 데이터셋(dataset)에서도 에이전트가 효과적으로 작동해야 합니다. 이러한 목표를 달성하기 위해 데이터를 계층화(stratify)해야 합니다. 이를 통해 모델이 특정 기본 데이터에만 지나치게 맞춰지지 않고, 다채로운 입력 환경에서도 유연하게 대응할 수 있도록 합니다. 사용자 업로드 데이터는 그 특성상 훨씬 더 다양하고 예측 불가능한 패턴을 가지므로, 에이전트가 이러한 현실적인 시나리오에 강건하게 대처할 수 있도록 훈련하는 것이 중요합니다.

고려해야 할 또 다른 중요한 요소는 모델 공급자(model providers)입니다. 특정 모델 공급자에게만 최적화하여 다른 공급자의 성능을 저하시키는 상황은 피해야 합니다. 참고로, 당사 플랫폼 사용자들은 주로 GPT-4o-mini와 같은 오픈AI(OpenAI)의 경제적인 모델을 선호하는 반면, 제미니(Gemini) 사용자는 주로 최고 성능 모델을 이용하는 경향이 있어 데이터에 내재된 편향성(bias)이 존재합니다. 개별 모델 단위로 평가하기에는 충분한 자료가 부족하여, 모델 공급자를 대리 지표로 활용하고 있습니다. 최고급 오픈AI(OAI) 모델과 다른 공급자의 최고급 모델을 비교했을 때, 오픈AI의 성공률은 유사한 수준을 보입니다. 이러한 편향을 최소화하고 공정한 평가를 위해, 자료 집합을 준비한 후 다음 제약 조건(constraint)을 사용하여 층화 표본(stratified sample)을 구성했습니다. 이는 에이전트의 일반화 능력을 극대화하기 위한 핵심 단계입니다:

*   전체 데이터의 20% 미만이 기본 자료(`is_default_dataset == True`)에서 유래합니다.
*   세 가지 주요 모델 공급자(OpenAI, Anthropic, Gemini) 각각 최종 표본에서 10% 이상의 비중을 차지합니다.

이 층화 과정은 다음 세 가지 필드(field)를 기준으로 이루어졌습니다:

*   `model_provider` (모델 공급자)
*   `is_successful` (성공 여부)
*   `is_default_dataset` (기본 자료 집합 여부)

층화된 표본(stratified sample)이 생성된 후, 이를 학습용 집합(training set)과 평가용 집합(test set)으로 나누어 준비했습니다. 이 엄격한 데이터 준비 과정은 에이전트가 실제 환경에서 마주할 수 있는 다양한 조건에 효과적으로 대응하고, 특정 환경에 과적합되지 않도록 보장하는 데 필수적입니다. 또한, 에이전트가 생성하는 코드의 품질, 효율성, 그리고 잠재적인 보안 취약성 등 단순한 성공/실패 여부를 넘어선 다차원적인 평가 지표를 고려하기 위한 기반을 마련합니다.

### 2. GEPA 메커니즘 설명

GEPA는 (Generic-Pareto)의 약자로, 인공지능 프롬프트(AI prompts)와 같은 언어적 요소들을 진화시키고 고도화하기 위해 자기 성찰(reflection) 기법을 활용하는 DSPy 프레임워크 기반 프로그램(program)을 위한 진화형 프롬프트 최적화 기법입니다. 이 기법은 대규모 언어 모델(LLMs)이 프로그램의 작동 경로를 면밀히 검토하고, 어떤 부분이 성공적이었고 어떤 부분이 미흡했는지 분석하며, 자연어 기반의 자기 반성(natural language reflection)을 통해 개선 방안을 제시하는 능력을 적극적으로 활용합니다. 이는 기존의 수동적인 프롬프트 엔지니어링 방식이 가지는 확장성 및 적응성 한계를 극복하는 혁신적인 접근 방식입니다.

GEPA는 다목적(Pareto) 최적화(optimization) 원리에 따라, 더 우수한 프롬프트(prompt)를 반복적으로 검증하고 선별하며, 이 과정에서 진화하는 프롬프트 후보들의 계층 구조(tree)를 형성합니다. 여기서 파레토 최적화란, 여러 가지 상충하는 목표(예: 정확도, 응답 속도, 비용, 견고성)를 동시에 고려하여, 어떤 하나의 목표를 개선하면 다른 목표가 반드시 나빠지는 지점들의 집합을 찾는 것을 의미합니다. 즉, GEPA는 단일 최적의 프롬프트를 찾는 대신, 다양한 성능 지표에서 균형을 이루는 최적의 프롬프트 세트를 찾아냅니다.

DSPy 환경에서 GEPA가 진화형 프롬프트 최적화 기법으로서 수행하는 상세한 절차는 아래와 같습니다:

1.  **초기 프롬프트 생성:** DSPy 프로그램의 각 모듈에 대한 초기 프롬프트를 생성합니다. 이는 수동으로 작성되거나 간단한 템플릿으로 시작할 수 있습니다.
2.  **실행 및 평가:** 생성된 프롬프트를 사용하여 AI 에이전트를 실행하고, 실제 데이터셋에 대한 성능을 평가합니다. 성공 여부, 코드 품질, 자원 사용량 등 다각적인 지표를 측정합니다.
3.  **LLM 기반 성찰:** 대규모 언어 모델(LLM)이 에이전트의 실행 결과와 평가 지표를 분석하여, 어떤 프롬프트가 효과적이었고 어떤 프롬프트가 실패했는지에 대한 자연어 기반의 성찰(reflection)을 수행합니다. 예를 들어, "이 프롬프트는 널(null) 값 처리에 실패했다. 널 값 검사를 포함하도록 프롬프트를 수정해야 한다"와 같은 진단을 내립니다.
4.  **프롬프트 개선 제안:** LLM은 성찰 결과를 바탕으로 현재 프롬프트의 문제점을 해결하거나 성능을 향상시킬 수 있는 새로운 프롬프트 수정안을 자연어 형태로 제안합니다.
5.  **진화적 선택 및 변이:** 제안된 개선안들을 바탕으로 기존 프롬프트에 '변이(mutation)'를 가하거나, 여러 프롬프트들을 '결합(crossover)'하여 새로운 프롬프트 후보들을 생성합니다.
6.  **파레토 최적화 적용:** 생성된 프롬프트 후보들을 다시 실행하고 평가하여, 다중 목표(Pareto) 최적화 기준에 따라 가장 우수한 프롬프트들을 선별합니다. 이 과정에서 '최적화된 프롬프트 트리'가 점진적으로 구축됩니다.
7.  **반복:** 이 과정(2단계부터 6단계)을 반복하여 점진적으로 더 강력하고 효율적인 프롬프트를 진화시킵니다.

이러한 GEPA의 접근 방식은 기존의 프롬프트 엔지니어링이 가지고 있던 '블랙박스' 문제를 해결하고, LLM 자체의 추론 및 자기 개선 능력을 활용하여 복잡한 AI 에이전트의 성능을 체계적으로 최적화할 수 있는 강력한 도구를 제공합니다. 특히, DSPy의 구조화된 LLM 프로그래밍 패러다임은 이러한 진화적 최적화 과정을 효율적으로 구현할 수 있도록 지원합니다.