# **실습 LangSmith 강좌[2/7]: LangSmith를 이용한 트레이싱(tracing)**

Author: Youssef Hosni
URL: https://youssefh.substack.com/p/hands-on-langsmith-course27-tracing

============================================================

**1년 동안 50% 할인**

AI 에이전트(agent)를 구축하면서 내부에서 실제로 무슨 일이 일어나는지 궁금했던 적이 있으신가요? 에이전트가 실패하거나 예상치 못한 결과를 생성할 때, 디버깅(debugging)은 마치 블랙박스(black box)를 조사하는 것처럼 느껴질 수 있습니다. 바로 이때 LangSmith 트레이싱(tracing)이 매우 중요해집니다. 이 튜토리얼에서는 웹에서 레시피(recipe) 정보를 검색하고 개인화된 요리 가이드를 생성하는 레시피 검색 에이전트(Recipe Discovery Agent)를 구축할 것입니다. 더 중요하게는, LangSmith 트레이싱을 사용하여 에이전트 실행의 모든 단계를 관찰하고, 그 블랙박스를 투명하고 디버깅 가능한 시스템으로 전환할 것입니다.

**목차:**
*   에이전트 아키텍처(Agent Architecture)
*   LangSmith 트레이싱 설정
*   LLM 클라이언트(Client) 래핑(Wrapping)
*   추적 가능한 함수(Traceable Functions) 구축
*   트레이싱 결과 관찰 및 이해

대규모 언어 모델(LLM) 위에 애플리케이션(application)을 구축해 본 경험이 있다면, 그 어려움을 잘 아실 것입니다. 문제가 발생했을 때, 단순한 버그(bug)인 경우는 거의 없습니다. 대신, 복잡한 실행 트리(run tree)를 통해 단일 사용자 상호작용을 추적하거나, 모델이 왜 올바르게 추론하지 못했는지 이해하기 위해 수많은 비정형 대화 속에서 의미를 찾으려 노력하게 됩니다. 그 논리를 디버깅하고 성능을 지속적으로 개선하는 방법을 알아내는 것은 종종 반복 가능한 과학이라기보다는 예측 불가능한 예술처럼 느껴질 수 있습니다. 바로 이 지점에서 LangSmith가 등장합니다. LangSmith는 전체 LLM 개발 수명 주기(lifecycle)를 위해 설계되었으며, 일반적인 가정을 뒤엎는 몇 가지 근본적인 원칙을 제시합니다.

LangSmith는 관측 가능성(observability)과 같은 필수 기능을 제공하며, 여기에는 자동화된 트레이싱(tracing) 및 디버깅(debugging)을 위한 실행 트리(run tree) 보기, 비용이 많이 드는 단계 식별, 지연 시간 병목 현상(latency bottlenecks) 분석과 같은 기능이 포함됩니다. 또한, 이 플랫폼은 평가(evaluation) 및 실험(experimentation)을 지원하여 사용자가 사용자 지정 평가자(custom evaluators)를 정의하고, 선별된 데이터셋(datasets)으로 체계적인 테스트(testing)를 수행하며, 아키텍처(architectural) 변경의 장단점(trade-offs)을 평가하기 위해 실험 결과를 나란히 비교할 수 있도록 합니다.

이 시리즈는 다음 주제를 다룰 것입니다:
*   LangSmith란 무엇인가? (게시됨!)
*   LangSmith로 트레이싱하기 (현재 보고 계신 글)
*   LangSmith의 플레이그라운드(Playground) 및 프롬프트(Prompts)
*   LangSmith의 데이터셋(Datasets) 및 평가(Evaluations)
*   LangSmith의 주석 큐(Annotation Queues)
*   LangSmith의 자동화(Automations) 및 온라인 평가(Online Evaluation)
*   LangSmith의 대시보드(Dashboards)

**내 모든 책을 버튼 하나로 40% 할인된 가격에 만나보세요**
유세프 호스니 · 6월 17일

제 책과 로드맵(roadmap)을 번들(bundle)로 만들었으니, 버튼 하나로 모든 것을 원가보다 40% 저렴하게 구매하실 수 있습니다. 이 번들에는 다음을 포함한 8개의 전자책(eBook)이 포함되어 있습니다: 전체 이야기 읽기

**1. 에이전트 아키텍처(Agent Architecture)**

**내 모든 책을 40% 할인된 가격에 만나보세요**

저희 레시피 에이전트는 간단한 두 단계의 파이프라인(pipeline)을 따릅니다. 먼저, DuckDuckGo를 사용하여 웹에서 레시피 정보를 수집합니다. 그런 다음, 이 정보를 언어 모델(language model)에 전달하여 모든 것을 유용한 요리 가이드로 형식화합니다. 개념은 간단하지만, 이 파이프라인을 통해 데이터(data)가 어떻게 흐르는지 관찰하면 성능, 비용 및 잠재적인 개선 사항에 대한 중요한 통찰력을 얻을 수 있습니다.

**2. LangSmith 트레이싱 설정**

**내 모든 책을 40% 할인된 가격에 만나보세요**

에이전트 코드(code)에 들어가기 전에 LangSmith를 올바르게 구성해야 합니다. 여기서 작업 순서는 매우 중요합니다. LangChain 라이브러리(libraries)를 임포트(import)하기 전에 환경 변수(environment variables)를 설정해야 합니다. 그렇지 않으면 트레이싱이 제대로 초기화되지 않습니다.

```python
import os
from google.colab import userdata

# Set environment variables FIRST
os.environ[”LANGSMITH_TRACING”] = “true”
os.environ[”LANGSMITH_ENDPOINT”] = “https://api.smith.langchain.com”
os.environ[”LANGSMITH_PROJECT”] = “recipe-discovery-agent”
os.environ[”LANGSMITH_API_KEY”] = userdata.get(”LANGSMITH_API_KEY”)
OPENROUTER_API_KEY = userdata.get(’OPENROUTER_API_KEY’)
```

LANGSMITH_TRACING을 "true"로 설정함으로써, LangSmith에게 에이전트로부터 실행 데이터(execution data)를 자동으로 수집하도록 지시하는 것입니다. 프로젝트(project) 이름은 이러한 트레이스(traces)가 대시보드(dashboard)에 어디에 나타날지 결정하여, 다양한 실험(experiments)이나 애플리케이션(applications)을 더 쉽게 정리할 수 있도록 합니다. 이 에이전트의 경우, 저는 더 전문화된 API(API) 대신 DuckDuckGo 검색을 선택했습니다. 그 이유는 실용적입니다. DuckDuckGo는 API 키(key)가 필요 없으므로 튜토리얼(tutorials) 및 실험에 완벽합니다. 이는 우리의 필요에 잘 맞는 구조화된 검색 결과(structured search results)를 반환합니다.

**1년 동안 50% 할인**
```python
from langchain_community.tools import DuckDuckGoSearchResults
search_tool = DuckDuckGoSearchResults(max_results=3)
```

DuckDuckGo가 이 데모(demo)에 훌륭하지만, 실제 운영 환경(production) 애플리케이션은 Tavily Search(AI에 최적화된 결과 제공) 또는 Wikipedia(더 백과사전적인 정보 제공)와 같은 대안으로부터 이점을 얻을 수 있습니다. LangChain의 도구 추상화(tool abstraction)의 장점은 나중에 이들을 교체할 때 최소한의 코드 변경만 필요하다는 것입니다.

**3. LLM 클라이언트(Client) 래핑(Wrapping)**

**내 모든 책을 40% 할인된 가격에 만나보세요**

이제 흥미로운 부분이 시작됩니다. 단순히 LLM을 호출하는 것만으로는 LangSmith에서 상세한 트레이스(traces)를 얻을 수 없습니다. LangSmith의 `wrap_openai` 함수(function)로 클라이언트(client)를 래핑(wrap)해야 합니다. 이 래퍼(wrapper)는 모든 API 호출을 가로채고 전체 프롬프트(prompt), 응답(response), 토큰(token) 개수, 타이밍(timing) 정보를 포함한 완전한 상호작용을 기록합니다.

```python
from langsmith.wrappers import wrap_openai
from openai import OpenAI

openrouter_client = wrap_openai(
    OpenAI(
        base_url=”https://openrouter.ai/api/v1”,
        api_key=OPENROUTER_API_KEY,
    )
)
```

이 래퍼가 없으면, 트레이스에는 함수가 LLM을 호출했다는 것만 표시되고 실제로 무엇이 전송되거나 수신되었는지는 볼 수 없을 것입니다. 이러한 가시성(visibility)은 프롬프트 문제(prompt issues)를 디버깅하거나 토큰 사용량(token usage)을 최적화할 때 매우 중요해집니다.

**4. 추적 가능한 함수(Traceable Functions) 구축**

**내 모든 책을 40% 할인된 가격에 만나보세요**

LangSmith의 마법은 `@traceable` 데코레이터(decorator)를 통해 일어납니다. `@traceable`로 장식된 모든 함수는 입력(inputs), 출력(outputs), 실행 시간(execution time) 및 호출 계층(call hierarchy) 내에서의 위치를 자동으로 기록합니다. 에이전트의 각 함수를 살펴보겠습니다.

**레시피 검색**

**1년 동안 50% 할인**