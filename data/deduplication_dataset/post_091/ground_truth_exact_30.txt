클라인(Cline), 3,200만 달러 시드+A 투자 유치 및 AI 코딩 에이전트 시장의 혁신

클라인(Cline)은 오늘 3,200만 달러 규모의 시드+A(Seed+A) 투자를 발표합니다. 끊임없이 등장하는 VSCode 포크(fork)(Kiro)와 터미널 에이전트(terminal agent)(Warp 2.0, Charm Crush, Augment CLI)의 시대에, 무료 오픈 소스(open source) VSCode 확장 프로그램(extension)이 2025년에 왜 이렇게 잘 나갈까요? AI 코딩 전쟁이 격화되면서, 이 분야의 새로운 진입자들에 대한 수요는 무한해 보입니다. 올해 1월, 클라인(Cline)은 VS Code, 커서(Cursor), 윈드서프(Windsurf)와 호환되는 AI 엔지니어 확장 프로그램(extension)을 출시했습니다. 출시 6개월 만에 200만 다운로드(download)에 육박하고 있습니다.

AI 코딩 에이전트 시장은 2025년에도 여전히 뜨겁습니다. 클라인(Cline)은 단순한 코드 생성 도구를 넘어, 개발자의 전체 워크플로우를 혁신하는 에이전트 기반 솔루션으로 자리매김하고 있습니다. 이러한 성공의 배경에는 기존 패러다임을 뒤집는 독창적인 접근 방식과 기술적 우위가 있습니다.

**플랜 & 액트(Plan & Act)와 코딩을 위한 RAG(Retrieval Augmented Generation)가 죽은 이유**
클라인(Cline) 팀이 일반적인 AI IDE 워크플로우(workflow)에 도입한 첫 번째 변화는 순차적 채팅(sequential chat)에서 모델이 필요한 변경 사항의 개요를 만들고 이를 실행하는 플랜 + 액트(plan + act) 방식으로 전환한 것입니다. 이 모드의 주요 차이점 중 하나는 RAG(즉, 코드베이스(codebase)를 인덱싱(indexing)하고 의미론적 검색(semantic search)을 수행)에서 에이전트 기반 검색(agentic search)으로 넘어가는 것입니다. RAG가 정신 바이러스(mind virus)라는 파쉬(Pash)의 블로그 게시물을 여기에서 읽을 수 있습니다. 이 모든 것은 클라인(Cline)에게 몇 가지 다른 요소를 포함하는 새로 만들어진 "컨텍스트 엔지니어링(context engineering)" 관행과 연결됩니다.

사우드(Saoud) [00:02:02]: 네, 제가 플랜 앤 액트(plan and act)를 처음 고안한 공로를 차지하겠습니다. 좋습니다. 클라인(Cline)은 개발자가 상호 작용할 수 있는 두 가지 모드(mode)를 갖는 개념을 처음으로 제시했습니다. 클라인(Cline)이 실제로 입력 필드(input field)만 있었을 때, 사용자들과 이야기하고 그들이 클라인(Cline)을 어떻게 사용하는지 살펴보면서, 많은 사용자들이 에이전트(agent)와 함께 작업을 시작하고, 에이전트(agent)에게 수행하기를 원하는 작업에 대한 일종의 아키텍처 계획(architecture plan)을 마크다운 파일(markdown file)로 작성하도록 요청하는 것을 발견했습니다. 그래서 우리는 사람들이 이 워크플로우(workflow)를 유기적으로 스스로 만들어내는 것을 보았습니다. 그래서 우리는 그것을 제품에 어떻게 적용할 수 있을지 생각했습니다. 그래서 새로운 사용자들에게는 그 패턴(pattern)을 스스로 익힐 필요가 없고, 사용자가 모드(mode)를 전환할 때마다 에이전트(agent)가 이러한 다른 모드(mode)를 따르도록 지시하고 가드레일(guardrails)을 설정할 수 있도록 하는 것이 좀 더 직관적입니다. 예를 들어, 플랜 모드(plan mode)에서는 에이전트(agent)가 더 탐색적(exploratory)으로 행동하고, 더 많은 파일을 읽고, 더 많은 데이터를 얻고, 더 많은 데이터를 얻고, 더 많은 데이터를 얻도록 지시받습니다. 사용자가 달성하고자 하는 작업이 무엇이든 간에 공격 계획(plan of attack)을 세우기 위해 관련 정보를 이해하고 컨텍스트(context)를 채웁니다. 그리고 액트 모드(act mode)로 전환하면, 에이전트(agent)는 계획을 보고 실행하기 시작하고, 명령을 실행하고, 파일을 편집하라는 지시를 받습니다. 그리고 이것은 에이전트(agent)와 함께 작업하는 것을 조금 더 쉽게 만듭니다. 특히 클라인(Cline)과 같은 경우, 많은 경우 사람들이 플랜 모드(plan mode)에서 주로 참여하며, 많은 주고받음(back and forth)이 있습니다. 개발자로부터 컨텍스트(context)를 추출하고, 질문을 하고, 예를 들어, 테마(theme)를 어떻게 보이게 하고 싶은지, 웹사이트(website)에 어떤 페이지(page)를 원하는지 등 사용자가 초기 프롬프트(prompt)에 넣지 않았을 수도 있는 모든 종류의 정보를 추출하려고 합니다. 사용자가 '좋아, 이제 에이전트(agent)가 가서 이 작업을 하도록 할 준비가 되었어'라고 느끼면, 액트 모드(act mode)로 전환하고, 자동 승인(auto approve)을 확인하고, 발을 뻗고 커피를 마시거나 다른 일을 하면서 에이전트(agent)가 작업을 완료하도록 합니다. 그래서, 네, 대부분의 참여는 플랜 모드(plan mode)에서 이루어집니다. 그리고 액트 모드(act mode)에서는, 주로 잘못된 방향으로 갈 때 경로를 수정하기 위해 무슨 일이 일어나고 있는지 주변 시야(peripheral vision)만 가집니다. 하지만 대부분의 경우, 그들은 모델이 작업을 완료할 것이라고 믿을 수 있습니다.

**컨텍스트 엔지니어링(Context Engineering)의 핵심 요소**
이 모든 것은 클라인(Cline)에게 몇 가지 다른 요소를 포함하는 새로 만들어진 "컨텍스트 엔지니어링(context engineering)" 관행과 연결됩니다:
동적 컨텍스트 관리(Dynamic Context Management): 실시간으로 파일 콘텐츠(file content)를 지능적으로 읽고 요약하는 전략을 사용하여 컨텍스트 윈도우(context window)를 압도하지 않으면서 컨텍스트(context)가 관련성 있고 최신 상태를 유지하도록 합니다.
AST(Abstract Syntax Tree) 기반 분석(AST-Based Analysis): 추상 구문 트리(Abstract Syntax Tree, AST)를 사용하여 코드의 관련 부분을 정확하게 식별하고 추출하여 파일의 정확한 탐색 및 조작을 돕습니다.
내러티브 무결성(Narrative Integrity): 과거 상호 작용을 요약하고 주요 정보를 유지하여 길거나 복잡한 작업 중 컨텍스트(context) 정확성을 유지함으로써 작업 전반에 걸쳐 지속적인 내러티브 일관성을 보장합니다.
메모리 뱅크(Memory Bank): 명시적인 입력 없이 필수적인 "부족 지식(tribal knowledge)"과 개발자 선호도를 캡처하고 유지하는 메커니즘을 개발하여 보다 개인화되고 컨텍스트(context)를 인지하는 상호 작용을 촉진합니다.

클라인(Cline)의 이러한 컨텍스트 엔지니어링 접근 방식은 최신 대규모 언어 모델(LLM)의 잠재력을 최대한 활용합니다. 과거 RAG 방식은 코드베이스를 작은 조각으로 나누어 벡터 임베딩(vector embedding)으로 변환하고 유사도 검색(similarity search)을 통해 관련성 높은 코드 스니펫(code snippet)을 찾아내는 데 중점을 두었습니다. 그러나 이러한 방식은 코드의 논리적 흐름과 구조를 파악하는 데 한계가 있었으며, 때로는 관련 없는 조각들이 섞여 모델을 혼란스럽게 만들기도 했습니다.

클라인(Cline)의 에이전트 기반 검색(agentic search)은 개발자가 새로운 코드베이스를 탐색하는 방식과 유사합니다. 에이전트가 폴더 구조를 확인하고, 주요 파일을 읽고, 임포트(import) 및 의존성(dependency)을 따라가며, 필요한 정보를 능동적으로 찾아 컨텍스트를 구축합니다. 이는 모델이 코드의 전체적인 맥락과 개발자의 의도를 더 정확하게 이해하도록 돕습니다. 최근에는 적응형 컨텍스트 윈도우(adaptive context window) 기술이 발전하여, 모델이 작업의 복잡도에 따라 컨텍스트 윈도우의 크기를 동적으로 조절하거나 계층적 컨텍스트(hierarchical context) 관리 기법을 사용하여 중요도가 높은 정보는 항상 유지하고 덜 중요한 정보는 압축하거나 요약하는 방식이 도입되고 있습니다. 예를 들어, AST 기반 분석은 단순한 코드 검색을 넘어, 특정 함수의 모든 호출 지점(call site)을 찾아내거나, 특정 타입(type)의 모든 인스턴스(instance)를 식별하여 대규모 리팩토링(refactoring) 작업을 안전하게 수행하는 데 활용될 수 있습니다.

**모두를 위한 MCP (Multi-Agent Communication Protocol)**
클라인(Cline)은 또한 매우 초기에 MCP(Multi-Agent Communication Protocol)에 집중했으며, 이미 자체 마켓플레이스(marketplace)를 출시했습니다. 우리는 가장 인기 있는 MCP가 무엇인지 물었고, 그들의 MCP 마켓플레이스(marketplace)에서 찾을 수 있는 "일반적인 용의자" 목록을 얻었습니다:
파일 시스템 MCP(File System MCP): 파일 및 디렉토리(directory) 관리용.
브라우저 자동화 MCP(Browser Automation MCP): 웹 작업을 위한 플레이라이트(Playwright), 퍼페티어(Puppeteer), 브라우저 툴(Browser Tools).
깃 툴(Git Tools): 저장소(repository) 상호 작용 및 버전 관리용.
문서 검색(Documentation Retrieval, Context 7): 문서 라이브러리(library)에 쉽게 접근할 수 있습니다.
서드파티 통합(Third-party integrations): 일반적인 코딩 환경을 넘어선 작업을 위한 슬랙(Slack), 퍼플렉시티 리서치(Perplexity Research), 유니티(Unity), 에이블톤(Ableton).
놀라운 점은 MCP가 비기술직 사람들에게도 킬러 기능(killer feature)이라는 것이었습니다. 코딩을 전혀 하지 않지만 워크플로우 자동화 플랫폼(workflow automation platform)으로 클라인(Cline)을 사용하는 사용자들이 있으며, 두 가지 주요 사용 사례는 다음과 같습니다:
자동화된 마케팅 및 소셜 미디어: 레딧(Reddit) 및 트위터(Twitter) MCP 통합을 활용하여 IDE 내에서 콘텐츠 스크래핑(content scraping) 및 게시물 생성을 자동화합니다.
프레젠테이션 생성: 비기술직 사용자들이 음성 메모(voice notes)를 필사하고 자동으로 전문적인 프레젠테이션(presentation)으로 포맷(format)하여 전체 슬라이드 덱(slide deck)을 생성했습니다. (코드를 슬라이드 프레임워크(slides framework)로 사용하므로 코딩 관련(coding-adjacent)이라고 주장할 수도 있지만, 그래도 놀랍습니다!)

MCP 생태계는 클라인(Cline)의 핵심 강점 중 하나입니다. 클라인(Cline)은 특정 프로그래밍 언어나 프레임워크(framework)에 특화된 MCP, 예를 들어 리액트(React) 컴포넌트(component) 생성 MCP나 AWS 클라우드 리소스(cloud resource) 관리 MCP 등 다양한 전문 MCP들을 통합하며 그 활용 범위를 넓히고 있습니다. 이러한 MCP들은 개발자가 복잡한 클라우드 아키텍처를 배포하거나, 특정 프레임워크의 보일러플레이트(boilerplate) 코드를 생성하는 등 반복적인 작업을 자동화하는 데 큰 도움을 줍니다.

MCP 수익화의 미래에 대한 논의도 활발합니다. 현재는 API 키 기반의 구독 모델이 주를 이루지만, 장기적으로는 에이전트 간의 마이크로트랜잭션(microtransaction)이나 스마트 컨트랙트(smart contract)를 활용한 자동 결제 시스템이 등장할 수 있습니다. 에이전트가 필요한 도구를 사용하고 그에 대한 비용을 실시간으로 지불하는 방식이 가능해진다면, MCP 생태계는 더욱 폭발적으로 성장할 것입니다. 물론 이러한 시스템에는 강력한 보안과 신뢰 메커니즘이 필수적입니다. 클라인(Cline)은 MCP 서버의 잠재적 위험을 인지하고, 샌드박싱(sandboxing) 기술과 평판 시스템(reputation system)을 도입하여 사용자들이 안심하고 MCP를 활용할 수 있도록 노력하고 있습니다.

**클라인(Cline)이 VS Code 확장 프로그램(Extension)인 이유, 포크(Fork)가 아닌 이유**
사우드(Saoud) [00:09:09]: 그리고 VS Code 확장 프로그램(extension)이라는 것은 사용자 OS(Operating System)에 접근하고, 사용자 터미널(terminal)에 접근하며, 파일을 읽고 편집할 수 있는 흥미로운 기능을 제공합니다. 확장 프로그램(extension)이라는 것은 많은 개발자들에게 온보딩(onboarding) 마찰을 크게 줄여줍니다. 그들은 새로운 애플리케이션(application)을 설치할 필요가 없거나, 조직 내에서 사용 승인을 받기 위해 내부적인 복잡한 절차를 거칠 필요가 없습니다. 그래서 마켓플레이스(marketplace)는 우리에게 엄청난 배포(distribution) 기회를 제공했으며, 데스크톱(desktop) 파일에 접근하거나, 터미널(terminal)에서 실행하거나, 코드를 편집하고, VS Code의 멋진 UI(User Interface)를 활용하여 예를 들어 파일 변경 전후의 차이 보기(diff views)를 보여주는 것과 같은 것에 완벽한 통로입니다. 스윅스(Swyx) [00:09:59]: VS Code를 포크(fork)하고 싶은 유혹은 없었습니까? 지금쯤 30억 달러를 벌고 있을 수도 있었을 텐데요. 사우드(Saoud) [00:10:05]: 글쎄요, 아니요, 저는 VS Code를 포크(fork)해야 하는 사람들을 불쌍히 여깁니다. 왜냐하면 마이크로소프트(Microsoft)는 이러한 포크(fork)를 유지 관리하기를 악명 높게 어렵게 만들기 때문입니다. 그래서 VS Code가 만드는 모든 업데이트(update)에 맞춰 포크(fork)를 최신 상태로 유지하는 데 많은 자원과 노력이 들어갑니다. 알겠습니다. 스윅스(Swyx) [00:10:23]: 그들이 비공개 저장소(private repo)를 가지고 있고 그것을 동기화(sync)해야 하기 때문입니까? 그런 것은 없습니까? 정확합니다. 정확합니다. 그리고 그런 종류의 오픈 소스(open source) 프로젝트(project) 중 하나입니다. 사우드(Saoud) [00:10:31]: 맞습니다. 그리고 VS Code는 너무 빠르게 움직여서, 병합 충돌(merge conflicts)과 같은 문제뿐만 아니라 백엔드(back end)에서도 온갖 종류의 문제에 부딪힐 것이라고 확신합니다. 그들은 항상 예를 들어 VS 마켓플레이스 API(VS Marketplace API)에 대한 개선 사항과 변경 사항을 만들고 있습니다. 그리고 그것을 리버스 엔지니어링(reverse engineer)하고, 사용자들이 그런 것들을 사용하는 데 문제가 발생하지 않도록 하는 방법을 알아내는 것은, VS Code 포크(fork)를 유지 관리해야 하는 누구에게나 엄청난 골칫거리(huge headache)일 것이라고 확신합니다. 그리고 확장 프로그램(extension)이라는 것은 우리에게 훨씬 더 많은 배포(distribution)를 제공합니다. 당신은 우리를 사용하거나 다른 누군가를 사용해야 합니다. 당신은 커서(Cursor)나 윈드서프(Windsurf) 또는 VS Code에서 클라인(Cline)을 사용할 수 있습니다. 그리고 저는 클라인(Cline)이 이 모든 것을 정말 잘 보완한다고 생각합니다. 왜냐하면 우리는 사용자들과 정말 긴밀하게 협력하여 최고의 에이전트 경험(agentic experience)이 무엇인지 알아낼 기회를 얻기 때문입니다. 반면에 커서(Cursor)와 윈드서프(Windsurf), 코파일럿(Copilot)은 전체 개발자 경험(developer experience), 인라인 코드 편집(inline code edits), Q&A(Question & Answer), 코드를 작성하는 데 필요한 모든 부가 기능(bells and whistles)에 대해 생각해야 합니다. 맞습니다. 맞습니다. 맞습니다. 맞습니다. 그래서 저는 우리가 미래 프로그래밍(programming)이라고 생각하는 것, 즉 이 에이전트 패러다임(agentic paradigm)에 집중할 것이라고 생각합니다. 그리고 모델이 더 좋아짐에 따라, 사람들은 점점 더 자연어(natural language)를 사용하고 에이전트(agent)와 함께 작업하며, 세부 사항에 얽매이거나 코드를 편집하고 탭 자동 완성(tab autocomplete)을 사용하는 일은 줄어들게 될 것입니다. 파쉬(Pash) [00:11:42]: 네, VS Code의 포크(fork)를 유지 관리하는 데 얼마나 많은 자원을 소비해야 할지 상상해 보세요. 우리는 핵심 에이전트 루프(agentic loop)에 집중하고, 출시되는 다양한 모델 제품군(model family)에 대해 최적화하고, 그들을 지원할 수 있습니다. 이 모든 것에는 너무나 많은 작업이 필요해서, 옆에서 포크(fork)를 유지 관리하는 것은 우리에게 엄청난 방해가 될 것이고, 저는 그것이 정말 가치 있다고 생각하지 않습니다.

클라인(Cline)이 VS Code 확장 프로그램으로 존재하며, 포크(fork)가 아닌 이유는 전략적인 선택입니다. 이는 클라인(Cline)이 핵심 에이전트 기능 개발에 집중하고, VS Code가 제공하는 풍부한 개발 환경과 강력한 확장성(extensibility)을 활용하기 위함입니다. VS Code의 디버깅(debugging) 도구, Git 통합, 다양한 언어 지원, 그리고 직관적인 UI는 클라인(Cline) 에이전트가 개발자의 워크플로우에 자연스럽게 녹아들 수 있는 기반을 제공합니다. 또한, 오픈 소스 커뮤니티(open source community)의 활발한 참여와 마이크로소프트의 지속적인 업데이트는 클라인(Cline)이 별도의 노력을 들이지 않고도 최신 개발 환경을 유지할 수 있게 합니다. 클라인(Cline)은 이러한 접근 방식을 JetBrains, NeoVim, CLI 등 다른 주요 개발 환경으로도 확장하여 더 많은 개발자에게 에이전트 기반 코딩의 이점을 제공할 계획입니다.

**프로그래밍 에이전트(Agent)의 경제적 가치 및 엔터프라이즈(Enterprise) 성장**
알레시오(Alessio) [00:12:07]: 당신이 이야기할 때, 저는 '우리는 프로그래밍(programming)의 미래를 위한 최고의 것이 되고 싶다'는 것과 '이것은 비프로그래밍(non-programming)에도 훌륭하다'는 구분을 듣습니다. MCP 서버(server)를 사용하는 사람들이 점점 더 많아지고, 특히 덜 기술적인 일을 하는 것을 보는 것이 최근의 일입니까? 그리고 그것은 흥미로운 분야입니다. 네. 네. 네. 네. 제 말은, 여전히 오늘날 판매되는 것 중 가장 높은 종류의 경제적 가치(economic value)를 가진 것이라는 거죠. 더 자세히 공유해 주실 수 있는지 궁금합니다. 사우드(Saoud) [00:12:34]: 경제적 가치(economic value) 측면에서, 프로그래밍(programming)은 현재 언어 모델(language models)에게 가장 높은 비용 대비 이점(cost to benefit)을 제공합니다. 그리고 저는, 아시다시피, 많은 모델 연구소(model labs)들이 오픈아이(OpenAI)와 앤트로픽(Anthropic)이 1년 전보다 코딩(coding)을 훨씬 더 진지하게 받아들이고 있다는 것을 인식하고 있다고 생각합니다. 우리가 본 것은, 네, MCP 생태계(ecosystem)가 성장하고 있고 많은 사람들이 프로그래밍(programming) 외의 일에 그것을 사용하고 있지만, 주요 사용 사례(use case)는 대부분 개발자 작업입니다. 몇 주 전 해커 뉴스(Hacker News)에 한 개발자가 버그(bug) 있는 클라우드플레어 워커(Cloudflare worker)를 배포하고 센트리(Sentry) MCP 서버(server)를 사용하여 스택 트레이스(stack trace)를 가져온 다음, 클라인(Cline)에게 스택 트레이스(stack trace) 정보를 사용하여 버그(bug)를 수정하고, 깃허브(GitHub) MCP 서버(server)에 연결하여 이슈(issue)를 닫고, 클라우드플레어(Cloudflare)에 수정 사항을 배포하도록 요청했다는 기사가 있었습니다. 이 모든 것이 클라인(Cline) 내에서 자연어(natural language)를 사용하여 이루어졌습니다. VS Code를 떠날 필요가 없었고, 개발자가 스스로 알아내고 개발 환경(developer environment)을 떠나야 하는 인지 과부하(cognitive overload)를 겪어야 했을 모든 서비스(service)와 상호 작용합니다. 본질적으로 에이전트(agent)가 백그라운드(background)에서 자연어(natural language)만 사용하여 할 수 있었던 일을 말이죠. 그래서 저는 이것이 미래의 방향이라고 생각합니다. 애플리케이션 계층(application layer)이 이전에 수동으로 상호 작용해야 했던 모든 다른 서비스(service)와 연결되고, 자연어(natural language)를 사용하여 상호 작용하는 단일 접점(single point of contact)이 되는 것입니다. 그리고 당신이 코드에 덜 관여하고, 에이전트(agent)가 무엇을 하는지에 대한 높은 수준의 이해를 가지고 경로를 수정할 수 있게 되는 것입니다. 저는 그것이 우리에게 중요한 또 다른 부분이며, 이 엄청나게 시끄러운 공간에서 우리가 두각을 나타낼(cut through the noise) 수 있게 해준 것이라고 생각합니다. 많은 사람들이 미래가 어디로 향하는지에 대해 정말 거창한 아이디어(grand ideas)를 가지고 있다고 생각하지만, 우리는 오늘날 사람들에게 유용한 것에 대해 정말 광적으로 집착했습니다. 그리고 그 큰 부분은 이러한 모델의 한계(model limitations)를 이해하고, 그들이 무엇을 잘하지 못하는지 파악하며, 최종 개발자들에게 그러한 것들에 대한 충분한 통찰력(insight)을 제공하여 그들이 경로를 수정하는 방법을 알도록 하는 것입니다. 그들은 일이 잘못될 때 피드백(feedback)을 제공하는 방법을 압니다. 그래서, 예를 들어, 클라인(Cline)은 모델에 들어가는 프롬프트(prompt)에 대해, 오류가 발생했을 때 왜 오류가 발생했는지에 대해, 모델이 호출하는 도구를 볼 수 있습니다. 우리는 작업을 수행하는 각 단계에서 모델이 정확히 무엇을 하는지에 대해 가능한 한 많은 통찰력(insight)을 제공하려고 노력합니다. 그래서 일이 잘못되거나 잘못된 방향으로 가기 시작할 때, 당신은 피드백(feedback)을 주고 경로를 수정할 수 있습니다. 저는 경로 수정 부분이 엄청나게 중요하며, 작업을 완료하는 데 있어서, 예를 들어 백그라운드 에이전트(background agent) 작업을 시키고 몇 시간 후에 돌아왔을 때 완전히 잘못되어 있고 당신이 기대했던 어떤 것도 하지 않았을 때보다 훨씬 더 빠르게 작업을 완료할 수 있다고 생각합니다. 그리고 몇 번 다시 시도해야만 제대로 작동합니다. 알레시오(Alessio) [00:15:16]: 센트리(Sentry) 예시는 훌륭하다고 생각합니다. 왜냐하면 어떤 면에서는 MCP가 제품 자체를 잠식하는 것 같기 때문입니다. 저는 센트리(Sentry) MCP를 사용하기 시작했습니다. 그리고 센트리(Sentry)는 이슈 해결 에이전트(issue resolution agent)인 '여기(here)'를 출시했는데, 처음에는 무료였습니다. 그래서 저는 센트리(Sentry)에서 그것을 켰고, 사용했는데, 훌륭했습니다. 그러다가 그들은 돈을 받기 시작했습니다. 그래서 저는 'MCP를 무료로 사용하고, 데이터를 내 코딩 에이전트(coding agent)에 넣으면, 무료로 문제를 해결하고 다시 보내줄 텐데'라고 생각했습니다. 특히 코딩(coding)에서 이런 폐쇄 루프(closed loop)를 가질 수 있는 경우를 보고 싶습니다. 예를 들어, RDS MCP가 유료 AI 서비스(paid AI offering)가 되어 그것을 연결할 수 있게 되는 경우 말이죠. 클라인(Cline)이 모든 비용을 분할하는 MCP 구독(subscription)을 가질까요? 오늘날 저에게는 그들의 구조 방식이 별로 합리적이지 않다고 느껴집니다. 파쉬(Pash) [00:16:07]: 글쎄요, 네, 우리는 아주 초기에 그랬습니다. 우리는 처음부터 MCP에 대해 낙관적이었습니다. 사우드(Saoud) [00:16:13]: 그리고 우리는 런치 파트너(launch partner)이자 금융 MCP였습니다. 죄송합니다. 방해해서요. 네, 괜찮습니다. 앤트로픽(Anthropic)이 처음 MCP를 출시하고 그들이 작업해 온 새로운 프로토콜(protocol)과 그것을 오픈 소스(open source)화하는 것에 대해 대대적으로 발표했을 때, 아무도 그것이 무엇을 의미하는지 제대로 이해하지 못했습니다. 그리고 저는 그것이 어떻게 작동하고 왜 중요한지에 대한 그들의 문서를 정말 깊이 파고드는 데 시간이 좀 걸렸습니다. 저는 그들이 오픈 소스(open source) 커뮤니티(community)가 생태계(ecosystem)에 기여하여 그것이 정말 성공할 수 있도록 하는 데 베팅(bet)했다고 생각하고 싶습니다. 그래서 저는 가능한 한 그것을 돕고 싶었습니다. 그래서 오랫동안 클라인(Cline) 시스템 프롬프트(system prompt)의 대부분은 'MCP는 어떻게 작동하는가?'였습니다. 왜냐하면 당시에는 너무 새로운 것이어서 모델들이 그것에 대해 아무것도 몰랐고 MCP 서버(server)를 만드는 방법도 몰랐기 때문입니다. 그래서 개발자가 무언가를 만들고 싶다면, 그것에 정말 능숙할 것입니다. 그리고 저는 클라인(Cline)이 그 이후로 MCP 생태계(ecosystem)가 얼마나 성장했는지에 대해 어느 정도 기여했다고 생각하고 싶습니다. 그리고 개발자들에게 내부적으로(under the hood) 어떻게 작동하는지에 대한 더 많은 통찰력(insight)과 인식을 제공하는 것이, 이러한 것들을 개발하는 것은 물론이고 사용하는 데 있어서도 엄청나게 중요하다고 생각합니다. 그래서, 네, 우리가 클라인(Cline)에서 MCP를 출시했을 때, 우리 디스코드(Discord) 사용자들은 그것을 이해하려고 애썼던 것을 기억합니다. 그리고 클라이언트(client)들이 MCP 서버(server)를 처음부터 구축하는 것을 보면서, 그들은 '아, 알겠다'고 했습니다. 그들은 점들을 연결하기 시작했습니다. '이것이 내부적으로(under the hood) 작동하는 방식이다. 이것이 유용한 이유다. 에이전트(agent)가 이러한 도구와 서비스(service) 및 API(Application Programming Interface)에 연결하는 방식이며, 이런 종류의 작업을 직접 해야 하는 많은 번거로움을 덜어주었다.' 파쉬(Pash) [00:17:37]: 그 당시에는 사람들이 여전히 MCP를 이해하려고 노력하던 초기였습니다. 그리고 발견 가능성(discoverability)에 큰 문제가 있었습니다. 그래서 지난 2월쯤, 우리는 MCP 마켓플레이스(marketplace)를 출시했습니다. 거기서 실제로 클라이언트(client)가 리드미(readme)를 보고, 깃허브(GitHub)에 연결된 전체 MCP 서버(server)를 처음부터 설치하고 즉시 실행할 수 있는 원클릭 설치 프로세스(process)를 가질 수 있었습니다. 그리고 그것이, 제 생각에는 그 무렵에 MCP가 마켓플레이스(marketplace) 출시와 함께 정말 이륙하기 시작했습니다. 사람들이 MCP를 발견하고, MCP 마켓플레이스(marketplace)에 기여할 수 있게 된 것이죠. 그 이후로 우리는 150개 이상의 MCP 서버(server)를 등록했습니다. 그리고 우리 마켓플레이스(marketplace)의 인기 MCP는 수십만 다운로드(download)를 기록했습니다. 사람들이 그것들을 사용합니다. 그리고, 아시다시피, 당신이 언급했듯이 '사람들이 기존 제품을 어떻게 잠식하는가'와 같은 정말 주목할 만한 예시들이 있습니다. 하지만 동시에 우리는 사람들이 MCP를 수익화(monetizing)하는 생태계(ecosystem)가 진화하는 것을 보기 시작했습니다. 주목할 만한 예시로는 21세기 개발 매직 MCP 서버(server)가 있습니다. 이 서버는 이 코딩 에이전트(coding agent)에 약간의 취향을 주입하여 LLM(Large Language Model)에 아름다운 컴포넌트(component) 라이브러리(library)를 가지고 관련 예시를 주입합니다. 그래서 클라이언트(client)가 들어가서 아름다운 UI(User Interface)를 구현할 수 있습니다. 그리고 그들이 그것을 수익화(monetizing)한 방식은 표준 API 키(API key)였습니다. 그래서 우리는 개발자들이 MCP를 정말 좋아하고, 그것을 구축하고, MCP 마켓플레이스(marketplace)와 클라이언트(client)와 같은 배포 플랫폼(platform)을 가지고, 그것을 중심으로 전체 비즈니스(business)를 수익화(monetizing)하는 것을 보기 시작했습니다. 그래서 이제는 거의 에이전트(agent)에게 도구를 판매하는 것과 같으며, 이는 정말 흥미로운 주제입니다.

프로그래밍 에이전트의 경제적 가치는 이미 입증되고 있으며, 특히 엔터프라이즈 환경에서 그 잠재력이 폭발적으로 증가하고 있습니다. 클라인(Cline)은 단순한 비용 절감을 넘어, 개발 생산성 향상, 버그(bug) 감소, 그리고 혁신 가속화를 통해 기업에 막대한 ROI(투자수익률)를 제공합니다. 예를 들어, 클라우드플레어 워커(Cloudflare worker)의 버그를 센트리(Sentry) MCP와 깃허브(GitHub) MCP를 통해 클라인(Cline)이 자동으로 수정하고 배포하는 사례는 개발자의 인지 부하(cognitive load)를 줄이고 문제 해결 시간을 획기적으로 단축시키는 것을 보여줍니다.

클라인(Cline)은 데이터 프라이버시(data privacy)와 보안에 대한 기업의 우려를 깊이 이해하고 있습니다. BYO-API-Key(Bring-Your-Own-API-Key) 모델을 통해 기업은 자신의 모델 제공업체와의 계약을 활용하고, 코드와 데이터가 클라인(Cline)의 서버를 거치지 않고 직접 모델로 전송되도록 할 수 있습니다. 이는 기업이 데이터 흐름을 완벽하게 통제하고, 민감한 IP(지적 재산)가 외부에 노출될 위험을 최소화할 수 있게 합니다. 또한, 클라인(Cline)은 온프레미스(on-premise) 배포 옵션과 관리형 서비스(managed service)를 제공하여 대규모 엔터프라이즈 고객의 특정 요구사항을 충족시키고 있습니다. 이러한 솔루션은 보안 취약점 스캐닝(vulnerability scanning), 규정 준수(compliance) 검사, 자동화된 코드 리뷰(code review)와 같은 전문적인 엔터프라이즈 사용 사례에 클라인(Cline)을 적용하는 데 기여합니다.

**에이전트 설계의 단순성 대 복잡성: RAG와 Fast Apply의 한계**
파쉬(Pash) [00:40:07]: 여러 면에서, 아시다시피, 우리와 포크(fork)들은 처음부터 단순함을 유지하고, 모든 것을 모델(model)에 맡기고, 추론(inference)으로 돈을 벌려고 하지 않고, 컨텍스트(context)를 적극적으로 사용하고, 파일을 컨텍스트(context)에 매우 공격적으로 읽어들이는 철학을 가진 유일한 존재였습니다. 그리고 클라우드 코드(Cloud Code)로 돌아가서, 저는 그들이 나와서 가능한 한 단순함을 유지하는 우리의 전체 철학을 입증해 주었다는 것이 정말 좋았습니다. 그리고 그것은 RAG(Retrieval Augmented Generation) 전체와도 연결됩니다. RAG는 2022년 초창기의 것이었습니다. 벡터 데이터베이스(vector database) 회사들이 생겨나기 시작했고, 컨텍스트 윈도우(context window)는 매우 작았습니다. 이것은 사람들이 '오, 당신의 AI에 무한한 기억력을 줄 수 있다'고 부르는 방식이었습니다. 실제로는 그렇지 않습니다. 하지만 그것은 이 모든 회사에 투자하는 벤처 투자자(venture backers)들에게 팔린 마케팅(marketing)이었습니다. 그리고 그것은 정말 오랫동안 지속된 내러티브(narrative)가 되었습니다. 그리고 심지어 지금도, 우리는 잠재적인 엔터프라이즈(enterprise) 고객들로부터 그들이 조달 과정(procurement process)을 거치면서 '코드베이스(codebase)를 인덱싱(indexing)하고 RAG를 사용하십니까?'와 같은 체크리스트(checklist) 질문을 받는 것을 볼 수 있습니다. 그러면 저는 '왜요? 왜 이것을 하고 싶어 하십니까?'라고 묻습니다. 저는 보리스(Boris)가 이 팟캐스트(podcast)에서 우리가 RAG를 시도했지만 특히 코딩(coding)에서는 잘 작동하지 않는다고 매우 잘 말했습니다. RAG가 작동하는 방식은 전체 저장소(repository)에 있는 모든 파일을 작은 조각으로 나누고, 그것들을 초고차원 벡터 공간(hyper dimensional vector space)에 던져 넣은 다음, 관련 코드 스니펫(code snippet)을 검색할 때 이러한 무작위 조각들을 꺼내는 것입니다. 근본적으로 그것은 너무 분열적입니다. 그리고 저는 그것이 실제로 모델(model)을 방해한다고 생각합니다. 그리고 당신은 새로운 저장소(repository)를 처음 접했을 때 선임 소프트웨어 엔지니어(senior software engineer)가 하는 것처럼, 폴더 구조를 보고, 파일을 살펴보고, '아, 이 파일이 다른 파일에서 임포트(import)되었네, 가서 저것을 보자'고 하는 것처럼 에이전트적으로 저장소(repository)를 탐색하는 것보다 더 나쁜 성능을 얻게 됩니다. 우리는 그것이 훨씬 더 잘 작동한다는 것을 발견했습니다. 그리고 비슷한 것들이 있습니다. 예를 들어, 단순함이 항상 이기는 비터 레슨(bitter lesson)처럼, 패스트 어플라이(fast apply)도 또 다른 예시입니다. 커서(Cursor)는 2024년 7월에 즉시 적용(instant apply)이라고 부르는 패스트 어플라이(fast apply)를 내놓았는데, 당시 모델은 파일을 편집하는 데 그리 능숙하지 않았습니다. 그리고 에이전트(agent)의 맥락에서 파일을 편집하는 방식은 검색 블록(search block)과 교체 블록(replace block)이 있는데, 교체하려는 것과 정확히 일치하도록 검색 블록(search block)을 일치시켜야 합니다. 그리고 교체 블록(replace block)은 그것을 바꿔버립니다. 그리고 당시 모델은 그리 능숙하지 않았습니다. 당시 내부적으로 사용하던 GPT는 이러한 검색 블록(search block)을 완벽하게 구성하는 데 그리 능숙하지 않았고, 종종 실패했습니다. 그래서 그들은 패스트 어플라이(fast apply) 모델을 미세 조정(fine tune)하는 영리한 해결책을 내놓았습니다. 당시 프런티어 모델(frontier model)들은 모호하게 만들고, 우리가 모두 익숙한 '나머지 파일은 여기, 나머지 임포트(import)는 여기'와 같은 게으른 코드 스니펫(lazy code snippet)을 출력하도록 했습니다. 그리고 그것을 미세 조정된 패스트 어플라이(fast apply) 모델에 공급했습니다. 그것은 아마도 퀀 7b(Quen 7b) 또는 양자화(quantized)된 매우 작은 모델이었을 것입니다. 그리고 그들은 이 게으른 코드 스니펫(lazy code snippet)을 이 작은 모델에 공급했고, 이 작은 모델은 코드 변경 사항이 적용된 전체 파일을 출력하도록 미세 조정되었습니다. 그리고 아더(Ader)의 창립자 중 한 명이 초기 깃허브(GitHub) 세션에서 이것을 정말 잘 말했습니다. 그는 '이제 하나의 모델이 일을 망치는 것을 걱정하는 대신, 이제 두 개의 모델이 일을 망치는 것을 걱정해야 한다'고 말했습니다. 그리고 더 나쁜 것은, 당신이 프로덕션 코드(production code)를 이 패스트 어플라이(fast apply) 모델에 넘겨주는 다른 모델은 작은 모델이고, 그 추론(reasoning)은 그리 좋지 않다는 것입니다. 최대 출력 토큰(token)은 8000 토큰, 16000 토큰일 수 있고, 이제 그들은 32000 토큰을 훈련하고 있을지도 모릅니다. 그리고 많은 코딩 파일, 예를 들어 우리 저장소(repository)에는 42000 토큰 길이의 파일이 있는데, 이것은 이러한 작은 패스트 어플라이(fast apply) 모델의 최대 토큰 출력 길이보다 깁니다. 그럼 어떻게 해야 할까요? 그런 다음 그것을 해결하기 위한 해결책을 구축해야 하고, 모든 이 인프라(infrastructure)를 구축하여 작업을 넘겨야 합니다. 그리고 그것은 실수를 저지릅니다. 그것은 매우 미묘한 실수이며, 작동하는 것처럼 보이지만 실제로는 원래의 프런티어 모델(frontier model)이 제안한 것이 아닙니다. 그리고 그것은 약간 다릅니다. 그리고 그것은 코드에 이 모든 미묘한 버그(bug)를 도입합니다. 그리고 우리가 보기 시작한 것은 AI가 발전함에 따라 애플리케이션 계층(application layer)이 줄어들고, 이러한 영리한 해결책이 더 이상 필요하지 않을 것이며, 이러한 시스템을 유지 관리할 필요가 없을 것이라는 것입니다. 그래서 RAG나 패스트 어플라이(fast apply)에 얽매이지 않고, 핵심 에이전트 루프(agentic loop)에 집중하고, diff 편집 실패를 최소화하는 것이 정말 해방감을 줍니다. 예를 들어, 우리 내부 벤치마크(benchmark)에서 클라우드 소넷 4(Cloud Sonnet 4)는 최근 5% 미만, 실제로는 약 4%의 diff 편집 실패율을 기록했습니다. 패스트 어플라이(fast apply)가 나왔을 때는 훨씬 높았고, 20%대와 30%대였습니다. 이제 우리는 4%로 떨어졌습니다. 그리고 6개월 안에 어떻게 0%가 될까요? 음, 우리가 이야기하는 동안에도 매일 0%로 가고 있습니다. 그리고 저는 실제로 패스트 어플라이(fast apply)를 하는 일부 회사의 창립자들과 이야기했는데, 그들은 우리와 협력하려고 노력하고 있습니다. 그들의 주력 사업은 이러한 패스트 어플라이(fast apply) 모델을 미세 조정(fine tune)하는 것입니다. 그리고 아시다시피, 릴레이(relays)와 모프(morph) 같은 것들이죠. 그리고 저는 이 사람들과 매우 솔직한 대화를 나눴습니다. 저는 '글쎄요, 패스트 어플라이(fast apply)가 관련성이 있었던 시기가 있습니다. 커서(Cursor)는 7월에 이 시기를 시작했습니다. 그들이 더 이상 관련성이 없어지기까지 얼마나 많은 시간이 남았다고 생각하십니까? 무한한 시간이라고 생각하십니까?'라고 물었습니다. 그들은 '아니요, 분명히 유한합니다. 이 패스트 어플라이(fast apply) 모델 시대는 분명히 끝나가고 있습니다.'라고 말했습니다. 그리고 저는 '글쎄요, 얼마나 오래 남았다고 생각하십니까?'라고 물었습니다. 그들은 '아마 3개월, 어쩌면 그보다 짧을 수도 있습니다.'라고 말했습니다.

클라인(Cline)의 철학은 에이전트 설계에서 단순함이 궁극적으로 승리한다는 "비터 레슨(Bitter Lesson)"에 뿌리를 두고 있습니다. RAG와 Fast Apply 같은 기술은 초기 LLM의 한계를 극복하기 위한 영리한 해결책이었지만, 모델 자체의 능력이 비약적으로 발전하면서 이러한 복잡한 계층은 오히려 불필요한 오버헤드(overhead)와 오류의 원인이 되고 있습니다. 현대의 LLM은 훨씬 더 긴 컨텍스트 윈도우(context window)와 정교한 지시 따르기(instruction following) 능력을 갖추고 있어, 복잡한 코드 변경도 단일 모델로 정확하게 처리할 수 있습니다. 클라인(Cline)은 이러한 모델의 발전에 발맞춰, 중간 계층을 최소화하고 모델 본연의 추론 능력에 집중함으로써, 더 안정적이고 효율적인 코딩 에이전트 경험을 제공합니다.

**비즈니스 모델: BYO-API-Key와 엔터프라이즈를 향한 여정**
클라인(Cline)의 비즈니스 모델은 "추론(inference)은 비즈니스가 아니다"라는 명확한 철학을 기반으로 합니다. 사용자는 Anthropic, OpenAI, OpenRouter 등 자신이 선호하는 모델 제공업체의 API 키(API key)를 직접 연결하여 사용합니다. 이러한 BYO-API-Key(Bring-Your-Own-API-Key) 접근 방식은 가격 투명성을 제공하고, 클라인(Cline)이 추론 비용으로 수익을 창출하는 대신 최고의 에이전트 경험을 제공하는 데 집중할 수 있게 합니다.

초기에는 오픈 소스(open source) 프로젝트로서 순수하게 커뮤니티(community)의 지원으로 성장했지만, 대규모 엔터프라이즈(enterprise) 고객들의 수요는 클라인(Cline)이 새로운 비즈니스 모델을 모색하게 만들었습니다. 많은 기업이 클라인(Cline)의 가치를 인정하면서도, 내부 보안 및 거버넌스(governance) 요구사항 때문에 오픈 소스 도구의 활용에 어려움을 겪었습니다. 이에 클라인(Cline)은 엔터프라이즈 고객을 위한 프리미엄 기능, 맞춤형 지원, 그리고 자체 호스팅(self-hosting) 옵션 등의 서비스를 제공하여 수익을 창출하고 있습니다. 이러한 서비스는 기업이 클라인(Cline)을 더 안전하고 효율적으로 도입할 수 있도록 돕고, 클라인(Cline)은 이를 통해 핵심 기술 개발에 재투자할 수 있는 선순환 구조를 구축하고 있습니다.

**미래 비전: 다중 에이전트 시스템과 메모리 진화**
클라인(Cline)은 단순한 단일 에이전트를 넘어, 미래의 다중 에이전트 시스템(multi-agent system)을 위한 기반을 다지고 있습니다. CLI 버전의 클라인(Cline)은 모듈성을 극대화하여 개발자가 여러 클라인(Cline) 인스턴스를 스핀업(spin up)하거나, GitHub 액션(action)과 같은 클라우드 환경에서 자율 에이전트(autonomous agent)로 실행할 수 있게 합니다. 이는 프론트엔드(frontend), 백엔드(backend), 테스트(testing) 등 각기 다른 전문성을 가진 에이전트들이 협력하여 대규모 프로젝트를 진행하고, 이를 메타-에이전트(meta-agent)가 조율하는 시나리오를 가능하게 합니다. 이러한 다중 에이전트 시스템에서는 에이전트 간의 효율적인 통신 프로토콜(communication protocol)과 복잡한 작업 조율(orchestration)이 핵심 과제가 될 것입니다.

메모리 시스템(memory system) 또한 클라인(Cline)의 중요한 개발 영역입니다. 현재의 단기 메모리(컨텍스트 윈도우)와 장기 메모리(지식 기반)를 넘어, 클라인(Cline)은 개발자의 암묵적 지식(implicit knowledge)과 선호도를 학습하고 유지하는 더 정교한 메모리 메커니즘을 개발하고 있습니다. 이는 그래프 데이터베이스(graph database)나 특수 임베딩(embedding)을 활용하여 코드 구조와 개발자의 작업 패턴을 장기적으로 기억하고, 이를 바탕으로 더욱 개인화되고 효율적인 지원을 제공하는 것을 목표로 합니다. 예를 들어, 특정 팀이 선호하는 코딩 스타일(coding style)이나 자주 사용하는 라이브러리(library)를 에이전트가 자동으로 학습하여, 명시적인 지시 없이도 일관된 결과물을 생성하도록 하는 것입니다.

**클라인(Cline)의 인간적인 면모와 팀 문화**
클라인(Cline)은 단순한 도구를 넘어, 개발자들에게 "그"라는 인칭 대명사가 어울리는 인간적인 에이전트로 인식되고 있습니다. 이러한 의인화(anthropomorphization)는 사용자들에게 친근함과 신뢰감을 형성하며, 에이전트와의 상호작용을 더욱 몰입감 있게 만듭니다. 클라인(Cline) 팀은 이러한 사용자 경험을 중요하게 생각하며, 에이전트가 개발자의 든든한 동료처럼 느껴지도록 지속적으로 개선하고 있습니다.

클라인(Cline)의 성공은 강력한 팀 문화와 열정적인 커뮤니티의 힘에서 비롯됩니다. 초고속으로 변화하는 AI 코딩 시장에서 경쟁력을 유지하기 위해서는 단순히 기술력뿐만 아니라, 명확한 비전과 강력한 실행력을 갖춘 팀이 필수적입니다. 클라인(Cline)은 "세상을 더 나은 곳으로 만드는 소프트웨어"라는 공동의 목표를 가진 동료들이 모여, 기술적 난제를 해결하고 새로운 패러다임을 제시하며 성장하고 있습니다. 오픈 소스 프로젝트로서 커뮤니티로부터 받은 건설적인 피드백은 클라인(Cline)의 로드맵과 제품 발전에 중요한 영감을 주었으며, 이러한 상호작용은 클라인(Cline)의 독특한 문화의 핵심입니다. 클라인(Cline)은 20명에서 100명 규모로 빠르게 성장하고 있으며, AI 코딩의 미래를 함께 만들어갈 열정적인 인재들을 적극적으로 찾고 있습니다.