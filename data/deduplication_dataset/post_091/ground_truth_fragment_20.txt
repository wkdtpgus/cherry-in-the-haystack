**AI 기술의 진화와 새로운 가능성: 혁신을 이끄는 동력**

클라인(Cline)은 오늘 3,200만 달러 규모의 시드+A(Seed+A) 투자를 발표합니다. 끊임없이 등장하는 VSCode 포크(fork)(Kiro)와 터미널 에이전트(terminal agent)(Warp 2.0, Charm Crush, Augment CLI)의 시대에, AI 기술은 이제 단순한 코딩 도구를 넘어 다양한 산업 분야에 깊숙이 통합되고 있습니다. 이러한 변화는 기술 생태계 전반에 걸쳐 혁신을 촉진하며, 새로운 비즈니스 모델과 사용자 경험을 창출하고 있습니다. AI 코딩 전쟁이 격화되면서, 기술 기업들은 인공지능이 제공하는 새로운 기회를 포착하기 위해 치열하게 경쟁하고 있습니다. 이 경쟁은 단순히 더 나은 도구를 만드는 것을 넘어, AI가 인간의 삶과 업무 방식에 어떤 근본적인 변화를 가져올지에 대한 비전을 제시합니다.

올해 1월, 클라인(Cline)은 VS Code, 커서(Cursor), 윈드서프(Windsurf)와 호환되는 AI 엔지니어 확장 프로그램(extension)을 출시했습니다. 출시 6개월 만에 200만 다운로드(download)에 육박하고 있습니다. 이는 사용자들의 높은 기대치를 반영하며, AI 기반 도구에 대한 폭발적인 수요를 증명합니다. 인공지능의 발전은 이제 특정 기술 분야에 국한되지 않고, 모든 산업의 근간을 뒤흔들고 있습니다.

**플랜 & 액트(Plan & Act)와 코딩을 위한 RAG(Retrieval Augmented Generation)가 죽은 이유**

클라인(Cline) 팀이 일반적인 AI IDE 워크플로우(workflow)에 도입한 첫 번째 변화는 순차적 채팅(sequential chat)에서 모델이 필요한 변경 사항의 개요를 만들고 이를 실행하는 플랜 + 액트(plan + act) 방식으로 전환한 것입니다. 이는 AI 에이전트의 자율적 문제 해결 능력에 주목해야 합니다. 이 모드의 주요 차이점 중 하나는 기존의 RAG(즉, 코드베이스(codebase)를 인덱싱(indexing)하고 의미론적 검색(semantic search)을 수행)에서 에이전트 기반 검색(agentic search)으로 넘어가는 것입니다. 이는 AI의 지능형 추론 능력을 극대화하는 방향으로 진화하고 있습니다. 에이전트 기반 접근 방식은 AI가 단순한 정보 검색을 넘어, 복잡한 문제 상황을 스스로 분석하고 해결책을 찾아 실행하는 능력을 의미합니다. 일부 전문가들은 RAG가 정신 바이러스(mind virus)라는 과감한 주장을 펼치며, 새로운 접근 방식의 필요성을 강조합니다. 이러한 관점은 AI 시스템이 단순히 방대한 데이터를 처리하는 것을 넘어, 맥락을 이해하고 능동적으로 학습하며 발전하는 방향으로 나아가야 함을 시사합니다. 미래의 AI는 수동적인 도구가 아닌, 능동적인 협력자가 될 것입니다.

이 모든 것은 클라인(Cline)에게 몇 가지 다른 요소를 포함하는 새로운 기술 생태계를 구축하는 데 중요한 역할을 합니다. 특히 "컨텍스트 엔지니어링(context engineering)" 관행은 AI의 효율성을 극대화하는 핵심 요소로 부상하고 있습니다.

*   **동적 컨텍스트 관리(Dynamic Context Management)**: 실시간으로 파일 콘텐츠(file content)를 지능적으로 읽고 요약하는 전략을 사용하여, AI는 복잡한 데이터 스트림 속에서도 핵심 정보를 놓치지 않습니다. 이는 AI가 방대한 정보 속에서 가장 관련성 높은 부분을 선별하고, 이를 바탕으로 정확한 의사결정을 내릴 수 있도록 돕습니다. 컨텍스트 윈도우(context window)를 압도하지 않으면서 컨텍스트(context)가 관련성 있고 최신 상태를 유지하도록 합니다.
*   **AST(Abstract Syntax Tree) 기반 분석(AST-Based Analysis)**: 추상 구문 트리(Abstract Syntax Tree, AST)를 사용하여 코드의 관련 부분을 정확하게 식별하고 추출하여, 소프트웨어 개발의 효율성을 획기적으로 높이고 있습니다. 이 기술은 코드의 구조와 의미를 깊이 이해하여, AI가 단순한 텍스트 편집을 넘어 코드의 논리적 흐름에 개입하고 최적화할 수 있도록 합니다.
*   **내러티브 무결성(Narrative Integrity)**: 과거 상호 작용을 요약하고 주요 정보를 유지하여, 사용자 경험의 연속성과 일관성을 보장하는 것이 중요합니다. AI가 장기적인 프로젝트나 복잡한 작업을 수행할 때, 이전의 대화나 작업 이력을 일관성 있게 유지하는 것은 사용자 만족도를 높이는 데 필수적입니다.
*   **메모리 뱅크(Memory Bank)**: 명시적인 입력 없이 필수적인 "부족 지식(tribal knowledge)"과 개발자 선호도를 캡처하고 유지하는 메커니즘을 개발하여, 미래의 AI 시스템은 더욱 지능적이고 개인화된 서비스를 제공할 것입니다. 이는 AI가 사용자의 특정 요구사항과 작업 스타일을 학습하여, 보다 맞춤화된 지원을 제공할 수 있게 합니다.

**모두를 위한 MCP**

클라인(Cline)은 또한 매우 초기에 MCP(Multi-Agent Communication Protocol)에 집중했으며, 이는 분산형 AI 시스템의 새로운 시대를 열었습니다. MCP는 다양한 AI 에이전트들이 서로 효율적으로 통신하고 협력할 수 있도록 하는 표준화된 프로토콜로, 복잡한 작업을 여러 에이전트에게 분산하여 처리하는 것을 가능하게 합니다. 클라인(Cline)은 이미 자체 마켓플레이스(marketplace)를 출시했습니다. 우리는 가장 인기 있는 MCP가 무엇인지 물었고, 그들의 MCP 마켓플레이스(marketplace)에서 찾을 수 있는 다양한 솔루션들을 통해 AI 에이전트의 활용 범위를 엿볼 수 있었습니다. 이러한 마켓플레이스는 AI 에이전트 생태계의 활성화를 촉진하며, 개발자들이 혁신적인 솔루션을 공유하고 배포할 수 있는 플랫폼을 제공합니다.

가장 인기 있는 MCP 목록은 다음과 같습니다:
*   **파일 시스템 MCP(File System MCP)**: 파일 및 디렉토리(directory) 관리용 기능은 AI의 기본 운영 능력을 강화합니다. AI가 시스템 내의 파일을 탐색하고 조작하는 데 필수적입니다.
*   **브라우저 자동화 MCP(Browser Automation MCP)**: 웹 작업을 위한 플레이라이트(Playwright), 퍼페티어(Puppeteer), 브라우저 툴(Browser Tools)은 디지털 환경에서의 AI 상호작용을 혁신하고 있습니다. AI가 웹 기반 작업을 수행하고 정보를 수집하는 데 중요한 역할을 합니다.
*   **깃 툴(Git Tools)**: 저장소(repository) 상호 작용 및 버전 관리용 기능은 협업 프로젝트에서 AI의 역할을 확장합니다. AI가 코드 변경 사항을 관리하고 통합하는 데 기여합니다.
*   **문서 검색(Documentation Retrieval, Context 7)**: 문서 라이브러리(library)에 쉽게 접근할 수 있습니다. 이는 정보 접근성을 크게 향상시킵니다. AI가 필요한 정보를 신속하게 찾아 활용할 수 있게 합니다.
*   **서드파티 통합(Third-party integrations)**: 일반적인 코딩 환경을 넘어선 작업을 위한 다양한 도구들이 AI의 적용 범위를 넓히고 있습니다. 슬랙(Slack), 퍼플렉시티 리서치(Perplexity Research), 유니티(Unity), 에이블톤(Ableton) 등과의 통합은 AI가 단순 코딩을 넘어선 영역에서 가치를 창출할 수 있음을 보여줍니다.

놀라운 점은 MCP가 비기술직 사람들에게도 킬러 기능(killer feature)이라는 것이었습니다. 이는 AI 대중화의 중요한 신호입니다. 코딩을 전혀 하지 않지만 워크플로우 자동화 플랫폼(workflow automation platform)으로 AI를 활용하는 사례가 늘고 있으며, 이는 생산성 향상에 크게 기여합니다. 예를 들어, 자동화된 마케팅 및 소셜 미디어: 레딧(Reddit) 및 트위터(Twitter) MCP 통합을 활용하여, AI는 콘텐츠 생성과 배포 과정을 효율적으로 관리합니다. 이는 비전문가도 복잡한 마케팅 작업을 손쉽게 수행할 수 있게 합니다. 프레젠테이션 생성: 비기술직 사용자들이 음성 메모(voice notes)를 필사하고 자동으로 전문적인 프레젠테이션(presentation)으로 포맷(format)하여, 누구나 손쉽게 고품질의 자료를 만들 수 있게 되었습니다. (코드를 슬라이드 프레임워크(slides framework)로 사용하므로 코딩 관련(coding-adjacent)이라고 주장할 수도 있지만, 그래도 놀랍습니다!) 이러한 사례들은 AI가 단순히 기술 전문가의 전유물이 아니라, 모든 사람의 일상과 업무를 변화시킬 잠재력을 가지고 있음을 보여줍니다.

MCP의 인기가 계속 높아지고 멀티모달 텍스트박스(multi-modal textbox)가 최고의 AI 인터페이스(interface)로 계속 성장함에 따라, AI와의 상호작용 방식은 더욱 다양해질 것입니다. 미래에는 음성, 이미지, 제스처 등 다양한 입력 방식을 통해 AI와 소통하며, 더욱 직관적이고 몰입감 있는 경험을 제공할 것입니다. 이러한 변화는 AI가 우리 삶의 모든 측면에 깊이 스며들게 하는 중요한 전환점이 될 것입니다.

**쇼 노트(Show Notes)**
*   AI 시대의 새로운 서막: 소개
*   플랜 앤 액트 패러다임(Plan and Act Paradigm)의 확장된 적용
*   모델 평가 및 AI 시스템의 지속적인 발전
*   코딩을 넘어선 AI의 무한한 사용 사례
*   클라인(Cline)이 VS Code 확장 프로그램(Extension)인 이유: 통합과 접근성의 중요성
*   프로그래밍 에이전트(Agent)의 경제적 가치와 미래 산업의 변화
*   MCP(Multi-Agent Communication Protocol)의 초기 도입과 생태계 확장
*   로컬(Local) 대 원격(Remote) MCP 서버(Server): 유연성과 보안의 균형
*   MCP 레지스트리(Registry)에서 앤트로픽(Anthropic)의 역할과 표준화의 중요성
*   가장 인기 있는 MCP(Multi-Agent Communication Protocol) 및 사용 사례 분석
*   MCP(Multi-Agent Communication Protocol) 수익화의 과제와 미래 전망
*   MCP(Multi-Agent Communication Protocol)의 보안 및 신뢰 문제와 해결 방안
*   MCP(Multi-Agent Communication Protocol) 없는 대체 역사: 오픈 표준의 가치
*   코딩 에이전트(Agent)의 시장 포지셔닝(Positioning) 및 IDE 통합 매트릭스(Matrix): 다양한 접근 방식
*   코딩 에이전트(Agent)의 가시성 및 자율성: 개발자 통제와 AI 효율성
*   프로그래밍 작업 복잡성의 진화하는 정의와 AI의 역할
*   클라인(Cline)의 포크(Fork) 및 오픈 소스(Open Source) 후회: 커뮤니티의 힘
*   에이전트(Agent) 설계의 단순성 대 복잡성: 최적의 균형점 찾기
*   패스트 어플라이(Fast Apply)가 비터 레슨(Bitter Lesson)을 얻은 방법: 기술 발전의 교훈
*   클라인(Cline)의 비즈니스 모델(Business Model) 및 BYO-API 키(Bring-Your-Own-API-Key) 접근 방식: 투명성과 사용자 중심
*   오픈라우터(OpenRouter) 및 엔터프라이즈(Enterprise) 인프라(Infrastructure) 통합: 개방형 생태계의 가능성
*   모델 비용 감소의 영향: AI 서비스의 대중화 가속
*   백그라운드 에이전트(Background Agent) 및 다중 에이전트 시스템(Multi-Agent System): 미래 AI 아키텍처의 핵심
*   비전(Vision) 및 멀티모달리티(Multi-Modalities): AI의 감각 확장
*   컨텍스트 엔지니어링(Context Engineering)의 현황과 AI 상호작용의 심화
*   코딩 에이전트(Agent)의 메모리 시스템(Memory System): 지식 관리의 새로운 패러다임
*   에이전트(Agent) 도구 전반의 규칙 파일 표준화와 상호 운용성(interoperability) 증진
*   클라인(Cline)의 성격 및 의인화: 사용자 경험의 인간적 요소
*   클라인(Cline) 채용 및 팀 문화: 혁신을 위한 인재 확보

**녹취록**
**소개**
**알레시오 (Alessio)**: 안녕하세요, 레이턴트 스페이스 팟캐스트(Latent Space podcast)에 오신 것을 환영합니다. 저는 데시벨(Decibel)의 파트너(partner) 겸 CTO(Chief Technology Officer)인 알레시오(Alessio)이며, 스몰 AI(Small AI)의 설립자인 공동 진행자 스윅스(Swyx)와 함께합니다. 오늘 우리는 AI 기술의 급속한 발전에 대해 이야기할 예정입니다.
**스윅스 (Swyx)**: 그리고 오늘 스튜디오에는 AI의 미래를 논의하기 위해 새로운 관점을 가진 게스트들이 함께합니다. 빠르게 변화하는 AI 환경 속에서, 우리는 기술이 어떻게 진화하고 있는지, 그리고 이것이 우리 삶에 어떤 영향을 미치는지 깊이 들여다볼 것입니다.
**알레시오 (Alessio)**: 완벽했습니다. 시작하죠.
**스윅스 (Swyx)**: AI 기술은 상당한 대중적 관심을 받고 있지만, 그 복잡성 때문에 모든 사람이 그 잠재력을 완전히 이해하는 것은 아닙니다. 오늘은 AI 에이전트의 역할과 그들이 가져올 변화에 집중해 봅시다.
**사우드 (Saoud)**: 네, 클라인(Cline)은 오픈 소스(open source) 코딩 에이전트(coding agent)입니다. 지금은 VS Code 확장 프로그램(extension)이지만, 젯브레인즈(JetBrains)와 네오빔(NeoVim), CLI(Command Line Interface)에도 출시될 예정입니다. AI 에이전트의 발전은 단순한 소프트웨어 개선을 넘어섭니다. 이제 AI는 자율적으로 작업을 수행하고, 다양한 시스템과 상호 작용하며, 인간의 개입 없이도 복잡한 문제 해결에 기여할 수 있습니다. 이는 개발 워크플로우뿐만 아니라, 다양한 산업 분야에서 혁신을 이끌 것입니다. 에이전트는 사용자의 터미널(terminal), 에디터(editor), 브라우저(browser)를 장악하고, 온갖 종류의 MCP 서비스(service)에 연결하여 본질적으로 당신의 전체 개발자 워크플로우(workflow)를 장악할 수 있습니다. 그리고 그것은 당신이 전체 작업을 완료하기 위한 접점이 됩니다.
**스윅스 (Swyx)**: 멋집니다. 파쉬(Pash), AI 에이전트의 미래에 대해 또 다른 가치 있는 관점은 무엇이라고 생각하십니까?
**파쉬 (Pash)**: 네, 저는 클라인(Cline)이 에이전트(agent)를 위한, 모든 오픈 소스(open source) 에이전트(agent)를 위한 일종의 인프라 계층(infrastructure layer)이라고 생각합니다. 사람들이 이런 에이전트 기반 인프라(agentic infrastructure) 위에 구축하고 있습니다. 클라인(Cline)은 완전히 모듈식 시스템(modular system)입니다. 그것이 우리가 구상하는 방식입니다. 그리고 우리는 그것을 더 모듈화하여 그 위에 어떤 에이전트(agent)든 구축할 수 있도록 노력하고 있습니다. 네. 그래서 우리가 출시하고 있는 CLI(Command Line Interface)와 SDK(Software Development Kit)를 통해 에이전트(agent)를 위한 완전히 에이전트 기반 시스템(agentic system)을 구축할 수 있을 겁니다. 저는 AI 에이전트가 미래의 디지털 인프라(infrastructure)를 형성하는 핵심 구성 요소가 될 것이라고 생각합니다. 이들은 단순히 작업을 자동화하는 것을 넘어, 새로운 종류의 지능형 시스템을 구축하는 기반을 제공합니다.

**플랜 앤 액트 패러다임(Plan and Act Paradigm)의 확장된 적용**
**스윅스 (Swyx)**: 아, 알겠습니다. 제가 가지고 있던 클라인(Cline)에 대한 관점과는 다르네요. 그럼, 먼저 AI의 현재 적용 사례에 대해 이야기하고, 그 다음 더 넓은 미래 전망에 대해 이야기해 봅시다. 플랜 앤 액트 패러다임(Plan and Act Paradigm)이 AI 시스템의 설계에 어떻게 적용되고 있습니까?
**사우드 (Saoud)**: 네, 제가 플랜 앤 액트(plan and act)를 처음 고안한 공로를 차지하겠습니다. 클라인(Cline)은 개발자가 상호 작용할 수 있는 두 가지 모드(mode)를 갖는 개념을 처음으로 제시했습니다. 플랜 앤 액트(plan and act) 개념은 AI 에이전트가 복잡한 작업을 처리하는 데 있어 핵심적인 접근 방식입니다. 이는 에이전트가 작업을 수행하기 전에 먼저 상세한 계획을 수립하고, 그 계획에 따라 행동하는 두 가지 모드(mode)를 갖는 것을 의미합니다. 이 방식은 AI가 단순한 지시 수행을 넘어, 전략적인 사고를 통해 문제에 접근하도록 돕습니다. 초기에는 사용자들이 자연스럽게 이러한 워크플로우(workflow)를 만들어냈지만, 이제는 제품 설계에 이러한 개념을 통합하여 사용자 경험을 더욱 직관적으로 만들고 있습니다. 플랜 모드(plan mode)에서는 에이전트가 더 탐색적(exploratory)으로 행동하고, 더 많은 파일을 읽고, 더 많은 데이터를 얻고, 더 많은 데이터를 얻고, 더 많은 데이터를 얻도록 지시받습니다. 이는 사용자가 달성하고자 하는 작업이 무엇이든 간에 공격 계획(plan of attack)을 세우기 위해 관련 정보를 이해하고 컨텍스트(context)를 채웁니다. 그리고 액트 모드(act mode)로 전환하면, 에이전트(agent)는 계획을 보고 실행하기 시작하고, 명령을 실행하고, 파일을 편집하라는 지시를 받습니다. 이 과정에서 사용자는 에이전트의 진행 상황을 모니터링하며 필요시 개입하여 경로를 수정할 수 있습니다.
**알레시오 (Alessio)**: 그리고 이것이 AI 제품 개발의 초기부터 고려되었던 형태였습니까? 아니면 반복적인 개선을 통해 도달한 결과입니까?
**사우드 (Saoud)**: 특히 클라인(Cline)의 초기에는 많은 실험과 사용자들과의 대화가 있었습니다. 그리고 그들에게 유용하다고 생각되는 어떤 종류의 워크플로우(workflow)가 나타나는지 보고 그것을 제품에 적용했습니다. 플랜 앤 액트(plan and act) 모드는 본질적으로 사용자가 복잡한 지시를 일일이 입력할 필요 없이, AI가 스스로 계획하고 실행하도록 돕는 단축키와 같습니다. 이는 사용자 편의성을 극대화하고, AI와의 상호작용을 더욱 자연스럽게 만듭니다.
**알레시오 (Alessio)**: 당시 AI 모델의 성능 평가는 어땠습니까? 모델의 한계는 무엇이었고, 그것이 어떻게 개선되어 왔습니까?

**모델 평가 및 AI 시스템의 지속적인 발전**
**사우드 (Saoud)**: 네, 제가 클라인(Cline) 작업을 처음 시작했을 때, 클라우드 3.5 소닉(Cloud 3.5 Sonic)이 출시된 지 10일 후였습니다. 저는 앤트로픽스(Anthropic's) 모델 카드 부록(model card addendum)을 읽고 있었습니다. 그리고 에이전트 코딩(agentic coding)과 그것이 단계별 작업 수행에 얼마나 더 나은지에 대한 섹션이 있었습니다. 당시 모델들은 Q&A(Question & Answer)나 원샷 프롬프팅 패러다임(one shot prompting paradigm)에 더 적합했지만, 새로운 모델들은 더 긴 컨텍스트(context)를 이해하고 복잡한 작업을 단계별로 처리하는 데 뛰어났습니다. 예를 들어, 클라우드 3.5는 건초 더미 속 바늘 찾기(needle in a haystack)라는 테스트(test)에서도 정말 뛰어났습니다. 컨텍스트 윈도우(context window)에 많은 컨텍스트(context)가 있고, 200k 컨텍스트 윈도우(context window)의 90%가 채워져 있다면, 그 컨텍스트(context)에서 세부 사항을 찾아내는 데 정말 뛰어납니다. 이러한 모델의 발전은 처음부터 제품을 설계할 때 중요한 고려 사항이었습니다. 우리는 모델의 한계를 이해하고, 이를 보완하는 방식으로 사용자 경험을 설계했습니다. 초기에는 개발자가 원하는 대로 사용할 수 있도록 가능한 한 일반적(general as possible)으로 만들고, 그들이 자신에게 잘 맞는 워크플로우(workflow)를 만들어내도록 하는 것이 중요했습니다. 이제 AI는 코딩(coding) 외에도 온갖 종류의 일에 활용되며, 그 적용 범위는 계속 확장되고 있습니다. 우리 제품 마케팅 담당자(product marketing guy)인 닉 바우만(Nick Bauman)은 레딧(Reddit) MCP 서버(server)에 연결하고, X MCP 서버(server)에 연결된 콘텐츠를 스크래핑(scraping)하고 트윗(tweet)을 게시하는 데 사용합니다. 본질적으로 VS Code 확장 프로그램(extension)이자 코딩 에이전트(coding agent)임에도 불구하고 말이죠. MCP는 클라인(Cline)이 모든 서비스(service) 등에 연결할 수 있는 '모든 것 에이전트(everything agent)'로 기능하게 합니다.
**파쉬 (Pash)**: 저는 암스테르담(Amsterdam)에서 열린 컨퍼런스(conference)에 있었는데, 슬라이드데브(SlideDev)라는 자바스크립트 라이브러리(JavaScript library)를 사용하여 제 전체 프레젠테이션(presentation), 전체 슬라이드 덱(slide deck)을 만들었습니다. 저는 클라인(Cline)에게 리미트리스(Limitless)라는 다른 앱(app)을 사용하여 녹음한 아젠다(agenda)를 알려주었습니다. 제 강연을 위해 이 컨퍼런스(conference)에서 무엇을 이야기할지에 대한 제 생각을 의식의 흐름(stream of consciousness)처럼 텍스트로 필사했습니다. 그리고 클라인(Cline)은 그냥 들어가서 저를 위해 전체 덱(deck)을 만들었습니다.

**코딩을 넘어선 AI의 무한한 사용 사례**
**스윅스 (Swyx)**: 네, 그래서 코딩 사용 사례(use case)와 비슷하네요.
**파쉬 (Pash)**: 일종의 코딩 사용 사례(use case)였지만, 그것으로 프레젠테이션(presentation)을 만드는 것이었죠. 하지만 스크립트(script)를 실행하거나, 데이터 분석(data analysis)을 해주고, 그것을 덱(deck)에 넣는 등 여러 가지를 결합할 수도 있습니다. 이러한 다재다능함은 AI의 잠재력이 얼마나 큰지 보여주는 좋은 예시입니다.
**사우드 (Saoud)**: 그리고 VS Code 확장 프로그램(extension)이라는 것은 사용자 OS(Operating System)에 접근하고, 사용자 터미널(terminal)에 접근하며, 파일을 읽고 편집할 수 있는 흥미로운 기능을 제공합니다. 이러한 접근성은 AI 에이전트가 사용자의 작업 환경에 깊이 통합되어, 더욱 광범위한 작업을 수행할 수 있도록 합니다. 확장 프로그램(extension)이라는 것은 많은 개발자들에게 온보딩(onboarding) 마찰을 크게 줄여줍니다. 그들은 새로운 애플리케이션(application)을 설치할 필요가 없거나, 조직 내에서 사용 승인을 받기 위해 내부적인 복잡한 절차를 거칠 필요가 없습니다. 그래서 마켓플레이스(marketplace)는 우리에게 엄청난 배포(distribution) 기회를 제공했으며, 데스크톱(desktop) 파일에 접근하거나, 터미널(terminal)에서 실행하거나, 코드를 편집하고, VS Code의 멋진 UI(User Interface)를 활용하여 예를 들어 파일 변경 전후의 차이 보기(diff views)를 보여주는 것과 같은 것에 완벽한 통로입니다.
**스윅스 (Swyx)**: VS Code를 포크(fork)하고 싶은 유혹은 없었습니까? 지금쯤 훨씬 더 큰 규모의 플랫폼을 구축할 수도 있었을 텐데요.
**사우드 (Saoud)**: 글쎄요, 아니요, 저는 VS Code를 포크(fork)해야 하는 사람들을 불쌍히 여깁니다. 왜냐하면 마이크로소프트(Microsoft)는 이러한 포크(fork)를 유지 관리하기를 악명 높게 어렵게 만들기 때문입니다. 기존 플랫폼에 통합하는 전략은 개발 자원을 핵심 AI 기능에 집중할 수 있게 합니다.
**스윅스 (Swyx)**: 그들이 비공개 저장소(private repo)를 가지고 있고 그것을 동기화(sync)해야 하기 때문입니까?
**사우드 (Saoud)**: 맞습니다. 그리고 VS Code는 너무 빠르게 움직여서, 병합 충돌(merge conflicts)과 같은 문제뿐만 아니라 백엔드(back end)에서도 온갖 종류의 문제에 부딪힐 것이라고 확신합니다. 확장 프로그램(extension)이라는 것은 우리에게 훨씬 더 많은 배포(distribution)를 제공합니다. 당신은 커서(Cursor)나 윈드서프(Windsurf) 또는 VS Code에서 클라인(Cline)을 사용할 수 있습니다. 그리고 저는 클라인(Cline)이 이 모든 것을 정말 잘 보완한다고 생각합니다. 왜냐하면 우리는 사용자들과 정말 긴밀하게 협력하여 최고의 에이전트 경험(agentic experience)이 무엇인지 알아낼 기회를 얻기 때문입니다. 반면에 커서(Cursor)와 윈드서프(Windsurf), 코파일럿(Copilot)은 전체 개발자 경험(developer experience), 인라인 코드 편집(inline code edits), Q&A(Question & Answer), 코드를 작성하는 데 필요한 모든 부가 기능(bells and whistles)에 대해 생각해야 합니다. 그래서 저는 우리가 미래 프로그래밍(programming)이라고 생각하는 것, 즉 이 에이전트 패러다임(agentic paradigm)에 집중할 것이라고 생각합니다. 그리고 모델이 더 좋아짐에 따라, 사람들은 점점 더 자연어(natural language)를 사용하고 에이전트(agent)와 함께 작업하며, 세부 사항에 얽매이거나 코드를 편집하고 탭 자동 완성(tab autocomplete)을 사용하는 일은 줄어들게 될 것입니다.
**파쉬 (Pash)**: 네, VS Code의 포크(fork)를 유지 관리하는 데 얼마나 많은 자원을 소비해야 할지 상상해 보세요. 우리는 핵심 에이전트 루프(agentic loop)에 집중하고, 출시되는 다양한 모델 제품군(model family)에 대해 최적화하고, 그들을 지원할 수 있습니다. 이 모든 것에는 너무나 많은 작업이 필요해서, 옆에서 포크(fork)를 유지 관리하는 것은 우리에게 엄청난 방해가 될 것이고, 저는 그것이 정말 가치 있다고 생각하지 않습니다.

**프로그래밍 에이전트(Agent)의 경제적 가치와 미래 산업의 변화**
**알레시오 (Alessio)**: 당신이 이야기할 때, 저는 '우리는 프로그래밍(programming)의 미래를 위한 최고의 것이 되고 싶다'는 것과 '이것은 비프로그래밍(non-programming)에도 훌륭하다'는 구분을 듣습니다. MCP 서버(server)를 사용하는 사람들이 점점 더 많아지고, 특히 덜 기술적인 일을 하는 것을 보는 것이 최근의 일입니까?
**사우드 (Saoud)**: 경제적 가치(economic value) 측면에서, 프로그래밍(programming)은 현재 언어 모델(language models)에게 가장 높은 비용 대비 이점(cost to benefit)을 제공합니다. 그리고 저는, 아시다시피, 많은 모델 연구소(model labs)들이 오픈아이(OpenAI)와 앤트로픽(Anthropic)이 1년 전보다 코딩(coding)을 훨씬 더 진지하게 받아들이고 있다는 것을 인식하고 있다고 생각합니다. 우리가 본 것은, 네, MCP 생태계(ecosystem)가 성장하고 있고 많은 사람들이 프로그래밍(programming) 외의 일에 그것을 사용하고 있지만, 주요 사용 사례(use case)는 대부분 개발자 작업입니다. 몇 주 전 해커 뉴스(Hacker News)에 한 개발자가 버그(bug) 있는 클라우드플레어 워커(Cloudflare worker)를 배포하고 센트리(Sentry) MCP 서버(server)를 사용하여 스택 트레이스(stack trace)를 가져온 다음, 클라인(Cline)에게 스택 트레이스(stack trace) 정보를 사용하여 버그(bug)를 수정하고, 깃허브(GitHub) MCP 서버(server)에 연결하여 이슈(issue)를 닫고, 클라우드플레어(Cloudflare)에 수정 사항을 배포하도록 요청했다는 기사가 있었습니다. 이 모든 것이 클라인(Cline) 내에서 자연어(natural language)를 사용하여 이루어졌습니다. VS Code를 떠날 필요가 없었고, 개발자가 스스로 알아내고 개발 환경(developer environment)을 떠나야 하는 인지 과부하(cognitive overload)를 겪어야 했을 모든 서비스(service)와 상호 작용합니다. 본질적으로 에이전트(agent)가 백그라운드(background)에서 자연어(natural language)만 사용하여 할 수 있었던 일을 말이죠. 그래서 저는 이것이 미래의 방향이라고 생각합니다. 애플리케이션 계층(application layer)이 이전에 수동으로 상호 작용해야 했던 모든 서비스(service)와 연결되고, 자연어(natural language)를 사용하여 상호 작용하는 단일 접점(single point of contact)이 되는 것입니다. 그리고 당신이 코드에 덜 관여하고, 에이전트(agent)가 무엇을 하는지에 대한 높은 수준의 이해를 가지고 경로를 수정할 수 있게 되는 것입니다. 저는 그것이 우리에게 중요한 또 다른 부분이며, 이 엄청나게 시끄러운 공간에서 우리가 두각을 나타낼(cut through the noise) 수 있게 해준 것이라고 생각합니다. 많은 사람들이 미래가 어디로 향하는지에 대해 정말 거창한 아이디어(grand ideas)를 가지고 있다고 생각하지만, 우리는 오늘날 사람들에게 유용한 것에 대해 정말 광적으로 집착했습니다. 그리고 그 큰 부분은 이러한 모델의 한계(model limitations)를 이해하고, 그들이 무엇을 잘하지 못하는지 파악하며, 최종 개발자들에게 그러한 것들에 대한 충분한 통찰력(insight)을 제공하여 그들이 경로를 수정하는 방법을 알도록 하는 것입니다. 그들은 일이 잘못될 때 피드백(feedback)을 제공하는 방법을 압니다. 그래서, 예를 들어, 클라인(Cline)은 모델에 들어가는 프롬프트(prompt)에 대해, 오류가 발생했을 때 왜 오류가 발생했는지에 대해, 모델이 호출하는 도구에 대해 많은 통찰력(insight)을 제공하는 데 정말 능숙합니다. 우리는 작업을 수행하는 각 단계에서 모델이 정확히 무엇을 하는지에 대해 가능한 한 많은 통찰력(insight)을 제공하려고 노력합니다. 그래서 일이 잘못되거나 잘못된 방향으로 가기 시작할 때, 당신은 피드백(feedback)을 주고 경로를 수정할 수 있습니다. 저는 경로 수정 부분이 엄청나게 중요하며, 작업을 완료하는 데 있어서, 예를 들어 백그라운드 에이전트(background agent) 작업을 시키고 몇 시간 후에 돌아왔을 때 완전히 잘못되어 있고 당신이 기대했던 어떤 것도 하지 않았을 때보다 훨씬 더 빠르게 작업을 완료할 수 있다고 생각합니다. 그리고 몇 번 다시 시도해야만 제대로 작동합니다.
**알레시오 (Alessio)**: 센트리(Sentry) 예시는 훌륭하다고 생각합니다. 왜냐하면 어떤 면에서는 MCP가 제품 자체를 잠식하는 것 같기 때문입니다. 저는 센트리(Sentry) MCP를 사용하기 시작했습니다. 그리고 센트리(Sentry)는 이슈 해결 에이전트(issue resolution agent)인 '여기(here)'를 출시했는데, 처음에는 무료였습니다. 그래서 저는 센트리(Sentry)에서 그것을 켰고, 사용했는데, 훌륭했습니다. 그러다가 그들은 돈을 받기 시작했습니다. 그래서 저는 'MCP를 무료로 사용하고, 데이터를 내 코딩 에이전트(coding agent)에 넣으면, 무료로 문제를 해결하고 다시 보내줄 텐데'라고 생각했습니다. 특히 코딩(coding)에서 이런 폐쇄 루프(closed loop)를 가질 수 있는 경우를 보고 싶습니다. 예를 들어, RDS MCP가 유료 AI 서비스(paid AI offering)가 되어 그것을 연결할 수 있게 되는 경우 말이죠. 클라인(Cline)이 모든 비용을 분할하는 MCP 구독(subscription)을 가질까요?

**MCP(Multi-Agent Communication Protocol)의 초기 도입과 생태계 확장**
**파쉬 (Pash)**: 글쎄요, 네, 우리는 아주 초기에 그랬습니다. 우리는 처음부터 MCP에 대해 낙관적이었습니다.
**사우드 (Saoud)**: 그리고 우리는 런치 파트너(launch partner)이자 금융 MCP였습니다. 앤트로픽(Anthropic)이 처음 MCP를 출시하고 그들이 작업해 온 새로운 프로토콜(protocol)과 그것을 오픈 소스(open source)화하는 것에 대해 대대적으로 발표했을 때, 아무도 그것이 무엇을 의미하는지 제대로 이해하지 못했습니다. 그리고 저는 그것이 어떻게 작동하고 왜 중요한지에 대한 그들의 문서를 정말 깊이 파고드는 데 시간이 좀 걸렸습니다. 저는 그들이 오픈 소스(open source) 커뮤니티(community)가 생태계(ecosystem)에 기여하여 그것이 정말 성공할 수 있도록 하는 데 베팅(bet)했다고 생각합니다. 그래서 저는 가능한 한 그것을 돕고 싶었습니다. 그래서 오랫동안 클라인(Cline) 시스템 프롬프트(system prompt)의 대부분은 'MCP는 어떻게 작동하는가?'였습니다. 왜냐하면 당시에는 너무 새로운 것이어서 모델들이 그것에 대해 아무것도 몰랐고 MCP 서버(server)를 만드는 방법도 몰랐기 때문입니다. 그래서 개발자가 무언가를 만들고 싶다면, 그것에 정말 능숙할 것입니다. 그리고 저는 클라인(Cline)이 그 이후로 MCP 생태계(ecosystem)가 얼마나 성장했는지에 대해 어느 정도 기여했다고 생각하고 싶습니다. 그리고 개발자들에게 내부적으로(under the hood) 어떻게 작동하는지에 대한 더 많은 통찰력(insight)과 인식을 제공하는 것이, 이러한 것들을 개발하는 것은 물론이고 사용하는 데 있어서도 엄청나게 중요하다고 생각합니다. 그래서, 네, 우리가 클라인(Cline)에서 MCP를 출시했을 때, 우리 디스코드(Discord) 사용자들은 그것을 이해하려고 애썼던 것을 기억합니다. 그리고 클라이언트(client)들이 MCP 서버(server)를 처음부터 구축하는 것을 보면서, 그들은 '아, 알겠다'고 했습니다. 그들은 점들을 연결하기 시작했습니다. '이것이 내부적으로(under the hood) 작동하는 방식이다. 이것이 유용한 이유다. 에이전트(agent)가 이러한 도구와 서비스(service) 및 API(Application Programming Interface)에 연결하는 방식이며, 이런 종류의 작업을 직접 해야 하는 많은 번거로움을 덜어주었다.'
**파쉬 (Pash)**: 그 당시에는 사람들이 여전히 MCP를 이해하려고 노력하던 초기였습니다. 그리고 발견 가능성(discoverability)에 큰 문제가 있었습니다. 그래서 지난 2월쯤, 우리는 MCP 마켓플레이스(marketplace)를 출시했습니다. 거기서 실제로 클라이언트(client)가 리드미(readme)를 보고, 깃허브(GitHub)에 연결된 전체 MCP 서버(server)를 처음부터 설치하고 즉시 실행할 수 있는 원클릭 설치 프로세스(process)를 가질 수 있었습니다. 그리고 그것이, 제 생각에는 그 무렵에 MCP가 마켓플레이스(marketplace) 출시와 함께 정말 이륙하기 시작했습니다. 사람들이 MCP를 발견하고, MCP 마켓플레이스(marketplace)에 기여할 수 있게 된 것이죠. 그 이후로 우리는 150개 이상의 MCP 서버(server)를 등록했습니다. 그리고 우리 마켓플레이스(marketplace)의 인기 MCP는 수십만 다운로드(download)를 기록했습니다. 사람들이 그것들을 사용합니다. 그리고, 아시다시피, 당신이 언급했듯이 '사람들이 기존 제품을 어떻게 잠식하는가'와 같은 정말 주목할 만한 예시들이 있습니다. 하지만 동시에 우리는 사람들이 MCP를 수익화(monetizing)하는 생태계(ecosystem)가 진화하는 것을 보기 시작했습니다. 주목할 만한 예시로는 21세기 개발 매직 MCP 서버(server)가 있습니다. 이 서버는 이 코딩 에이전트(coding agent)에 약간의 취향을 주입하여 LLM(Large Language Model)에 아름다운 컴포넌트(component) 라이브러리(library)를 가지고 관련 예시를 주입합니다. 그래서 클라이언트(client)가 들어가서 아름다운 UI(User Interface)를 구현할 수 있습니다. 그리고 그들이 그것을 수익화(monetizing)한 방식은 표준 API 키(API key)였습니다. 그래서 우리는 개발자들이 MCP를 정말 좋아하고, 그것을 구축하고, MCP 마켓플레이스(marketplace)와 클라이언트(client)와 같은 배포 플랫폼(platform)을 가지고, 그것을 중심으로 전체 비즈니스(business)를 수익화(monetizing)하는 것을 보기 시작했습니다. 그래서 이제는 거의 에이전트(agent)에게 도구를 판매하는 것과 같으며, 이는 정말 흥미로운 주제입니다.

**로컬(Local) 대 원격(Remote) MCP 서버(Server): 유연성과 보안의 균형**
**알레시오 (Alessio)**: 그리고 당신은 VS Code에 있기 때문에 그것을 할 수 있습니다. 터미널(terminal)이 있으니까요. 그래서 PX로 다른 서버(server)를 실행할 수 있습니다. 원격 MCP 호스팅(hosting)을 고려해 본 적이 있습니까?
**파쉬 (Pash)**: 네, 우리는 실제로 직접 호스팅(hosting)한 적은 없습니다. 우리는 그것이, 우리는 그것을 검토하고 있습니다. 원격 MCP는 지금 매우 초기 단계(nascent)라고 생각합니다. 하지만 우리는 원격 MCP를 지원하고 우리 마켓플레이스(marketplace)에 등록하는 데 분명히 관심이 있습니다.
**사우드 (Saoud)**: 그리고 또 다른 부분은, 로컬 MCP 서버(server)와 원격 MCP의 차이점이라고 생각합니다. 대부분의 원격 MCP는 다른 API(Application Programming Interface)에 연결하는 데만 유용합니다. 하지만 그것은 MCP의 작은 사용 사례(use case)일 뿐입니다. 많은 MCP는 컴퓨터의 다른 애플리케이션(application)에 연결하는 데 도움이 됩니다. 예를 들어, VS Code 내에서 3D 객체를 생성하는 데 도움이 되는 유니티(Unity) MCP 서버(server)가 있습니다. 에이블톤(Ableton) MCP 서버(server)도 있습니다. 클라이언트(client)나 MCP를 사용하는 다른 것을 사용하여 노래를 만들 수 있습니다. 우리는 이러한 MCP 서버(server)가 원격으로만 호스팅(hosting)되는 세상을 보지 못할 것입니다. 항상 로컬 MCP 서버(server)와 원격 MCP 서버(server)의 혼합이 있을 것입니다. 원격 MCP 서버(server)는 OAuth 플로우(flow)와 같은 것을 통해 설치 프로세스(process)를 조금 더 쉽게 만들고, API 키(API key)를 직접 관리해야 하는 것만큼 고통스럽지 않게 인증할 수 있도록 한다고 생각합니다. 하지만 대부분의 경우, MCP 생태계(ecosystem)는 정말 초기 단계(earlier days)에 있습니다. 우리는 여전히 보안과 최종 개발자를 위한 편의성의 좋은 균형을 찾으려고 노력하고 있습니다. 그래서 이러한 것들을 설정하는 것이 고통스럽지 않도록 말이죠. 그리고 저는 우리가 이것이 사람들에게 얼마나 유용한지에 대한 매우 실험적인 단계에 있다고 생각합니다. 그리고 이제 이것이 시장 적합성(market fit) 수준을 보이고 사람들이 이것이 그들의 일을 완전히 바꾸고 있다는 기사(article)와 워크플로우(workflow)를 내놓고 있기 때문에, 생태계(ecosystem)와 프로토콜(protocol) 구축에 더 많은 자원과 노력이 투입될 것이라고 생각합니다. 앤트로픽스(Anthropic's) 로드맵(Roadmap)에는 많은 것이 있다고 생각합니다. 그리고 커뮤니티(community) 전반적으로 많은 아이디어를 가지고 있으며, 특히 우리 마켓플레이스(marketplace)는 우리가 이것을 할 수 있는 몇 가지 방법에 대한 통찰력(insight)을 제공했습니다. 개발자들이 요구했던 것들, 즉 우리가 '미래의 마켓플레이스(marketplace)는 어떤 모습일까?'라고 생각하는 것들 말입니다. 그리고 우리에게는 그것이 조합이 될 것입니다. 아시다시피, 우리 사용자들 중 많은 사람들이 보안 의식(security conscious)이 매우 높습니다. 그리고 최종 개발자를 신뢰하지 않는다면 MCP 서버(server)를 사용하는 것이 꽤 위험할 수 있는 많은 방법이 있습니다. 그래서 우리는 '어느 정도의 보안 수준을 가질 수 있는 미래는 어떤 모습일까?'를 알아내려고 노력하고 있습니다. 그리고 설치하는 MCP 서버(server)에 대한 어느 정도의 신뢰를 구축하는 방법은 무엇일까요? 저는 지금은 너무 이르다고 생각하며, 많은 엔터프라이즈(enterprise) 개발자나 조직이 아직 기꺼이 하려고 하지 않는 커뮤니티(community)의 많은 신뢰가 있습니다. 그래서 그것이 우리에게 최우선 고려 사항(top of mind)입니다.

**MCP 레지스트리(Registry)에서 앤트로픽(Anthropic)의 역할과 표준화의 중요성**
**스윅스 (Swyx)**: 앤트로픽(Anthropic)과 여기 커뮤니티(community) 사이에 흥미로운 긴장감이 있습니다. 당신은 기본적으로 내부적으로 모델 등록 MCP 레지스트리(registry)를 가지고 있는 것 같네요, 그렇죠? 솔직히 말해서, 저는 당신이 그것을 노출해야 한다고 생각합니다. 저는 당신의 웹사이트에서 그것을 찾고 있었는데, 클라이언트(client)를 설치해야만 접근할 수 있는 것 같았습니다. 하지만 스미더리(Smithery)와 다른 사람들도 있죠, 그렇죠? 하지만 앤트로픽(Anthropic)도 언젠가 모델 레지스트리(registry) 또는 MCP 레지스트리(registry)를 출시할 것이라고 말했습니다. 언젠가요. 앤트로픽(Anthropic)이 공식적인 것을 출시한다면, 그들이 기본적으로 이길까요, 그렇죠? 왜냐하면, 당신은 그냥 그들을 사용할까요?
**사우드 (Saoud)**: 저는 그렇게 생각합니다. 저는 전체 생태계(ecosystem)가 그들이 하는 모든 것에 수렴할 것이라고 생각합니다. 그들은 배포(distribution)가 너무 좋고, 네, 그들이 그것을 고안했습니다. 네, 정확합니다. 좋습니다.

**가장 인기 있는 MCP(Multi-Agent Communication Protocol) 및 사용 사례 분석**
**스윅스 (Swyx)**: 그리고 저는 당신이 정말 많이 다운로드(download)된 MCP들을 가지고 있다는 것을 알았습니다. 저는 가장 많은 설치를 기준으로 보았습니다. 제가 그냥 읽어드리겠습니다. 언제든지 저를 멈추고 코멘트(comment)를 달아주셔도 됩니다. 그래서 가장 인기 있는 것은 파일 시스템 MCP(File System MCP)입니다. 이해가 됩니다. 에이전트-AI(agent-AI)의 브라우저 도구(Browser tools)요. 그게 뭔지는 모르겠습니다. 순차적 사고(Sequential thinking). 그것은 초기 MCP 릴리스(release)와 함께 나왔습니다. 컨텍스트 7(Context 7)요. 그건 모르겠습니다.
**파쉬 (Pash)**: 그건 큰 겁니다. 컨텍스트 7(Context 7)은 어디서든 문서를 가져오는 데 도움이 됩니다. 그리고 모든 인기 라이브러리(library)와 그 문서에 대한 큰 인덱스(index)를 가지고 있습니다. 당신의 에이전트(agent)는 자연어 쿼리(query)를 제출하고 어떤 문서든 검색할 수 있습니다.
**스윅스 (Swyx)**: 그리고 분명히 업스태시(Upstash)가 그것을 했는데, 업스태시(Upstash)는 보통 레디스(Redis)이기 때문에 이것도 특이합니다. 깃 도구(Git Tools)는 원래 나왔던 것입니다. 페치(Fetch). 브라우저 사용. 브라우저 사용은 브라우저 도구와 경쟁한다고 생각합니다, 그렇죠? 제 생각엔요. 그리고 그 아래에 플레이라이트(Playwright)가 있습니다. 플레이라이트(Playwright), 맞죠? 그래서 많은 것들이 있습니다. 예를 들어, 브라우저(browser)를 자동화하고 작업을 수행합시다. 디버깅(debugging)을 위한 것이라고 가정합니다. 파이어크롤(Firecrawl), 퍼페티어(Puppeteer), 피그마(Figma). 여기 당신을 위한 것이 있습니다. 퍼플렉시티 리서치(Perplexity research). 당신 것입니까?
**파쉬 (Pash)**: 글쎄요, 네, 제가 그것을 포크(fork)해서 등록했습니다. 하지만 네, 그것은, 아시다시피, 무엇이든 연구할 수 있는 또 다른 매우 인기 있는 것입니다.
**스윅스 (Swyx)**: 그래서 사람들은 브라우저(browser)를 에뮬레이트(emulate)하고 싶어 합니다. 저는 사람들이 무엇을 하는지로부터 교훈을 얻으려고 합니다, 그렇죠? 그들은 브라우저(browser)를 자동화하고 싶어 합니다. 그들은 깃(Git)과 파일 시스템(file system)에 접근하고 싶어 합니다. 그들은 문서와 검색에 접근하고 싶어 합니다. 다른 것은 없습니까? 주목할 만하다고 생각하는 것이요?
**파쉬 (Pash)**: 온갖 종류의 것들이 있습니다. 예를 들어, 슬랙(Slack) MCP가 있는데, 그것으로 메시지를 보낼 수 있습니다. 아시다시피, 그것은 실제로 제가 설정한 워크플로우(workflow) 중 하나입니다. 클라이언트(Client)에서 반복 작업(repetitive task)을 자동화할 수 있습니다. 그래서 저는 클라이언트(Client)에게 '이 PR(Pull Request)을 가져와라. 터미널(terminal)을 사용하여 이미 설치된 GH 명령줄 도구(command line tool)를 사용하여 PR을 가져오고, PR의 설명, 토론, 그리고 전체 차이(diff)를 단일 명령, 비대화형 명령으로 가져와라'고 말합니다. 네. 그 모든 컨텍스트(context)를 가져오고, 차이(diff) 주변 파일을 읽고, 검토하고, '이 댓글로 승인할까요, 말까요?'와 같은 질문을 합니다. 그리고 제가 '네'라고 하면 승인하고, 예를 들어 슬랙(Slack) MCP를 사용하여 팀에 슬랙(Slack) 메시지를 보냅니다. 아, 작성하는 데 사용합니다. 네. 저는 읽는 데만 사용할 겁니다. 네, 아니요, 아시다시피, 사람들은 '저는 그것을 좋아합니다. 슬랙(Slack) 등으로 자동 메시지를 보낼 수 있는 것이 좋습니다'라고 합니다. 당신은 또한 워크플로우(workflow)를 원하는 대로 설정할 수 있습니다. 예를 들어, '클라이언트(Client)야. 아무것도 하기 전에 나에게 물어봐 줘. 메시지를 보내기 전에 승인해 달라고 요청하는지 확인해 줘'와 같이 말이죠.

**MCP(Multi-Agent Communication Protocol) 수익화의 과제와 미래 전망**
**스윅스 (Swyx)**: 네. 알겠습니다. MCP 측면을 마무리하기 위해, MCP 세계에서 이야기해야 할 다른 흥미로운 점이 있습니까? MCP 오프(off)가 최근 비준되었습니다.
**파쉬 (Pash)**: 저는 수익화(monetization)가 현재 MCP 생태계(ecosystem)의 큰 질문이라고 생각합니다. 우리는 스트라이프(Stripe)와 많은 이야기를 나누었습니다. 그들은 MCP에 대해 매우 낙관적이며, 그것을 위한 수익화 계층을 알아내려고 노력하고 있습니다. 하지만 모든 것이 너무 초기 단계(early)여서 실제로 어디로 갈지 상상하기조차 어렵습니다.
**스윅스 (Swyx)**: 제가 허수아비 논증(straw man)을 제시할 테니, 무엇이 잘못되었는지 말씀해 주십시오. API 수익화(monetization)와 이것이 어떻게 다릅니까?
**파쉬 (Pash)**: 아니요, 지금은 그렇다고 생각합니다. 매직 MCP, 21세기 개발자들이 그렇게 했습니다. 하지만 우리는 에이전트(agent)가 스스로 사용할 수 있는 MCP 도구에 대해 비용을 지불하고, 각 도구 호출에 대해 비용을 지불하며, 다른 제품의 수백만 개의 다른 API 키(API key)를 처리하고 모든 것에 가입할 필요가 없는 세상을 구상하고 있습니다. 통합된 결제 계층이 필요합니다. 어떤 사람들은 스테이블 코인(stable coins)에 대해 이야기합니다. 이제 에이전트(agent)가 기본적으로 그것들을 사용할 수 있게 되었다고요. 스트라이프(Stripe)는 결제를 위한 MCP 프로토콜(protocol) 주변의 이런 추상화(abstraction)를 고려하고 있습니다. 하지만 제가 말했듯이, 그것이 어디로 갈지, 어떻게 나타날지(manifest)를 실제로 말하기는 어렵습니다.
**스윅스 (Swyx)**: 저는 그들이 작년에, 몇 달 전에 에이전트 툴킷(toolkit)을 출시했을 때, 그것으로 충분했다고 말할 수 있습니다. 그들이 거래당 30센트를 가져간다는 사실을 제외하고는 스테이블 코인(stable coins)이 필요해 보이지 않았습니다. 네.
**알레시오 (Alessio)**: 코인베이스(Coinbase)의 X402를 사용하여 결제가 포함된 HTTP 요청(HTTP request)을 할 수 있는 것을 본 적이 있습니까?
**파쉬 (Pash)**: 네, 네, 그것은 오랫동안 존재했습니다. 402 오류는 '결제 거부'와 같은 것입니다. 맞습니다. 그래서, 네, 우리는 일부 사람들이 그것에 대해 이야기하는 것을 보았습니다. 예를 들어, 그것을 더 기본적으로 내장하는 것과 같이요. 하지만 네, 아무것도요. 네, 지금은 아무도 실제로 그렇게 하고 있지 않습니다.

**MCP(Multi-Agent Communication Protocol)의 보안 및 신뢰 문제와 해결 방안**
**스윅스 (Swyx)**: 흥미로운 MCP 스타트업(startup)을 만드는 사람들이 있습니까?
**알레시오 (Alessio)**: 대부분 로컬(local) 서버를 재호스팅(rehosting)하고 원격으로 전환한 다음, 기본적으로 10개의 MCP를 설정하는 대신, 모든 도구에 넣는 표준 URL(URL)을 가지고 모든 서버(server)에서 모든 도구를 노출하는 방식입니다. 네, 이러한 도구 중 일부를 실행하는 MCP가 있습니다.
**스윅스 (Swyx)**: 네, 하지만 저는 그것이 더 나은 MCP를 만들도록 사람들을 어떻게 장려할 것인가, 그리고 그것이 주로 퍼스트 파티(first party)일 것인가 서드 파티(third party)일 것인가 하는 동일한 문제를 가지고 있다고 생각합니다.
**파쉬 (Pash)**: MCP와 퍼플렉시티(perplexity)를 기기에 로컬로 설치하는 것은 항상 엄청난 위험을 수반합니다. 그리고 MCP가 누구인지 전혀 모르는 사람에 의해 생성될 때, 그들은 언제든지 깃허브(GitHub)를 업데이트(update)하여 어떤 종류의 악성 코드(malicious stuff)를 도입할 수 있습니다. 그래서 당신이 그것을 등록할 때 확인했더라도, 그들은 그것을 변경할 수 있습니다. 그래서 저는 그 버전을 고정하기 위해 몇 개를 포크(fork)해야 했습니다.
**스윅스 (Swyx)**: 아, 알겠습니다. 그래서 이것은 당신이 그것을 변경하지 않도록 그냥 포크(fork)하는 것이군요. 네, 없이 없이요. 흥미롭네요. 이것들은 모두 레지스트리(registry)의 문제점이죠, 그렇죠? 보안 등을 보장해야 하는 것 말입니다. 좋습니다. 다음으로 넘어가겠습니다. 마지막으로 궁금한 점은 이렇습니다. 앤트로픽(Anthropic)이 MCP를 만들지 않았다면 어떻게 되었을까요?

**MCP(Multi-Agent Communication Protocol) 없는 대체 역사: 오픈 표준의 가치**
**스윅스 (Swyx)**: 대체 역사(alternative history)는 어땠을까요? 당신이 MCP를 만들었을까요?
**사우드 (Saoud)**: 그래서 우리는 이러한 에이전트(agent)에 플러그 앤 플레이(plug and play) 도구를 자체적으로 개발해 온 경쟁사들을 보았습니다. 그들은 이러한 도구와 통합을 제품에 직접 기본적으로 생성해야 했습니다. 그래서 저는 앤트로픽(Anthropic)이 우리 모두에게 많은 수고를 덜어주고 오픈 소스(open source)와 커뮤니티(community) 주도 개발의 힘을 활용하여, 개별 기여자(individual contributor)들이 사람들이 생각할 수 있는 모든 것에 대한 MCP를 만들고 사람들의 상상력을 정말 활용할 수 있도록 했다고 생각합니다. 이는 지금 우리가 이런 종류의 것의 잠재력을 최대한 발휘하기 위해 필요하다고 생각하는 방식입니다.

**코딩 에이전트(Agent)의 시장 포지셔닝(Positioning) 및 IDE 통합 매트릭스(Matrix): 다양한 접근 방식**
**알레시오 (Alessio)**: 그래서 우리는 다른 코딩 제품(coding product)에 대한 에피소드를 12개 정도 가졌던 것 같습니다. 네.
**스윅스 (Swyx)**: 그리고 그건 그렇고, 이 에피소드는 그가 트윗(tweet)한 직후에 나왔습니다. 그가 클라우드 코드(Cloud Code) 에피소드에 대해 트윗(tweet)했던 것 같은데, 그들은 당신이 앉아 있는 바로 그 자리에 앉아 있었습니다. 클립을 공유해 주셔서 감사합니다. RAG에 대해 이야기하고 있습니다. 네. 코딩 에이전트(Agent)의 시장 포지셔닝(Positioning) 및 IDE 통합 매트릭스(Matrix)에 대해 사람들에게 설명해 주실 수 있습니까? 어떤 도구가 가장 적합한지, 그리고 당신들이 가장 잘하는 것은 무엇입니까?
**사우드 (Saoud)**: 저는 우리가 가장 잘하는 것과 처음부터 우리의 정신(ethos)은 개발자들이 현재 있는 곳에서 그들을 만나는 것이라고 생각합니다. 저는 지금 이 모델들이 약간의 통찰력(insight)과 안내를 필요로 한다고 생각합니다. 그리고 IDE는 그런 것에 완벽한 통로입니다. 당신은 그것이 만드는 편집을 볼 수 있습니다. 당신은 그것이 실행하는 명령을 볼 수 있습니다. 당신은 그것이 호출하는 도구를 볼 수 있습니다. 그것은 당신이 오늘날 이 모델들의 한계(model limitations)와 함께 작업하기 위해 필요한 방식으로 통찰력(insight)과 제어 수준을 가지고 경로를 수정할 수 있는 완벽한 UX(User Experience)를 제공합니다. 하지만 모델이 더 좋아짐에 따라, 당신은 그것을 점점 덜 하게 되고, 초기 계획과 프롬프팅(prompting)을 점점 더 많이 하게 될 것이며, 모델이 당신이 원하는 대로 정확히 작업을 완료할 수 있을 것이라는 신뢰와 확신을 갖게 될 것이라는 것은 꽤 분명하다고 생각합니다. 저는 이 모델들이 우리의 마음을 읽을 수 없을 것이라는 점에서 항상 약간의 간극이 있을 것이라고 생각합니다. 그래서 당신이 원하는 모든 세부 사항을 가장 포괄적으로 제공하는 것을 확실히 해야 할 것입니다. 그래서 당신이 게으른 프롬프트 사용자라면, 많은 마찰과 주고받음(back and forth)을 예상할 수 있습니다. 당신은 정말로 원하는 것을 얻을 것입니다. 하지만 저는 우리가 이러한 것들과 함께 작업하면서, 이러한 것들을 프롬프트(prompt)하는 올바른 방법과 우리가 원하는 것을 명확히 하는 방법, 그리고 그들이 최종 결과에 도달하기 위해 채워야 할 간극을 어떻게 환각하는지, 그리고 우리가 그런 것을 어떻게 피하고 싶은지 스스로 배우고 있다고 생각합니다. 그래서 클라우드 코드(Cloud Code)에 대해 흥미로운 점은 에이전트(agent)가 무엇을 하는지에 대한 많은 통찰력(insight)이 없다는 것입니다. 그것은 당신에게 전체적으로 높은 수준에서 무엇을 하는지에 대한 체크리스트(checklist)를 제공합니다. 저는 모델이 실제로 생산할 만큼 충분히 좋지 않았다면 그것이 잘 작동하지 않았을 것이라고 생각합니다. 하지만 저는 이 분야가 '아마도 사람들은 더 이상 이런 종류의 것에 대한 많은 통찰력(insight)이 필요하지 않을 것이다. 그리고 그들은 에이전트(agent)가 작업을 완료하도록 허용하는 것에 만족한다. 그리고 당신이 봐야 할 것은 최종 결과이며, 그것이 정말 완벽해지기 전에 약간 수정하는 것뿐이다'는 것에 따라잡아야 한다고 생각합니다. 그리고 저는 다른 작업에 다른 도구들이 있을 것이라고 생각합니다. 저는 많은 통찰력(insight)이 없는 완전히 자율적인 에이전트(agent)와 같은 것은 새로운 프로젝트(project) 스캐폴딩(scaffolding)에 훌륭하다고 생각합니다. 하지만 진지하고 더 복잡한 종류의 것들, 예를 들어 특정 수준의 통찰력(insight)이 필요하거나 더 많은 참여가 필요한 경우에는 더 많은 통찰력(insight)을 제공하는 것을 사용하고 싶을 수도 있습니다. 그래서 저는 이러한 종류의 도구들이 서로 보완한다고 생각합니다. 예를 들어, 테스트(test)를 작성하거나 동일한 버그(bug)를 수정하기 위해 10개의 에이전트(agent)를 분리하는 것은 당신에게 너무 많은 참여를 요구하지 않는 도구에 유용할 수 있습니다. 반면에 약간 더 많은 창의성이나 상상력을 요구하는 것. 또는 당신의 뇌에서 컨텍스트(context)를 추출하는 것은 모델이 무엇을 하는지에 대한 약간 더 많은 통찰력(insight)과 주고받음(back and forth)을 요구하며, 저는 클라이언트(client)가 그것에 조금 더 적합하다고 생각합니다.
**파쉬 (Pash)**: 에이전트(agent)가 무엇을 하는지에 대한 가시성(visibility)이 한 축입니다. 그리고 다른 하나는 자율성(autonomy)입니다. 얼마나 자동화되었는지 말이죠. 그리고 우리는 코드를 보려고 하지도 않는 사람들의 사용 사례(use case)에 더 집중하는 회사들의 범주를 가지고 있습니다. 예를 들어, 러버블스(lovables), 리플릿(replets)과 같은 곳이죠. 당신이 들어가서 앱(app)을 만들고, 기술적이지 않을 수도 있지만 결과에 만족합니다.

**코딩 에이전트(Agent)의 가시성 및 자율성: 개발자 통제와 AI 효율성**
**알레시오 (Alessio)**: 엔지니어(engineer)로서 제가 가진 문제는 우리 모두가 복잡한 일을 한다고 믿고 싶어 한다는 것입니다. 시간이 지남에 따라 복잡성의 정의는 어떻게 변했습니까?
**파쉬 (Pash)**: 그리고 엔지니어(engineer)를 위해 만들어졌지만, 내부에서 무슨 일이 일어나는지에 대한 가시성(visibility)이 많지 않은 하이브리드(hybrid) 같은 것들도 있습니다. 이것은 바이브 코더(vibe coders)를 위한 것입니다. 그들은 완전히 AI가 주도하도록(take the wheel) 하고 매우 빠르게 무언가를 구축하며, 많은 오픈 소스(open source) 팬(fan)들과 취미 생활자들이 이것으로 코딩(coding)하는 것을 즐깁니다. 그리고 진지한 엔지니어링 팀(engineering team)에 이르면, 그들은 모든 것을 AI에 맡길 수 없습니다. 적어도 아직은요. 그리고 그들은 모든 단계에서 무슨 일이 일어나는지에 대한 높은 가시성(visibility)을 가져야 하고, 그들의 코드에서 실제로 무슨 일이 일어나는지 이해해야 합니다. 당신은 프로덕션 코드베이스(production code base)를 이 비결정론적 시스템(non-deterministic system)에 넘겨주고, 뭔가 잘못되면 검토에서 발견하기를(catch it in review) 바라는 것입니다. 반면에 개인적으로 제가 AI를 사용하는 방식, 클라인(Cline)을 사용하는 방식은 모든 단계에서 함께하며 올바른 방향으로 안내하는 것을 좋아합니다. 그래서 모든 파일이 편집될 때마다 모든 것을 승인하고, 일이 올바른 방향으로 가고 있는지 확인하며, 개발되는 동안 일이 어디로 가고 있는지 잘 이해하고 있습니다. 그래서 이런 종류의 하이브리드 워크플로우(hybrid workflow)는 개인적으로 저에게 정말 잘 맞습니다. 하지만, 아시다시피, 때로는 완전 YOLO 모드(mode)로 가고 싶을 때, 저는 그냥 모든 것을 자동 승인(auto approve)하고 커피 한 잔 마시러 나갔다가 돌아와서 작업을 검토합니다.

**프로그래밍 작업 복잡성의 진화하는 정의와 AI의 역할**
**사우드 (Saoud)**: 저는 몇 년 전만 해도 복잡했던 것이 오늘날에는 완전히 다르다고 생각합니다. 이제 우리는 초기 단계에서 내리는 아키텍처 결정에 대해 더 의도적으로 접근해야 합니다. 당신이 명확한 방향을 가지고 있고 무엇을 원하는지 잘 알고 있다면, 기초를 어떻게 놓을지에 대한 좋은 아이디어를 가질 수 있습니다. 몇 년 전 복잡하다고 여겨졌던 알고리즘적 도전 과제들은 오늘날 모델에게는 매우 사소한 일입니다. 이제 우리는 원하는 것에 대한 특정 기대치나 단위 테스트를 제공하고, 모델은 완벽한 해결책을 제시합니다. 그래서 저는 많은 생각이 맛있는 아키텍처 결정에 들어가야 한다고 생각합니다. 이는 당신이 무엇이 작동하고 무엇이 작동하지 않는지에 대한 경험을 가지고 있을 때만 가능합니다. 프로젝트의 방향과 코드베이스에 대한 당신의 비전에 대한 명확한 아이디어를 가지고 있어야 합니다. 이러한 모든 결정은 모델에 의존하기 어렵습니다. 왜냐하면 모델은 제한된 컨텍스트를 가지고 있고, 당신의 비전을 이해할 수 없으며, 당신이 원하는 모든 것을 담은 거대한 프롬프트를 작성하지 않는 한 당신이 무엇을 달성하려고 하는지 제대로 이해할 수 없기 때문입니다. 하지만 몇 년 전 우리가 대부분의 시간을 보냈던 작업은 완전히 바뀌었습니다. 그리고 저는 더 좋은 방향으로 바뀌었다고 생각합니다. 저는 아키텍처 결정에 대해 생각하는 것이 알고리즘을 만드는 것보다 훨씬 더 재미있다고 생각합니다.
**파쉬 (Pash)**: 이는 선임 소프트웨어 엔지니어들이 더욱 아키텍처적인 사고를 할 수 있도록 해줍니다. 그들은 현재 저장소(repository)의 상태와 아키텍처를 잘 이해하고, 새로운 것을 도입할 때 진정으로 아키텍처 수준에서 생각합니다. 그리고 그들은 이를 클라인(Cline)에게 명확하게 전달합니다. 물론 여기에는 약간의 기술이 필요하며, 에이전트 측에서 후속 질문을 하거나 명확히 하는 방식으로 완화될 수 있습니다. 하지만 궁극적으로 이 새로운 아키텍처를 에이전트에게 명확히 전달해야 하며, 그러면 에이전트는 깊이 파고들어 모든 것을 구현할 수 있습니다. 이런 식으로 일하는 것이 더 재미있습니다. 개인적으로 저는 더 아키텍처적인 수준에서 생각하는 것이 훨씬 더 흥미롭고, 주니어 엔지니어들에게는 코드베이스(codebase)를 배우는 데 정말 좋은 패러다임입니다. 마치 주머니 속에 선임 엔지니어가 있는 것과 같습니다. 클라인(Cline)에게 '이 저장소(repository)를 설명해 줄래? 이런 것을 구현하고 싶다면 어떤 파일을 봐야 할까? 이건 어떻게 작동하는 거지?'라고 물어보는 것과 같습니다. 그것에도 훌륭합니다.

**클라인(Cline)의 포크(Fork) 및 오픈 소스(Open Source) 후회: 커뮤니티의 힘**
**알레시오 (Alessio)**: 경쟁에서 벗어나, 마지막 질문이 있습니다. 루코드(RooCode)와의 트위터 설전(beef)에 대해 알고 싶습니다. 어제 당신이 트윗(tweet)한 것을 봤는데, 누군가 루코드에게 Gemini CLI 지원을 추가해달라고 요청했고, 당신들은 "또 우리 것을 베끼는군요"라고 답했습니다. 그리고 그들은 "감사합니다. 출처를 밝히겠습니다"라고 말했습니다. 정말로 설전입니까?
**파쉬 (Pash)**: 우리는 모두 타임라인에서 즐거운 시간을 보내고 있다고 생각합니다. 포크(fork)가 많습니다.
**사우드 (Saoud)**: 6천 개 정도의 포크(fork)가 있습니다.
**파쉬 (Pash)**: 네, 클라인(Cline)을 VS Code 마켓플레이스(marketplace)에서 검색하면, 전체 페이지가 클라인(Cline)의 포크(fork)들로 가득합니다. 심지어 포크(fork)의 포크(fork)들도 나와서 엄청난 돈을 모으기도 했습니다.
**사우드 (Saoud)**: 오픈라우터(OpenRouter)의 상위 세 앱은 모두 클라인(Cline)과 클라인(Cline) 포크(fork), 클라인(Cline) 포크(fork)입니다.
**파쉬 (Pash)**: 재밌네요. 수십억 개의 토큰이 이 모든 포크(fork)들을 통해 전송되고 있습니다. 포크 전쟁이 벌어지고 있는데, 나이프 하나면 충분하죠. 흥미진진합니다. 저는 그들이 모두 정말 멋진 사람들이라고 생각합니다. 유럽에서 우리를 포크(fork)하는 사람들도 있고, 중국에서 작은 포크(fork)를 만드는 사람들도 있습니다. 삼성도 최근에 월스트리트 저널(Wall Street Journal) 기사에서 클라인(Cline)을 사용하지만, 자신들만의 작은 클라인(Cline) 포크(fork)를 사용한다고 밝혔습니다. 아시다시피, 우리는 그것을 장려합니다.
**알레시오 (Alessio)**: 오픈 소스(open source)에 대해 후회하는 점은 없습니까?
**사우드 (Saoud)**: 전혀 없습니다. 클라인(Cline)은 코딩 에이전트(coding agent)가 어떤 모습이어야 하는지에 대한 정말 좋은 기반으로 시작했으며, 사람들은 그 위에 구축하고 싶은 자신만의 흥미로운 아이디어와 스핀오프, 개념을 많이 가지고 있었습니다. 그리고 그것을 보고, 이 분야 전반의 흥분을 보는 것은 영감을 주었으며, 무엇이 효과적이고 무엇이 그렇지 않은지에 대한 통찰력을 주어 우리 제품에 반영할 수 있도록 도왔습니다. 그리고 대부분의 경우, 아시다시피, 우리 중 많은 사람들이 삼성(Samsung)과 모든 조직에서 수년 동안 일해 왔습니다. 거기에는 많은 마찰이 있고, 이런 종류의 소프트웨어를 코드베이스(codebase)에서 사용할 수 있습니다. 그것은 진입 장벽을 줄여주는데, 이는 이 완전히 새로운 에이전트 코딩 패러다임(agentic coding paradigm)에 발을 들여놓고 싶을 때 엄청나게 중요하다고 생각합니다. 이 패러다임은 우리가 수십 년 동안 소프트웨어를 작성해 온 방식을 완전히 뒤엎을 것입니다. 그래서 큰 그림에서 보면, 저는 그것이 세상과 이 분야에 긍정적인 영향을 미친다고 생각합니다. 그래서 후회는 없습니다.

**에이전트(Agent) 설계의 단순성 대 복잡성: 최적의 균형점 찾기**
**파쉬 (Pash)**: 여러 면에서, 아시다시피, 우리와 포크(fork)들은 처음부터 단순성을 유지하고, 모델이 모든 것을 하도록 하며, 추론(inference)으로 돈을 벌려고 하지 않고, 컨텍스트(context)에 집중하며, 파일을 컨텍스트(context)로 적극적으로 읽어들이는 철학을 가진 유일한 존재였습니다. 클라우드 코드(Cloud Code)를 다시 살펴보면, 그들이 가능한 한 단순하게 유지하는 우리 철학을 검증해 주었다는 것이 정말 좋았습니다. 이는 래그(RAG)와도 연결됩니다. 래그는 2022년 초기에 등장한 것으로, 컨텍스트 윈도우(context window)가 매우 작았을 때 벡터 데이터베이스(vector database) 회사들이 "AI에게 무한한 메모리를 줄 수 있다"고 홍보하며 투자자들을 끌어모았습니다. 하지만 래그는 코드베이스(codebase)를 인덱싱하고 작은 조각으로 나누어 임의의 코드 스니펫(code snippet)을 검색하는 방식인데, 이는 모델을 혼란스럽게 하고 오히려 성능을 저하시킵니다. 시니어 소프트웨어 엔지니어가 새로운 저장소(repository)에 처음 접했을 때처럼, 폴더 구조를 보고 파일을 탐색하며 에이전트적으로 저장소를 탐색하는 방식이 훨씬 더 효과적이라는 것을 우리는 발견했습니다.

**패스트 어플라이(Fast Apply)가 비터 레슨(Bitter Lesson)을 얻은 방법: 기술 발전의 교훈**
**사우드 (Saoud)**: 래그(RAG)와 패스트 어플라이(Fast Apply)는 모델이 대규모 컨텍스트(context) 처리나 검색 및 대체(search and replace) 편집에 능숙하지 않았을 때 유용한 도구였습니다. 하지만 이제는 더 이상 필요 없는 추가적인 요소가 되어 문제를 일으킬 수 있습니다. 코그니션 랩스(Cognition Labs)의 흥미로운 기사에서 다중 에이전트 오케스트레이션(multi-agent orchestration)에 대해 이야기했습니다. 그들은 여러 모델과 에이전트가 함께 작업할 때 세부 사항에서 많은 것이 손실될 수 있다고 지적했습니다. 그리고 악마는 세부 사항에 있습니다. 그것들이 가장 중요한 것들이며, 에이전트가 루프에 빠지거나 동일한 문제에 다시 부딪히지 않도록 하고, 모든 올바른 컨텍스트를 갖도록 하는 것입니다. 그래서 저는 모델에 가까이 다가가 필요한 모든 컨텍스트를 제공하고, 관련 컨텍스트를 가져오기 위한 비용 최적화된 접근 방식을 취하지 않는 것이 중요하다고 생각합니다. 래그(RAG)나 더 저렴한 모델을 사용하여 파일에 편집을 적용하는 것 말입니다. 저는 궁극적으로, 네, 더 비싸다고 생각합니다. 클라우드 소넷(Cloud Sonnet)과 같은 모델에게 이러한 모든 종류의 일, 즉 전체 코드베이스를 그랩(grep)하고 전체 컨텍스트를 채우도록 요청하는 것은 말입니다. 하지만 당신은 지불한 만큼 얻습니다. 그리고 저는 그것이 오픈 소스(open source)의 또 다른 이점이라고 생각합니다. 우리 개발자들은 기모노 아래를 들여다볼 수 있습니다. 그들은 자신의 요청이 어디로 전송되는지, 어떤 프롬프트가 이러한 것들에 들어가는지 볼 수 있습니다. 그리고 그것은 특정 수준의 신뢰를 만듭니다. 그들은 하루에 10달러, 20달러, 100달러를 쓸 때, 자신의 데이터가 어디로 전송되는지, 어떤 모델이 사용되는지, 어떤 프롬프트가 이러한 것들에 들어가는지 압니다. 그래서 그들은 작업을 완료하기 위해 그만큼의 돈을 쓰는 것에 편안함을 느낍니다.
**파쉬 (Pash)**: 네, 추론(inference)으로 돈을 벌지 않는 것이 중요합니다. 인센티브(incentive)는 이 논의에서 매우 중요합니다. 왜냐하면, 아시다시피, 당신이 한 달에 20달러를 청구하고 그것으로 돈을 벌려고 한다면, 당신은 모든 종류의 중요한 작업을 더 작은 모델로 오프로드(offload)하거나, 래그(RAG)와 같은 방식으로 비용을 최적화하려고 할 것입니다. 파일 전체를 읽는 것이 아니라 작은 스니펫(snippet)을 읽는 것과 같이요. 반면에 당신이 추론으로 돈을 벌지 않고 사용자가 자신의 API 키(API key)를 가져오도록 한다면, 당신은 비용 절감에 인센티브를 받지 않고 최고의 에이전트(agent)를 구축하는 데 집중할 수 있습니다. 우리는 전체 산업이 그 방향으로 움직이는 추세를 보기 시작했습니다. 아시다시피, 모든 사람들이 종량제 모델(pay as you go models)이나 추론에 직접 비용을 지불하는 모델에 개방되기 시작했습니다. 그리고 저는 그것이 미래라고 생각합니다.

**클라인(Cline)의 비즈니스 모델(Business Model) 및 BYO-API 키(Bring-Your-Own-API-Key) 접근 방식: 투명성과 사용자 중심**
**알레시오 (Alessio)**: 클라인(Cline)의 가격 책정 비즈니스 모델(Business Model)은 무엇입니까?
**사우드 (Saoud)**: 현재는 API 키(API key)를 가져오는 방식입니다. 당신이 사용하는 추론 제공업체(inference provider)나 모델에 대한 사전 약정이 있다면, 당신의 앤트로픽(Anthropic)이나 오픈AI(OpenAI), 오픈라우터(OpenRouter) API 키(API key)를 클라인(Cline)에 연결하기만 하면 됩니다. 그리고 저는 그 수준의 투명성, 그 수준의 '우리는 최고의 제품을 구축하고 있다. 우리는 가격 불투명성이나 영리한 속임수, 모델 오케스트레이션(orchestration)을 통해 우리 비용을 낮추고 더 높은 이익을 최적화하는 데 집중하지 않는다'는 것이 우리를 이러한 모델을 최대한 활용할 수 있는 독특한 위치에 놓았다고 생각합니다. 그리고 저는 그것이 나타났다고 생각합니다. 아시다시피, 당신은 지불한 만큼 얻습니다. 클라인(Cline)에 작업을 던지면 비용이 많이 듭니다.
**파쉬 (Pash)**: 하지만 그것이 지능의 비용입니다.
**사우드 (Saoud)**: 네, 그게 지능의 비용입니다. 그래서 현재 비즈니스 모델은 당신이 선택할 수 있는 오픈 소스(open source)이며, 당신은 그것을 포크(fork)할 수 있고, 당신의 데이터가 어디로 전송되는지 선택할 수 있으며, 누구에게 지불할지 선택할 수 있습니다. 우리가 대화한 많은 조직들은 이러한 제공업체(provider)들과 특정 볼륨 기반 할인(volume based discounts)을 받고 있으며, 클라인(Cline)을 통해 이를 활용할 수 있습니다. 이는 클라인(Cline)이 꽤 비쌀 수 있기 때문에 도움이 됩니다. 네.
**스윅스 (Swyx)**: 잠깐만요, 그럼 어떻게 돈을 버는 겁니까? 아? 왜? 왜 돈을 벌어야 하죠? 네. 아, 급여를 지불해야 하니까요.
**파쉬 (Pash)**: 아니요, 그건 많은 사람들이 우리에게 묻는 질문인데, 저는 항상 그들에게 '왜 돈을 벌어야 하죠?'라고 되묻습니다. 하지만 진짜 답은 엔터프라이즈(enterprise)입니다.
**스윅스 (Swyx)**: 네, 우리가 출시할 때 이걸 말해도 된다고 했죠. 네.
**파쉬 (Pash)**: 엔터프라이즈(enterprise)에 대해 이야기하고 싶습니까?
**사우드 (Saoud)**: 저는 오픈 소스(open source)이고 API 키(API key)를 가져오는 방식이 데이터 프라이버시(data privacy), 제어, 보안이 최우선인 조직들에서 쉽게 채택될 수 있도록 했다고 생각합니다. 그리고 저는 그것이 정말 중요하다고 생각합니다. 그들의 코드를 일반 텍스트로 어떤 서버로 보내서 데이터를 훈련시키고, 그 데이터가 무작위 사용자에게 IP를 유출할 수 있는 모델을 훈련시키는 것에 전념하기는 어렵습니다. 저는 사람들이 자신의 데이터가 어디로 전송되고 무엇에 사용되는지에 대해 훨씬 더 의식하고 있다고 생각합니다. 그래서 그것은 우리에게 '아무것도 우리 서버를 통과하지 않으며, 당신은 전체 애플리케이션(application)과 데이터가 전송되는 곳에 대한 완전한 통제권을 가지고 있다'고 말할 수 있는 기회를 얻었습니다. 그리고 그것은 좋습니다. 그리고 저는, 아시다시피, 지난 몇 달 동안 우리가 이야기해 온 조직에서 우리가 이야기해 온 것 중 하나는 이러한 쉬운 채택과 우리가 그들과 더 긴밀하게 협력하여 조직 전체에 채택을 돕기 위해 할 수 있는 모든 것, 본질적으로 이러한 조직에서 클라인(Cline)에 대한 사람들의 열정에 기름을 붓고 엔터프라이즈(enterprise) 수준에서 에이전트 코딩(agent decoding)의 사용을 확산시키는 방법입니다.
**파쉬 (Pash)**: 글쎄요, 네, 정말 놀라운 것은, 우리가 클라인(Cline)을 오픈 소스(open source)로 공개했을 때, 사람들이 정말 좋아했습니다. 개발자들이 조직 내에서 클라인(Cline)을 사용했고, 조직들은 우리가 오픈 소스이고 데이터를 어디로도 보내지 않는다는 것을 알았기 때문에 마지못해 승인했습니다. 그리고 우리는 엔터프라이즈(enterprise)를 위한 연락 양식을 웹사이트에 올렸지만, 당시에는 실제 엔터프라이즈 제품이 없었습니다. 그런데 엄청난 수의 대기업들이 우리에게 연락해 왔습니다. 그리고, 아시다시피, 포춘 5대 기업 중 하나가 우리에게 와서 '이봐요, 우리 조직 내에서 수백 명의 엔지니어가 클라인(Cline)을 사용하고 있습니다. 그리고 이것은 우리에게 엄청난 문제입니다. 이것은 우리가 해결해야 할 불입니다. 왜냐하면 우리는 그들이 어떤 API 키(API key)를 사용하고 있는지, 얼마나 지출하고 있는지, 데이터를 어디로 보내고 있는지 전혀 모르기 때문입니다. 제발 우리에게 돈을 주고 엔터프라이즈 제품을 만들어 주세요'라고 말했습니다. 그래서 제품은 그런 식으로 진화했습니다. 맞습니다. 맞습니다.
**사우드 (Saoud)**: 제 말은, 그것은 정말로 우리 사용자들의 의견을 듣는 것으로 귀결됩니다. 그래서 우리가 이 페이지를 게시한 직후, 우리는 이러한 조직의 관리자들이 클라인(Cline)과 같은 것을 안정적으로 사용하기 위해 필요한 보안 가드레일(security guardrails)과 거버넌스(governance) 및 통찰력(insight)과 같은 기본적인 엔터프라이즈 기능에 대한 많은 요구를 받았습니다. 네. 우리는 많은 사람들이 우리에게 두 가지를 제공해 달라고 요청했습니다. 수천 달러를 지출하는 모든 예산 책정 및 지출을 돕기 위한 송장입니다. 모든 유럽인들. 네. 그리고 다른 하나는 약간 놀라웠는데, 클라인(Cline)이 그들에게 제공하는 이점에 대한 어느 정도의 통찰력입니다. 그래서 그것은 우리 시대나 작성된 코드 라인일 수 있습니다. 왜냐하면 그것은 이러한 조직에서 이러한 종류의 도구를 채택하기 위한 AI 선도적인 동인들이 그것을 증거로 삼아 다른 팀들에게 가서 '클라인(Cline)이 나를 이렇게 많이 돕고 있습니다. 우리는 업계의 다른 사람들과 보조를 맞추기 위해 이것을 채택하기 시작해야 합니다'라고 말할 수 있도록 하기 때문입니다.
**스윅스 (Swyx)**: 이것은 내부 챔피언들이 자신의 ROI를 증명하기 위한 것이군요. 정확합니다. 알겠습니다.
**사우드 (Saoud)**: 그들은 아마도 지출을 정당화하기 위해 동일한 것을 사용할 수 있을 것입니다. 네.

**오픈라우터(OpenRouter) 및 엔터프라이즈(Enterprise) 인프라(Infrastructure) 통합: 개방형 생태계의 가능성**
**스윅스 (Swyx)**: 우리는 이 문제를 나중에 다룰 수 있지만, 우리는 그들 중 일부와 이야기를 나누고 싶습니다. 그들이 팟캐스트에서 상사들에게 무엇을 말하는지 들어보고 싶습니다. 왜냐하면 우리는 종종 개발 도구의 창업자와 개발자들과만 이야기하지만, 최종 소비자들과는 이야기하지 않기 때문입니다. 그리고 실제로 우리는 그들에게서 듣고 싶습니다, 그렇죠? 그들이 무엇을 필요로 하는지에 대해 어떻게 생각하는지 말입니다. 꽤 멋집니다. 제가 더블 클릭하고 싶었던 한 가지는 당신의 그룹에 있는 인스타그램 문서에 대한 것입니다. 오픈라우터(OpenRouter)와 당신의 엔터프라이즈(enterprise) 서비스 간의 관계입니다. 제 이해로는 현재 모든 것이 오픈라우터(OpenRouter)를 통해 실행됩니다.
**사우드 (Saoud)**: 모든 것이 그런 것은 아닙니다. 오픈AI(OpenAI), 앤트로픽(Anthropic), 베드락(Bedrock)에 API 키(API key)를 가져올 수 있습니다. 그리고 사용자에게 직접적인 연결이 있습니다.
**스윅스 (Swyx)**: 하지만 다른 모든 것은 오픈라우터(OpenRouter)를 통해 실행될 것입니다. 그래서 기본적으로 클라이언트(Client)의 엔터프라이즈(enterprise) 버전은 당신이 해당 엔터프라이즈(enterprise)에 가시성(visibility)과 제어권을 제공하는 자체 오픈라우터(OpenRouter)를 가질 것이라는 의미입니까?
**파쉬 (Pash)**: 네, 그것은 자체 호스팅(self-hosted) 옵션에 대한 것입니다. 맞죠? 자체 호스팅(self-hosted)을 하지 않아도 괜찮지만, 자신의 베드락(Bedrock) API 키(API key) 등을 사용하는 한, 많은 엔터프라이즈(enterprise)가 있습니다. 반면에 자체 호스팅(self-hosted)에 정말 관심이 있거나 팀을 관리하고 싶은 사람들을 위해서는 내부 라우터(router)가 있을 것입니다.

**모델 비용 감소의 영향: AI 서비스의 대중화 가속**
**스윅스 (Swyx)**: 여기서 궁금한 점은 모델 비용이 0으로 떨어진다면 어떻게 될까요? Gemini 코드가 나와서 "여러분, 무료입니다"라고 말한다면요?
**사우드 (Saoud)**: 네, 그러면 우리에게는 정말 좋을 겁니다. 우리의 가설은 추론(inference)이 비즈니스가 아니라는 것입니다.
**스윅스 (Swyx)**: 추론으로 돈을 벌지 않을 것이라는 말이죠? 네.
**사우드 (Saoud)**: 우리는 최종 사용자에게 가격에 대한 완전한 투명성을 제공하고 싶습니다. 이는 당신이 지출하는 만큼의 돈을 쓰는 것에 편안함을 느끼기 위해 엄청나게 중요하다고 생각합니다. 이 공간에서 가격 불투명성은 개발자들이 사용량 기반 요금제(usage-based plans)에 가입하는 것을 주저하게 만들었습니다. 그리고 우리는 많은 사람들이 '아마도 제품 사용을 위한 기본 요금제는 있지만, 추론은 방해하지 않고, 최종 개발자에게 비용뿐만 아니라 사용되는 모델에 대한 통찰력을 제공하여 작업을 완료하는 데 필요한 만큼 돈을 쓰는 데 더 자신감을 갖게 하자'는 개념에 수렴하고 있다고 봅니다. 저는 래그(RAG)나 패스트 어플라이(Fast Apply)와 같은 속임수를 사용하여 비용을 낮게 유지할 수 있다고 생각합니다. 하지만 대부분의 경우, 코딩 에이전트(coding agents)에는 충분한 ROI가 있어서, 아시다시피, 사람들은 작업을 완료하기 위해 돈을 기꺼이 지출합니다.
**파쉬 (Pash)**: 그리고 정말 좋은 코딩 에이전트(coding agent)의 ROI는 계산하기조차 어렵습니다. 왜냐하면 제가 클라인(Cline)이 없었다면 시도조차 하지 않았을 일들이 너무 많기 때문입니다. 하지만 이제 클라인(Cline)이 있으니, 이 이상한 실험을 하거나, 이 사이드 프로젝트를 하거나, 제가 생각조차 하지 않았을 이 무작위 버그를 수정할 수 있습니다. 그래서 그것을 어떻게 측정합니까?

**백그라운드 에이전트(Background Agent) 및 다중 에이전트 시스템(Multi-Agent System): 미래 AI 아키텍처의 핵심**
**스윅스 (Swyx)**: 이 문제의 한 가지 변형은... 이제 컨텍스트 엔지니어링(context engineering)과 메모리(memory) 등 다른 모든 것에 대해 이야기해 보겠습니다. 이 문제의 또 다른 변형은 백그라운드 에이전트(background agent)와 다중 에이전트(multi-agent)입니다. 현재 코덱스(Codex)와 같이 백그라운드 에이전트(background agent)는 1분당 하나의 PR을 생성하거나, 데빈(Devin)이나 코그니션(Cognition)처럼 작동합니다. 당신도 그런 방향으로 갈 것입니까? 그것은 제가 당신에게 물을 수 있는 한 가지 구체적인 질문입니다. 서버에 클라인(Cline)이 있을까요? 그리고 다른 버전은 여전히 노트북에 있지만, 칸반(Kanban)과 같은 병렬 에이전트(parallel agents)입니다. 지금 칸반(Kanban)은 매우 과대평가되어 있습니다. 사람들은 커서(Cursor)와 클라우드 코드(Cloud Code)를 위한 칸반 인터페이스(Kanban interfaces)를 만들고 있습니다. 병렬 또는 백그라운드 측면에서 어떤 것이든요.
**파쉬 (Pash)**: 우리는 클라인(Cline)의 CLI 버전(CLI version)을 출시할 예정이며, 이는 완전히 모듈식입니다. 그래서 클라인(Cline)에게 CLI를 실행하여 더 많은 클라인(Cline)을 스핀업(spin up)하도록 요청하거나, 깃허브 액션(GitHub action)에서 클라우드 프로세스(cloud process)로 클라인(Cline)을 실행할 수 있습니다. 원하는 대로요. 그래서 CLI는 이러한 완전히 자율적인 에이전트(agent)를 위한 형태입니다. 그리고 기존의 클라인(Cline) CLI가 컴퓨터에서 실행되고 있는 것에 연결하여 제어하고 올바른 방향으로 이끌 수 있다는 것도 좋습니다. 그것도 가능합니다. 하지만 사우드, 어떻게 생각하십니까?
**사우드 (Saoud)**: 저는 이것이 '이것 아니면 저것'의 문제가 아니라고 생각합니다. 이 모든 다른 방식들이 서로를 정말 잘 보완한다고 생각합니다. 코덱스(Codex), 데빈(Devin), 커서(Cursor)의 백그라운드 에이전트(background agent)는 모두 같은 목표를 달성합니다. 우리가 자체 버전을 출시한다면, 저는 그것이 다른 개발자들이 그 위에 구축할 수 있는 기반이 될 것이라고 말하고 싶습니다. 닉의 형인 앙드레(Andre)는 10년 앞을 내다보고 있습니다. 그리고 그가 이 분야가 어디로 향하는지에 대해 가지고 있는 몇 가지 아이디어는 항상 저를 놀라게 합니다. 하지만 우리는 최근에 어떤 플랫폼이든 코딩 에이전트(coding agents)를 위한 오픈 소스 프레임워크(open source framework)를 구축하는 것에 대해 논의했습니다. SDK와 도구, 그리고 클라인(Cline)을 크로마(Chroma) 확장 프로그램(extension), CLI, 젯브레인즈(JetBrains), 주피터 노트북(Jupyter notebooks), 스마트카 등 어디든 가져오는 데 도움이 되고 필요한 모든 다른 것들을 구축하는 것입니다. 하지만 냉장고. 냉장고. 정확합니다. 전자레인지. 네, 정확합니다. 이것이 우리가 클라인(Cline)의 6000개 포크(fork)에서 본 것처럼, 우리는 이 개발자 커뮤니티가 그 위에 구축하고 활용할 수 있는 기반을 마련했습니다. 아시다시피, 그들의 실험과 상상력, 그리고 이 분야가 어디로 향하는지에 대한 그들의 창의성을 활용하는 것입니다. 그리고 저는 앞으로 10년을 내다볼 때, 우리는 적어도 소프트웨어 개발이나 VS Code 확장 프로그램(extension)의 범위를 넘어선 곳으로 클라인(Cline)과 같은 것을 가져오는 방법에 대한 빌딩 블록(building blocks)을 제공하는 최전선에 서고 싶다고 생각합니다. 저는 그것이 궁극적으로 서로를 정말 잘 보완하는 것들의 문을 열 것이라고 생각합니다. 하지만 그것은 결코 '이것 아니면 저것'의 문제가 아닐 것입니다. 백그라운드 에이전트(background agents)는 특정 종류의 작업에 좋고, 병렬 칸반(Kanban) 다중 에이전트(multi-agents)는 랜딩 페이지(landing page)가 어떻게 보일지에 대한 다섯 가지 다른 버전을 실험하고 반복하고 싶을 때 좋을 수 있습니다. 그리고 클라이언트(Client)와 같은 단일 에이전트(agent)와의 주고받음(back and forth)은 컨텍스트(context)를 가져오고 정말 복잡한 작업을 위한 정말 복잡한 계획을 세우고 싶을 때 정말 잘 작동합니다. 그리고 저는 이러한 모든 다른 도구들이 궁극적으로 서로를 보완하게 될 것이며, 사람들은 어떤 종류의 작업에 무엇이 가장 잘 작동하는지에 대한 취향과 이해를 발전시키게 될 것이라고 생각합니다. 하지만 저는 10년 앞을 내다볼 때, 우리는 적어도 백그라운드 에이전트(background agents)나 다중 에이전트(multi-agents) 이후의 다음 것을 위한 빌딩 블록(building blocks)을 제공하는 최전선에 서고 싶다고 생각합니다.

**비전(Vision) 및 멀티모달리티(Multi-Modalities): AI의 감각 확장**
**스윅스 (Swyx)**: 컨텍스트 엔지니어링(context engineering)으로 넘어가겠습니다. 아시다시피, 이 주제는 RAG와 RAG가 정신 바이러스(mind virus)라는 말처럼 비슷한 맥락에 있다고 생각합니다. 당신의 문서에는 컨텍스트 관리(context management) 섹션이 있고, 메모리 뱅크(memory bank) 섹션도 있습니다. 꽤 멋지다고 생각합니다. 많은 사람들이 메모리(memory)를 파악하려고 노력하고 있습니다. 높은 수준에서 시작해서 나중에 메모리(memory)로 넘어가겠습니다. 컨텍스트 엔지니어링(context engineering)은 당신에게 무엇을 의미합니까?

**컨텍스트 엔지니어링(Context Engineering)의 현황과 AI 상호작용의 심화**
**사우드 (Saoud)**: 컨텍스트 엔지니어링(context engineering)은 저에게 무엇을 의미합니까?
**스윅스 (Swyx)**: 그것은 프롬프트 엔지니어링(prompt engineering)을 의미합니다. 네, 맞습니다. 제 말은, 거기에 들어가는 것에는 많은 예술적 요소가 있다고 생각합니다. 저는 그것이 정말 좋은 에이전트(agent)를 구축하는 데 있어 80-20 원칙이라고 생각합니다. 컨텍스트(context)에 무엇이 들어가야 하는지, 그리고 MCP와 시스템 클라이언트, 권장 프롬프트(prompt) 사이의 상호작용이 궁극적으로 좋은 에이전트(agent)를 만드는 요소입니다.
**파쉬 (Pash)**: 네, 컨텍스트 관리(context management)는 컨텍스트(context)에 무엇을 로드(load)하는가 하는 한 부분입니다. 다른 부분은 컨텍스트 윈도우(context window)에 도달했을 때 어떻게 정리하는가 하는 것입니다. 전체 라이프사이클(lifecycle)을 어떻게 관리하는가 하는 것입니다. 네, 저는 컨텍스트 관리(context management)는 컨텍스트(context)에 무엇을 로드(load)하는가 하는 한 부분이라고 생각합니다. 다른 부분은 컨텍스트 윈도우(context window)에 도달했을 때 어떻게 정리하는가 하는 것입니다. 그리고 제가 생각하는 방식은, 테이블 위에 너무 많은 옵션이 있고, 에이전트를 잘못된 방향으로 이끌거나 방해할 위험이 너무 많다는 것입니다. RAG나 다른 종류의 검색과 같은 아이디어들도 있습니다. 그것은 한 가지 아이디어입니다. 에이전트적 탐색(agentic exploration)도 있습니다. 그것은 우리가 훨씬 더 효과적이라는 것을 발견한 또 다른 아이디어입니다. 그리고 추세는 일반적으로 컨텍스트(context)에 무언가를 로드(load)하는 방향으로 바뀌고 있는 것 같습니다. 모델이 컨텍스트(context)에 가져올 수 있는 도구를 제공하고, 모델이 정확히 무엇을 컨텍스트(context)에 가져올지 결정하도록 하며, AST(Abstract Syntax Tree)와 같은 일종의 지도를 따라 힌트를 주는 것입니다. VS Code에서 열려 있는 탭이 무엇인지도 포함될 수 있습니다. 그것은 실제로 우리 내부 벤치마킹에서 매우, 매우 잘 작동하는 것으로 나타났습니다. 몇 개만 열려 있어도 마치 당신의 마음을 읽는 것과 같습니다.
**스윅스 (Swyx)**: 그것은 저를 스트레스 받게 합니다. 왜냐하면 때로는 관련 없는 탭이 열려 있어서 작업을 시작하기 전에 닫아야 하기 때문입니다.
**파쉬 (Pash)**: 클라인(Cline)을 사용할 때는 너무 많이 생각하지 않을 겁니다. 클라인(Cline)은 그것을 잘 처리합니다. 하지만 분명히 예외적인 경우가 있습니다, 그렇죠? 모든 것에는 예외적인 경우가 있습니다. 그리고 그것은 '좋아, 대부분의 사용 사례는 무엇인가?'와 같습니다. 관련 없는 탭이 하나도 열려 있지 않은 상태에서 새로운 작업을 시작하는 경우와 같습니다. CLI에서는 그런 작은 표시기가 없습니다. 그래서 거기서는 생각해야 합니다. 상자 밖의 많은 것들을 생각할 필요는 없습니다. 그래서 그것은 컨텍스트(context)에 무언가를 읽어들이는 것에 대한 것입니다. 그리고 컨텍스트 관리(context management)는 컨텍스트 윈도우(context window)의 전체 용량에 도달했을 때 어떻게 압축하는가 하는 것입니다. 그리고 우리는 초기에 이런 종류의 순진한 잘라내기(truncation)를 시도했습니다. 대화의 절반을 그냥 버리는 것입니다. 그리고 그것에는 분명히 문제가 있습니다. 왜냐하면 그것은 마치 책을 절반쯤 읽다가 시작하는 것과 같기 때문입니다. 당신은 이전에 무슨 일이 일어났는지 아무것도 모릅니다. 그리고 우리는 내러티브 무결성(narrative integrity)에 대해 많이 생각합니다. 클라이언트(client)의 모든 작업은 일종의 이야기와 같습니다. 지루한 이야기일 수도 있습니다. 외로운 코딩 에이전트(coding agent)가 당신이 무엇이든 해결하도록 돕기로 결심한 것과 같습니다. 주인공이 극복해야 할 큰 문제는 작업의 해결입니다, 그렇죠? 하지만 우리는 에이전트가 결론에 도달하기 위해 이야기의 다음 부분을 예측할 수 있도록 내러티브 무결성(narrative integrity)을 어떻게 유지할까요? 그래서 우리는 중복 파일 읽기(duplicate file reads)를 정리하는 것과 같은 것을 시도했습니다. 그것은 꽤 잘 작동합니다. 하지만 궁극적으로 이것은 또 다른 경우입니다. '모델에게 그냥 물어보면 어떨까? 컨텍스트(context)에 무엇이 속한다고 생각하니?' 이것의 또 다른 형태는 요약입니다. '이봐, 모든 관련 세부 사항을 요약해 줘. 그리고 우리는 그것을 교체할 거야.' 그리고 그것은 정말, 정말 잘 작동합니다.
**스윅스 (Swyx)**: AST 언급에 대해 더 자세히 설명해 주십시오. 언제 그것을 사용합니까?
**사우드 (Saoud)**: 현재, 그것은 도구입니다. 클라이언트(client)가 관련 컨텍스트(context)를 가져오기 위해 에이전트적 탐색(agentic exploration)을 수행할 때, 예를 들어 특정 디렉토리(directory)에서 무엇이 진행되고 있는지 파악하려고 할 때 사용됩니다. 이 도구는 클래스 이름이나 함수 이름과 같은 디렉토리(directory)의 언어를 가져올 수 있도록 하여, 해당 폴더에서 무엇이 진행되고 있는지 파악하는 데 도움을 줍니다. 그리고 그것이 수행하려는 작업과 관련이 있다고 판단되면, 해당 파일 전체를 컨텍스트(context)로 읽어들입니다. 그래서 그것은 본질적으로 대규모 코드베이스(codebases)를 탐색하는 방법을 파악하는 데 도움이 되는 방법입니다.
**파쉬 (Pash)**: 우리는 일부 회사들이 AST를 지식 그래프(knowledge graph)로 활용하는 것을 보았습니다. 이는 흥미로운 아이디어입니다. AST이지만 지식 그래프(knowledge graph)이기도 하며, 이러한 지식 그래프(knowledge graph)에서 이산적인 결정론적 작업을 실행할 수 있습니다. 그래서 그것은 마치, 아시다시피, 코드베이스(codebase)의 모든 함수를 찾고, 사용되지 않는 모든 함수를 찾아 삭제하는 것과 같이요. 에이전트(agent)는 거의 SQL과 같은 언어로 이 지식 그래프(knowledge graph)와 상호 작용하여 이러한 전역적인 작업을 수행할 수 있습니다. 지금 당장 코딩 에이전트(coding agent)에게 사용되지 않는 모든 함수를 제거하거나 대규모 리팩토링(refactoring) 작업을 수행하도록 요청하면, 어떤 경우에는 작동할 수도 있습니다. 하지만 대부분의 경우, 많은 토큰을 소모하고 궁극적으로 실패할 것입니다. 반면에 이러한 종류의 도구를 사용하면, 이러한 종류의 쿼리, 즉 짧은 쿼리 문을 사용하여 전체 저장소(repository)에서 실제로 작동할 수 있습니다. 저는 이러한 종류의 것에 많은 잠재력이 있다고 생각합니다. AST를 넘어선 다음 단계이며, 이러한 종류의 지식 그래프(knowledge graph)를 쿼리하는 언어입니다. 하지만, 아시다시피, 클라우드 4(Cloud 4) 릴리스에서 본 것처럼, 이러한 프론티어 모델(frontier model) 회사들은 자체 애플리케이션 계층(application layer)에서 훈련하는 경향이 있습니다. 그리고 당신은 이론적으로는 정말 잘 작동할 매우 영리한 도구를 만들 수도 있지만, 클라우드 4(Cloud 4)와는 잘 작동하지 않습니다. 왜냐하면 클라우드 4(Cloud 4)는 그랩(grep)하도록 훈련되었기 때문입니다. 그래서 그것은 또 다른 흥미로운 현상입니다. 아시다시피, 당신은 이러한 프론티어 모델(frontier models)이 시간이 지남에 따라 더 일반화될 것이라고 기대하지만, 대신 더 전문화되고 있으며, 이러한 다른 모델 제품군(model families)을 지원해야 합니다.

**코딩 에이전트(Agent)의 메모리 시스템(Memory System): 지식 관리의 새로운 패러다임**
**알레시오 (Alessio)**: 메모리(memory) 측면을 마무리하기 위해, 메모리는 거의 요약의 결과물입니다. 그래서 당신은 컨텍스트(context)를 요약하고, 몇 가지 측면을 추출합니다. 특히 코드에 대해, 어쩌면 직관적이지 않은 흥미로운 학습 내용은 없습니까? 사람들은 인간에 대한 메모리(memory)는 이해하지만, 코드베이스(codebases)에 대한 메모리(memory)와 같은 것은 어떻게 보입니까?
**사우드 (Saoud)**: 저는 현재 메모리(memory)가 대부분 쓸모없다고 생각합니다. 당신이 코딩할 때 원하는 종류의 메모리는, 저는 사람들이 그런 것들에 대해 생각하고 싶어 하지 않는다고 생각합니다. 그래서 우리가 생각하고 있는 것은, 에이전트가 도중에 배우는 부족 지식(tribal knowledge)을 어떻게 유지할 수 있을까 하는 것입니다. 사람들이 문서화하지 않거나 규칙 파일에 넣지 않는 것들을 말입니다. 사용자가 이러한 것들을 메모리 데이터베이스(memory database)에 강제로 저장하도록 하지 않고 말입니다.
**파쉬 (Pash)**: 그것들은 작업 공간 규칙이나 부족 지식, 팀으로서 사용하는 일반적인 패턴과 같습니다. 하지만 우리는 내부 실험을 통해 할 일 목록 도구를 만들었습니다. 거기에는 할 일을 작성하는 도구 하나만 있었고, 매번 할 일을 처음부터 다시 작성할 수 있었습니다. 그리고 우리는 수동적으로, 모든 메시지는 아니지만, 가끔씩 이 할 일 목록의 최신 상태를 컨텍스트(context)로 전달했습니다. 그리고 우리는 이것이 여러 번의 컨텍스트 요약과 압축 후에도 에이전트(agent)를 계속 궤도에 올려놓는다는 것을 발견했습니다. 그리고 그것은 갑자기 컨텍스트 윈도우(context window) 길이의 10배 이상에 걸쳐 전체 복잡한 작업을 처음부터 구축할 수 있었습니다. 그리고 내부 테스트에서 이것은 매우, 매우 유망했습니다. 그래서 우리는 그것을 구체화하려고 노력하고 있습니다. 그리고 저는 그런 것이, 우리는 이전에 메모리 뱅크(memory bank)의 초기 버전을 가지고 있었습니다. 실제로 우리 마케팅 담당자인 닉 바우만(Nick Bauman)이 이 메모리 뱅크(memory bank) 개념을 고안했는데, 그것은 클라이언트 규칙과 같았습니다. 그는 클라이언트에게 '이봐, 작업할 때마다 작업 중인 스크래치 패드(scratch pad)를 가지고 있어'라고 말했습니다. 그리고 이것은 그것을 하는 더 내장된 방법입니다. 그리고 저는 그것이 에이전트가 '이봐, 지금까지 무엇을 했지? 무엇이 남았지? 특정 앱 파일 언급, 어떤 종류의 코드를 작업하고 있지? 일반적인 컨텍스트(context)를 세션 간에 전달하는 것'과 같은 작은 스크래치 패드(scratch pad)를 갖는 데 매우, 매우 도움이 될 수 있다고 생각합니다. 네.

**에이전트(Agent) 도구 전반의 규칙 파일 표준화와 상호 운용성(interoperability) 증진**
**알레시오 (Alessio)**: CloudMD, AgentsMD, AgentMD에 대한 생각은 없습니까? 저는 Agents927이라는 오픈 소스 도구를 만들었는데, XKCD처럼 모든 파일 이름에 복사-붙여넣기하여 모든 파일이 접근할 수 있도록 했습니다. 단일 파일이 있어야 한다고 생각하십니까? IDE 규칙과 에이전트 규칙도 있습니다. 많은 문제가 있습니다.
**사우드 (Saoud)**: 저는 각 도구가 자신만의 특정 지침을 가지고 있는 것이 괜찮다고 생각합니다. 왜냐하면 저는 커서(Cursor) 규칙과 클라인(Cline) 규칙을 따로 사용하기 때문입니다. 클라인(Cline)이라는 에이전트(agent)가 특정 방식으로 작동하기를 원하는데, 이는 커서(Cursor)가 제 코드베이스(codebase)와 상호 작용하기를 원하는 방식과는 다릅니다. 그래서 저는 각 도구가 제가 하는 작업의 종류에 특화되어 있다고 생각합니다. 그리고 저는 이러한 것들이 작동하기를 원하는 방식에 대해 다른 지침을 가지고 있습니다. 그래서 저는 많은 사람들이 그것에 대해 불평하는 것을 보았고, 코드베이스(codebases)를 약간 보기 흉하게 만들 수 있다는 것을 이해합니다. 하지만 저에게는 그것들이 분리되어 있는 것이 엄청나게 도움이 되었습니다.

**클라인(Cline)의 성격 및 의인화: 사용자 경험의 인간적 요소**
**스윅스 (Swyx)**: 그가 '그'라고 말하는 것을 들었습니다. 클라인(Cline)에게는 전체적인 배경 성격이 있습니까? 네.
**사우드 (Saoud)**: 클라인(Cline)은 CLI와 에디터(editor)를 가지고 있습니다.
**스윅스 (Swyx)**: 이전에는 클로드 데브(Claude Dev)였고, 이제는 클라인(Cline)입니다. 네.
**사우드 (Saoud)**: 저는 클라인(Cline)이 커서(Cursor) 에이전트(agent)나 코파일럿(Copilot)이나 캐스케이드(cascade)와 같은 것보다 좀 더 인간적인 면모를 가지고 있다는 점에서 이 분야에서 돋보인다고 생각합니다.
**스윅스 (Swyx)**: 그리고 데빈(Devin)이라는 실제 이름도 있죠. 클로드(Claude)도 실제 이름이고요. 네.
**사우드 (Saoud)**: 네. 그래서 저는 클라인(Cline)에 있을 때보다 클라인(Cline)에 있을 때 좀 더 자의식이 있다고 생각합니다. 저는 그것이 저를 더 자신감 있게 만든다고 생각합니다. 저는 그것이 저를 더 자신감 있게 만든다고 생각합니다. 왜냐하면 저는 그것에 좀 더 의지할 수 있었기 때문입니다. 에이전트(agent)와 인간 사이에 일종의 신뢰 구축이 있습니다. 그리고 그것의 인간화 측면은 개인적으로 저에게 도움이 되었습니다. 그리고
**파쉬 (Pash)**: 그리고 이것은 내러티브 무결성(narrative integrity)으로 돌아갑니다. 에이전트(agent)를 의인화하는 것이 정말 중요하다고 생각합니다. 모든 행동은 작은 이야기와 같고, 뚜렷한 정체성이 없으면 결과가 좋지 않습니다. 그리고 이러한 에이전트(agent)를 개발할 때, 우리는 그런 식으로 생각해야 합니다, 그렇죠? 우리는 이러한 이야기를 만들고 있다고 생각해야 합니다. 우리는 거의 할리우드 감독과 같습니다, 그렇죠? 우리는 이야기가 전개되도록 모든 올바른 조각을 제자리에 놓는 것입니다. 그리고 네, 그것을 둘러싼 정체성을 갖는 것이 정말, 정말 중요합니다.
**스윅스 (Swyx)**: 그리고 클라인(Cline), 아시다시피, 그는 멋진 작은 친구입니다. 그는 그냥 느긋한 친구입니다. 그는 우리를 돕고 있습니다. 아시다시피, 그는 항상 기꺼이 돕습니다. 아니면 그에게 행복하지 말라고 말하면, 그는 매우 심술궂을 수 있습니다. 그래서 좋습니다. 멋집니다. 당신이 채용 중이라는 것을 압니다. 현재 20명입니다. 100명을 목표로 하고 있습니다. 멋진 새 사무실도 있습니다. 클라인(Cline)에서 일하는 것에 대한 최고의 홍보 문구는 무엇입니까?

**클라인(Cline) 채용 및 팀 문화: 혁신을 위한 인재 확보**
**사우드 (Saoud)**: 현재 우리의 채용은 대부분 친구의 친구, 우리 네트워크의 사람들, 우리가 이전에 함께 일했고 신뢰하는 사람들로 이루어져 있습니다. 우리가 당면한 이 엄청나게 어려운 과제를 해결하기 위해 함께 일할 수 있는 사람들입니다. 앞으로 많은 도전 과제가 있습니다. 저는 문제 공간이 지금 당장 가장 흥미로운 분야라고 생각합니다. 엔지니어들은 일반적으로 자신의 삶을 더 쉽게 만드는 일에 열정적입니다. 그래서 코딩 에이전트(coding agent)보다 더 흥미로운 일은 상상할 수 없습니다. 이는 약간 편향된 의견일 수 있지만, 흥미로운 문제 공간이 큰 부분을 차지합니다. 우리는 앞으로 10년이 어떻게 될지 파악하고, 백그라운드 에이전트(background agent)나 다중 에이전트(multi-agent) 이후에 무엇이 올지, 그리고 이 모든 것이 어떻게 형성될지 정의하는 데 기여하고 싶은 정말 의욕적인 사람들을 찾고 있습니다. 우리는 정말 열정적인 사용자 및 개발자 커뮤니티를 가지고 있습니다. 저는 오픈 소스(open source)가 우리에게 많은 선의를 가져다주었다고 생각합니다. 우리가 받는 피드백 중 많은 부분이 우리의 로드맵(roadmap)과 우리가 구축하는 제품을 형성하는 데 엄청나게 건설적이고 도움이 됩니다. 그리고 그런 커뮤니티와 함께 일하는 것은 가장 만족스러운 일 중 하나입니다. 지금은 사무실을 옮기는 중이지만, 카트 타기나 카약 타기 등과 같은 활동을 합니다. 그래서 많은 노력이 필요하지만, 아시다시피, 우리는 그 과정에서 즐거움을 느끼도록 노력합니다.
**파쉬 (Pash)**: 네, 아니요, 클라인(Cline)은 독특한 회사입니다. 왜냐하면 우리는 모두 친구처럼 멋진 것을 만들고 있다는 느낌이 정말 들기 때문입니다. 그리고 우리는 정말 열심히 일하고 있으며, 이 분야는 경쟁이 치열할 뿐만 아니라, 하이퍼 경쟁적입니다. 모든 경쟁자들에게 자본이 흘러 들어가고 있고, 제가 말했듯이 포크(fork)의 포크(fork)들도 수천만 달러를 모금하고 있습니다. 그리고 우리는 매우 빠르게 성장하고 있습니다. 현재 20명이며, 연말까지 100명을 목표로 하고 있습니다. 그리고 오픈 소스(open source)는 자체적인 도전 과제를 가지고 있습니다. 아시다시피, 우리는 모든 연구를 하고, 모든 벤치마킹 작업을 하여 우리의 차이 편집 알고리즘(diff editing algorithm)이 견고하고, 가장 낮은 차이 편집 실패를 위해 이러한 모델과 함께 작업하는 방식이 최적화되도록 합니다. 그리고 우리는 그것을 오픈 소스(open source)로 공개하고 트위터(Twitter)에 게시합니다. 그러면 누군가가 '오, 오픈 소스(open source)해 주셔서 정말 감사합니다. 저는 우리 제품으로 많은 돈을 모금할 것입니다'라고 말합니다. 하지만 제가 보기에는 이것은, 아시다시피, 그들이 베끼도록 내버려 두는 것입니다. 우리는 이 분야의 리더입니다. 우리는 전체 산업을 위한 길을 보여주고 있습니다. 그리고 이 모든 것을 구축하는 엔지니어(engineer)가 되는 것은 매우 흥미진진합니다. 그래서 이 모든 사람들과 함께 일하는 것은 정말 놀랍습니다.
**알레시오 (Alessio)**: 알겠습니다, 감사합니다.
**사우드 (Saoud)**: 네, 정말 즐거웠습니다.