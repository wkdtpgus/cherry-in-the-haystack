**[문맥: 기사 내용]**

**업데이트**:
**AI 기술의 진화와 새로운 가능성: 혁신을 이끄는 동력**

끊임없이 등장하는 VSCode 포크(fork)와 터미널 에이전트(terminal agent)의 시대에, AI 기술은 이제 단순한 코딩 도구를 넘어 다양한 산업 분야에 깊숙이 통합되고 있습니다. 이러한 변화는 기술 생태계 전반에 걸쳐 혁신을 촉진하며, 새로운 비즈니스 모델과 사용자 경험을 창출하고 있습니다. AI 코딩 전쟁이 격화되면서, 기술 기업들은 인공지능이 제공하는 새로운 기회를 포착하기 위해 치열하게 경쟁하고 있습니다. 이 경쟁은 단순히 더 나은 도구를 만드는 것을 넘어, AI가 인간의 삶과 업무 방식에 어떤 근본적인 변화를 가져올지에 대한 비전을 제시합니다.

클라인(Cline)은 VS Code, 커서(Cursor), 윈드서프(Windsurf)와 호환되는 AI 엔지니어 확장 프로그램(extension)을 출시했지만, 이 외에도 수많은 AI 솔루션이 시장에 쏟아져 나오고 있습니다. 이러한 솔루션들은 각자의 강점을 바탕으로 특정 니즈를 충족시키며, 사용자들에게 전례 없는 선택의 폭을 제공합니다. 놀라운 성장세를 보이며 200만 다운로드(download)에 육박하고 있습니다. 이는 사용자들의 높은 기대치를 반영하며, AI 기반 도구에 대한 폭발적인 수요를 증명합니다. 인공지능의 발전은 이제 특정 기술 분야에 국한되지 않고, 모든 산업의 근간을 뒤흔들고 있습니다.

플랜 & 액트(Plan & Act)와 코딩을 위한 RAG(Retrieval Augmented Generation)가 죽은 이유에 대해, 우리는 AI 에이전트의 자율적 문제 해결 능력에 주목해야 합니다. 기존의 RAG(즉, 코드베이스(codebase)를 인덱싱(indexing)하고 의미론적 검색(semantic search)을 수행)에서 에이전트 기반 검색(agentic search)으로 넘어가는 것입니다. 이는 AI의 지능형 추론 능력을 극대화하는 방향으로 진화하고 있습니다. 에이전트 기반 접근 방식은 AI가 단순한 정보 검색을 넘어, 복잡한 문제 상황을 스스로 분석하고 해결책을 찾아 실행하는 능력을 의미합니다. 일부 전문가들은 RAG가 정신 바이러스(mind virus)라는 과감한 주장을 펼치며, 새로운 접근 방식의 필요성을 강조합니다. 이러한 관점은 AI 시스템이 단순히 방대한 데이터를 처리하는 것을 넘어, 맥락을 이해하고 능동적으로 학습하며 발전하는 방향으로 나아가야 함을 시사합니다. 미래의 AI는 수동적인 도구가 아닌, 능동적인 협력자가 될 것입니다.

이 모든 것은 클라인(Cline)에게 몇 가지 다른 요소를 포함하는 새로운 기술 생태계를 구축하는 데 중요한 역할을 합니다. 특히 "컨텍스트 엔지니어링(context engineering)" 관행은 AI의 효율성을 극대화하는 핵심 요소로 부상하고 있습니다. 동적 컨텍스트 관리(Dynamic Context Management): 실시간으로 파일 콘텐츠(file content)를 지능적으로 읽고 요약하는 전략을 사용하여, AI는 복잡한 데이터 스트림 속에서도 핵심 정보를 놓치지 않습니다. 이는 AI가 방대한 정보 속에서 가장 관련성 높은 부분을 선별하고, 이를 바탕으로 정확한 의사결정을 내릴 수 있도록 돕습니다.

AST(Abstract Syntax Tree) 기반 분석(AST-Based Analysis): 추상 구문 트리(Abstract Syntax Tree, AST)를 사용하여 코드의 관련 부분을 정확하게 식별하고 추출하여, 소프트웨어 개발의 효율성을 획기적으로 높이고 있습니다. 이 기술은 코드의 구조와 의미를 깊이 이해하여, AI가 단순한 텍스트 편집을 넘어 코드의 논리적 흐름에 개입하고 최적화할 수 있도록 합니다. 내러티브 무결성(Narrative Integrity): 과거 상호 작용을 요약하고 주요 정보를 유지하여, 사용자 경험의 연속성과 일관성을 보장하는 것이 중요합니다. AI가 장기적인 프로젝트나 복잡한 작업을 수행할 때, 이전의 대화나 작업 이력을 일관성 있게 유지하는 것은 사용자 만족도를 높이는 데 필수적입니다. 메모리 뱅크(Memory Bank): 명시적인 입력 없이 필수적인 "부족 지식(tribal knowledge)"과 개발자 선호도를 캡처하고 유지하는 메커니즘을 개발하여, 미래의 AI 시스템은 더욱 지능적이고 개인화된 서비스를 제공할 것입니다. 이는 AI가 사용자의 특정 요구사항과 작업 스타일을 학습하여, 보다 맞춤화된 지원을 제공할 수 있게 합니다.

클라인(Cline)은 또한 매우 초기에 MCP(Multi-Agent Communication Protocol)에 집중했으며, 이는 분산형 AI 시스템의 새로운 시대를 열었습니다. MCP는 다양한 AI 에이전트들이 서로 효율적으로 통신하고 협력할 수 있도록 하는 표준화된 프로토콜로, 복잡한 작업을 여러 에이전트에게 분산하여 처리하는 것을 가능하게 합니다. 우리는 가장 인기 있는 MCP가 무엇인지 물었고, 그들의 MCP 마켓플레이스(marketplace)에서 찾을 수 있는 다양한 솔루션들을 통해 AI 에이전트의 활용 범위를 엿볼 수 있었습니다. 이러한 마켓플레이스는 AI 에이전트 생태계의 활성화를 촉진하며, 개발자들이 혁신적인 솔루션을 공유하고 배포할 수 있는 플랫폼을 제공합니다.

가장 인기 있는 MCP 목록은 다음과 같습니다:
파일 시스템 MCP(File System MCP): 파일 및 디렉토리(directory) 관리용 기능은 AI의 기본 운영 능력을 강화합니다. AI가 시스템 내의 파일을 탐색하고 조작하는 데 필수적입니다.
브라우저 자동화 MCP(Browser Automation MCP): 웹 작업을 위한 플레이라이트(Playwright), 퍼페티어(Puppeteer), 브라우저 툴(Browser Tools)은 디지털 환경에서의 AI 상호작용을 혁신하고 있습니다. AI가 웹 기반 작업을 수행하고 정보를 수집하는 데 중요한 역할을 합니다.
깃 툴(Git Tools): 저장소(repository) 상호 작용 및 버전 관리용 기능은 협업 프로젝트에서 AI의 역할을 확장합니다. AI가 코드 변경 사항을 관리하고 통합하는 데 기여합니다.
문서 검색(Documentation Retrieval, Context 7): 문서 라이브러리(library)에 쉽게 접근할 수 있습니다. 이는 정보 접근성을 크게 향상시킵니다. AI가 필요한 정보를 신속하게 찾아 활용할 수 있게 합니다.
서드파티 통합(Third-party integrations): 일반적인 코딩 환경을 넘어선 작업을 위한 다양한 도구들이 AI의 적용 범위를 넓히고 있습니다. 슬랙(Slack), 퍼플렉시티 리서치(Perplexity Research), 유니티(Unity), 에이블톤(Ableton) 등과의 통합은 AI가 단순 코딩을 넘어선 영역에서 가치를 창출할 수 있음을 보여줍니다.

놀라운 점은 MCP가 비기술직 사람들에게도 킬러 기능(killer feature)이라는 것이었습니다. 이는 AI 대중화의 중요한 신호입니다. 코딩을 전혀 하지 않지만 워크플로우 자동화 플랫폼(workflow automation platform)으로 AI를 활용하는 사례가 늘고 있으며, 이는 생산성 향상에 크게 기여합니다. 예를 들어, 자동화된 마케팅 및 소셜 미디어: 레딧(Reddit) 및 트위터(Twitter) MCP 통합을 활용하여, AI는 콘텐츠 생성과 배포 과정을 효율적으로 관리합니다. 이는 비전문가도 복잡한 마케팅 작업을 손쉽게 수행할 수 있게 합니다. 프레젠테이션 생성: 비기술직 사용자들이 음성 메모(voice notes)를 필사하고 자동으로 전문적인 프레젠테이션(presentation)으로 포맷(format)하여, 누구나 손쉽게 고품질의 자료를 만들 수 있게 되었습니다. 이러한 사례들은 AI가 단순히 기술 전문가의 전유물이 아니라, 모든 사람의 일상과 업무를 변화시킬 잠재력을 가지고 있음을 보여줍니다.

MCP의 인기가 계속 높아지고 멀티모달 텍스트박스(multi-modal textbox)가 최고의 AI 인터페이스(interface)로 계속 성장함에 따라, AI와의 상호작용 방식은 더욱 다양해질 것입니다. 미래에는 음성, 이미지, 제스처 등 다양한 입력 방식을 통해 AI와 소통하며, 더욱 직관적이고 몰입감 있는 경험을 제공할 것입니다. 이러한 변화는 AI가 우리 삶의 모든 측면에 깊이 스며들게 하는 중요한 전환점이 될 것입니다.

**쇼 노트(Show Notes)**
AI 시대의 새로운 서막: 소개
플랜 앤 액트 패러다임(Plan and Act Paradigm)의 확장된 적용
모델 평가 및 AI 시스템의 지속적인 발전
코딩을 넘어선 AI의 무한한 사용 사례
클라인(Cline)이 VS Code 확장 프로그램(Extension)인 이유: 통합과 접근성의 중요성
프로그래밍 에이전트(Agent)의 경제적 가치와 미래 산업의 변화
MCP(Multi-Agent Communication Protocol)의 초기 도입과 생태계 확장
로컬(Local) 대 원격(Remote) MCP 서버(Server): 유연성과 보안의 균형
MCP 레지스트리(Registry)에서 앤트로픽(Anthropic)의 역할과 표준화의 중요성
가장 인기 있는 MCP(Multi-Agent Communication Protocol) 및 사용 사례 분석
MCP(Multi-Agent Communication Protocol) 수익화의 과제와 미래 전망
MCP(Multi-Agent Communication Protocol)의 보안 및 신뢰 문제와 해결 방안
MCP(Multi-Agent Communication Protocol) 없는 대체 역사: 오픈 표준의 가치
코딩 에이전트(Agent)의 시장 포지셔닝(Positioning) 및 IDE 통합 매트릭스(Matrix): 다양한 접근 방식
코딩 에이전트(Agent)의 가시성 및 자율성: 개발자 통제와 AI 효율성
프로그래밍 작업 복잡성의 진화하는 정의와 AI의 역할
클라인(Cline)의 포크(Fork) 및 오픈 소스(Open Source) 후회: 커뮤니티의 힘
에이전트(Agent) 설계의 단순성 대 복잡성: 최적의 균형점 찾기
패스트 어플라이(Fast Apply)가 비터 레슨(Bitter Lesson)을 얻은 방법: 기술 발전의 교훈
클라인(Cline)의 비즈니스 모델(Business Model) 및 BYO-API 키(Bring-Your-Own-API-Key) 접근 방식: 투명성과 사용자 중심
오픈라우터(OpenRouter) 및 엔터프라이즈(Enterprise) 인프라(Infrastructure) 통합: 개방형 생태계의 가능성
모델 비용 감소의 영향: AI 서비스의 대중화 가속
백그라운드 에이전트(Background Agent) 및 다중 에이전트 시스템(Multi-Agent System): 미래 AI 아키텍처의 핵심
비전(Vision) 및 멀티모달리티(Multi-Modalities): AI의 감각 확장
컨텍스트 엔지니어링(Context Engineering)의 현황과 AI 상호작용의 심화
코딩 에이전트(Agent)의 메모리 시스템(Memory System): 지식 관리의 새로운 패러다임
에이전트(Agent) 도구 전반의 규칙 파일 표준화와 상호 운용성(interoperability) 증진
클라인(Cline)의 성격 및 의인화: 사용자 경험의 인간적 요소
클라인(Cline) 채용 및 팀 문화: 혁신을 위한 인재 확보

**녹취록**
**소개**
**알레시오 (Alessio)**: 안녕하세요, 레이턴트 스페이스 팟캐스트(Latent Space podcast)에 오신 것을 환영합니다. 저는 데시벨(Decibel)의 파트너(partner) 겸 CTO(Chief Technology Officer)인 알레시오(Alessio)이며, 스몰 AI(Small AI)의 설립자인 공동 진행자 스윅스(Swyx)와 함께합니다. 오늘 우리는 AI 기술의 급속한 발전에 대해 이야기할 예정입니다.
**스윅스 (Swyx)**: 그리고 오늘 스튜디오에는 AI의 미래를 논의하기 위해 새로운 관점을 가진 게스트들이 함께합니다. 빠르게 변화하는 AI 환경 속에서, 우리는 기술이 어떻게 진화하고 있는지, 그리고 이것이 우리 삶에 어떤 영향을 미치는지 깊이 들여다볼 것입니다.
**알레시오 (Alessio)**: 완벽했습니다. 시작하죠.
**스윅스 (Swyx)**: AI 기술은 상당한 대중적 관심을 받고 있지만, 그 복잡성 때문에 모든 사람이 그 잠재력을 완전히 이해하는 것은 아닙니다. 오늘은 AI 에이전트의 역할과 그들이 가져올 변화에 집중해 봅시다.
**사우드 (Saoud)**: 네, AI 에이전트의 발전은 단순한 소프트웨어 개선을 넘어섭니다. 이제 AI는 자율적으로 작업을 수행하고, 다양한 시스템과 상호 작용하며, 인간의 개입 없이도 복잡한 문제 해결에 기여할 수 있습니다. 이는 개발 워크플로우뿐만 아니라, 다양한 산업 분야에서 혁신을 이끌 것입니다. 에이전트는 사용자의 터미널(terminal), 에디터(editor), 브라우저(browser)를 활용하여 전체 개발자 워크플로우(workflow)를 자동화할 수 있으며, 이는 곧 AI가 우리의 업무 방식에 근본적인 변화를 가져올 것임을 의미합니다.
**스윅스 (Swyx)**: 멋집니다. 파쉬(Pash), AI 에이전트의 미래에 대해 또 다른 가치 있는 관점은 무엇이라고 생각하십니까?
**파쉬 (Pash)**: 네, 저는 AI 에이전트가 미래의 디지털 인프라(infrastructure)를 형성하는 핵심 구성 요소가 될 것이라고 생각합니다. 이들은 단순히 작업을 자동화하는 것을 넘어, 새로운 종류의 지능형 시스템을 구축하는 기반을 제공합니다. 완전히 모듈식 시스템(modular system)으로 설계된 에이전트들은 그 위에 어떤 종류의 지능형 애플리케이션이든 구축할 수 있는 유연성을 제공합니다. 새로운 CLI(Command Line Interface)와 SDK(Software Development Kit)를 통해 개발자들은 더욱 강력하고 맞춤화된 에이전트 기반 시스템(agentic system)을 구축할 수 있을 겁니다.

**플랜 앤 액트 패러다임(Plan and Act Paradigm)의 확장된 적용**
**스윅스 (Swyx)**: 아, 알겠습니다. 제가 가지고 있던 AI 에이전트에 대한 관점과는 다르네요. 그럼, 먼저 AI의 현재 적용 사례에 대해 이야기하고, 그 다음 더 넓은 미래 전망에 대해 이야기해 봅시다. 플랜 앤 액트 패러다임(Plan and Act Paradigm)이 AI 시스템의 설계에 어떻게 적용되고 있습니까?
**사우드 (Saoud)**: 네, 플랜 앤 액트(plan and act) 개념은 AI 에이전트가 복잡한 작업을 처리하는 데 있어 핵심적인 접근 방식입니다. 이는 에이전트가 작업을 수행하기 전에 먼저 상세한 계획을 수립하고, 그 계획에 따라 행동하는 두 가지 모드(mode)를 갖는 것을 의미합니다. 이 방식은 AI가 단순한 지시 수행을 넘어, 전략적인 사고를 통해 문제에 접근하도록 돕습니다. 초기에는 사용자들이 자연스럽게 이러한 워크플로우(workflow)를 만들어냈지만, 이제는 제품 설계에 이러한 개념을 통합하여 사용자 경험을 더욱 직관적으로 만들고 있습니다. 플랜 모드(plan mode)에서는 에이전트가 더 탐색적(exploratory)으로 행동하고, 더 많은 파일을 읽고, 더 많은 데이터를 얻고, 더 많은 데이터를 얻고, 더 많은 데이터를 얻도록 지시받습니다. 이는 사용자가 달성하고자 하는 목표를 위해 필요한 모든 관련 정보를 수집하고 분석하는 단계입니다. 그리고 액트 모드(act mode)로 전환하면, 에이전트(agent)는 계획을 보고 실행하기 시작하고, 명령을 실행하고, 파일을 편집하라는 지시를 받습니다. 이 과정에서 사용자는 에이전트의 진행 상황을 모니터링하며 필요시 개입하여 경로를 수정할 수 있습니다.
**알레시오 (Alessio)**: 그리고 이것이 AI 제품 개발의 초기부터 고려되었던 형태였습니까? 아니면 반복적인 개선을 통해 도달한 결과입니까?
**사우드 (Saoud)**: 특히 초기에는 많은 실험과 사용자들과의 대화가 있었습니다. 사용자들의 피드백을 통해 어떤 워크플로우(workflow)가 가장 효과적인지 파악하고, 이를 제품에 반영했습니다. 플랜 앤 액트(plan and act) 모드는 본질적으로 사용자가 복잡한 지시를 일일이 입력할 필요 없이, AI가 스스로 계획하고 실행하도록 돕는 단축키와 같습니다. 이는 사용자 편의성을 극대화하고, AI와의 상호작용을 더욱 자연스럽게 만듭니다.
**알레시오 (Alessio)**: 당시 AI 모델의 성능 평가는 어땠습니까? 모델의 한계는 무엇이었고, 그것이 어떻게 개선되어 왔습니까?

**모델 평가 및 AI 시스템의 지속적인 발전**
**사우드 (Saoud)**: 제가 AI 에이전트 작업을 처음 시작했을 때, 클라우드 3.5 소닉(Cloud 3.5 Sonic)과 같은 모델들이 단계별 작업 수행 능력이 크게 향상되었음을 발견했습니다. 당시 모델들은 Q&A(Question & Answer)나 원샷 프롬프팅(one shot prompting)에 더 적합했지만, 새로운 모델들은 더 긴 컨텍스트(context)를 이해하고 복잡한 작업을 단계별로 처리하는 데 뛰어났습니다. 예를 들어, 클라우드 3.5는 긴 컨텍스트 윈도우(context window) 내에서 미세한 세부 사항을 찾아내는 데 매우 능숙했습니다. 이러한 모델의 발전은 처음부터 제품을 설계할 때 중요한 고려 사항이었습니다. 우리는 모델의 한계를 이해하고, 이를 보완하는 방식으로 사용자 경험을 설계했습니다. 초기에는 개발자가 원하는 대로 사용할 수 있도록 가능한 한 일반적(general as possible)으로 만들고, 그들이 자신에게 잘 맞는 워크플로우(workflow)를 만들어내도록 하는 것이 중요했습니다. 이제 AI는 코딩(coding) 외에도 온갖 종류의 일에 활용되며, 그 적용 범위는 계속 확장되고 있습니다.
**파쉬 (Pash)**: 저는 컨퍼런스(conference)에서 슬라이드데브(SlideDev) 같은 자바스크립트 라이브러리(JavaScript library)를 사용하여 전체 프레젠테이션(presentation)을 만들었습니다. AI 에이전트에게 제 스타일 가이드라인(style guidelines)과 강연 아젠다(agenda)를 주었더니, 에이전트가 저를 위해 전체 슬라이드 덱(slide deck)을 만들었습니다. 이는 AI가 단순한 코드 생성을 넘어, 창의적이고 복잡한 문서 작업까지 수행할 수 있음을 보여줍니다.

**코딩을 넘어선 AI의 무한한 사용 사례**
**스윅스 (Swyx)**: 네, 그래서 코딩 사용 사례(use case)와 비슷하네요.
**파쉬 (Pash)**: 일종의 코딩 사용 사례(use case)였지만, 그것으로 프레젠테이션(presentation)을 만드는 것이었습니다. 하지만 스크립트(script)를 실행하거나, 데이터 분석(data analysis)을 해주고, 그것을 덱(deck)에 넣는 등 여러 가지를 결합할 수도 있습니다. 이러한 다재다능함은 AI의 잠재력이 얼마나 큰지 보여주는 좋은 예시입니다.
**사우드 (Saoud)**: 그리고 VS Code 확장 프로그램(extension)이라는 것은 사용자 OS(Operating System)에 접근하고, 사용자 터미널(terminal)에 접근하며, 파일을 읽고 편집할 수 있는 흥미로운 기능을 제공합니다. 이러한 접근성은 AI 에이전트가 사용자의 작업 환경에 깊이 통합되어, 더욱 광범위한 작업을 수행할 수 있도록 합니다. 확장 프로그램(extension)이라는 것은 많은 개발자들에게 온보딩(onboarding) 마찰을 크게 줄여줍니다. 새로운 애플리케이션(application)을 설치할 필요 없이 기존 환경에서 AI 기능을 활용할 수 있다는 점은 사용자 접근성을 높이는 데 결정적인 역할을 합니다.
**스윅스 (Swyx)**: VS Code를 포크(fork)하고 싶은 유혹은 없었습니까? 지금쯤 훨씬 더 큰 규모의 플랫폼을 구축할 수도 있었을 텐데요.
**사우드 (Saoud)**: 글쎄요, 아니요, 저는 VS Code를 포크(fork)해야 하는 사람들을 불쌍히 여깁니다. 마이크로소프트(Microsoft)는 이러한 포크(fork)를 유지 관리하기를 악명 높게 어렵게 만들기 때문입니다. 기존 플랫폼에 통합하는 전략은 개발 자원을 핵심 AI 기능에 집중할 수 있게 합니다.
**스윅스 (Swyx)**: 그들이 비공개 저장소(private repo)를 가지고 있고 그것을 동기화(sync)해야 하기 때문입니까?
**사우드 (Saoud)**: 맞습니다. 그리고 VS Code는 너무 빠르게 움직여서, 병합 충돌(merge conflicts)과 같은 문제뿐만 아니라 백엔드(back end)에서도 온갖 종류의 문제에 부딪힐 것이라고 확신합니다. 확장 프로그램(extension)이라는 것은 우리에게 훨씬 더 많은 배포(distribution)를 제공합니다. 커서(Cursor)나 윈드서프(Windsurf) 또는 VS Code에서 클라인(Cline)을 사용할 수 있도록 하여, 사용자들이 선호하는 환경에서 AI 에이전트를 활용할 수 있게 합니다.
**파쉬 (Pash)**: 네, VS Code의 포크(fork)를 유지 관리하는 데 얼마나 많은 자원을 소비해야 할지 상상해 보세요. 우리는 핵심 에이전트 루프(agentic loop)에 집중하고, 출시되는 다양한 모델 제품군(model family)에 대해 최적화하고, 그들을 지원할 수 있습니다. 이는 우리가 가장 잘하는 것에 집중하고, 불필요한 복잡성을 피하는 전략입니다.

**프로그래밍 에이전트(Agent)의 경제적 가치와 미래 산업의 변화**
**알레시오 (Alessio)**: 당신이 이야기할 때, 저는 '우리는 프로그래밍(programming)의 미래를 위한 최고의 것이 되고 싶다'는 것과 '이것은 비프로그래밍(non-programming)에도 훌륭하다'는 구분을 듣습니다. MCP 서버(server)를 사용하는 사람들이 점점 더 많아지고, 특히 덜 기술적인 일을 하는 것을 보는 것이 최근의 일입니까?
**사우드 (Saoud)**: 경제적 가치(economic value) 측면에서, 프로그래밍(programming)은 현재 언어 모델(language models)에게 가장 높은 비용 대비 이점(cost to benefit)을 제공합니다. 많은 모델 연구소(model labs)들이 코딩(coding)을 훨씬 더 진지하게 받아들이고 있습니다. 우리가 본 것은, 네, MCP 생태계(ecosystem)가 성장하고 있고 많은 사람들이 프로그래밍(programming) 외의 일에 그것을 사용하고 있지만, 주요 사용 사례(use case)는 대부분 개발자 작업입니다. 예를 들어, 한 개발자가 버그(bug) 있는 클라우드플레어 워커(Cloudflare worker)를 배포하고 센트리(Sentry) MCP 서버(server)를 사용하여 스택 트레이스(stack trace)를 가져온 다음, 클라인(Cline)에게 스택 트레이스(stack trace) 정보를 사용하여 버그(bug)를 수정하고, 깃허브(GitHub) MCP 서버(server)에 연결하여 이슈(issue)를 닫고, 클라우드플레어(Cloudflare)에 수정 사항을 배포하도록 요청했다는 기사가 있었습니다. 이 모든 것이 클라인(Cline) 내에서 자연어(natural language)를 사용하여 이루어졌습니다. 이는 AI 에이전트가 개발자의 인지 부하를 줄이고, 복잡한 작업을 효율적으로 처리할 수 있음을 보여줍니다.
**알레시오 (Alessio)**: 센트리(Sentry) 예시는 훌륭하다고 생각합니다. 왜냐하면 어떤 면에서는 MCP가 제품 자체를 잠식하는 것 같기 때문입니다. 클라인(Cline)이 모든 비용을 분할하는 MCP 구독(subscription)을 가질까요?

**MCP(Multi-Agent Communication Protocol)의 초기 도입과 생태계 확장**
**파쉬 (Pash)**: 글쎄요, 네, 우리는 아주 초기에 그랬습니다. 우리는 처음부터 MCP에 대해 낙관적이었습니다.
**사우드 (Saoud)**: 그리고 우리는 런치 파트너(launch partner)이자 금융 MCP였습니다. 앤트로픽(Anthropic)이 처음 MCP를 출시하고 대대적으로 발표했을 때, 아무도 그것이 무엇을 의미하는지 제대로 이해하지 못했습니다. 하지만 저는 그들이 오픈 소스(open source) 커뮤니티(community)가 생태계(ecosystem)에 기여하여 그것이 정말 성공할 수 있도록 하는 데 베팅(bet)했다고 생각합니다. 우리는 개발자들에게 내부적으로(under the hood) 어떻게 작동하는지에 대한 더 많은 통찰력(insight)과 인식을 제공하는 데 집중했습니다.
**파쉬 (Pash)**: 그 당시에는 사람들이 여전히 MCP를 이해하려고 노력하던 초기였습니다. 발견 가능성(discoverability)에 큰 문제가 있었습니다. 그래서 지난 2월쯤, 우리는 MCP 마켓플레이스(marketplace)를 출시했습니다. 거기서 실제로 클라이언트(client)가 리드미(readme)를 보고, 깃허브(GitHub)에 연결된 전체 MCP 서버(server)를 처음부터 설치하고 즉시 실행할 수 있는 원클릭 설치 프로세스(process)를 가질 수 있었습니다. 그 이후로 우리는 150개 이상의 MCP 서버(server)를 등록했습니다.

**로컬(Local) 대 원격(Remote) MCP 서버(Server): 유연성과 보안의 균형**
**알레시오 (Alessio)**: 그리고 당신은 VS Code에 있기 때문에 그것을 할 수 있습니다. 터미널(terminal)이 있으니까요. 그래서 PX로 다른 서버(server)를 실행할 수 있습니다. 원격 MCP 호스팅(hosting)을 고려해 본 적이 있습니까?
**파쉬 (Pash)**: 네, 우리는 실제로 직접 호스팅(hosting)한 적은 없습니다. 우리는 그것이, 우리는 그것을 검토하고 있습니다. 원격 MCP는 지금 매우 초기 단계(nascent)라고 생각합니다. 하지만 우리는 원격 MCP를 지원하고 우리 마켓플레이스(marketplace)에 등록하는 데 분명히 관심이 있습니다.
**사우드 (Saoud)**: 그리고 또 다른 부분은, 로컬 MCP 서버(server)와 원격 MCP의 차이점이라고 생각합니다. 대부분의 원격 MCP는 다른 API(Application Programming Interface)에 연결하는 데만 유용합니다. 하지만 그것은 MCP의 작은 사용 사례(use case)일 뿐입니다. 많은 MCP는 컴퓨터의 다른 애플리케이션(application)에 연결하는 데 도움이 됩니다. 예를 들어, 유니티(Unity) MCP 서버(server)나 에이블톤(Ableton) MCP 서버(server)처럼요. 우리는 이러한 MCP 서버(server)가 원격으로만 호스팅(hosting)되는 세상을 보지 못할 것입니다. 항상 로컬 MCP 서버(server)와 원격 MCP 서버(server)의 혼합이 있을 것입니다. 현재 MCP 생태계(ecosystem)는 보안과 편의성 사이의 균형을 찾는 실험적인 단계에 있습니다.

**MCP 레지스트리(Registry)에서 앤트로픽(Anthropic)의 역할과 표준화의 중요성**
**스윅스 (Swyx)**: 앤트로픽(Anthropic)과 여기 커뮤니티(community) 사이에 흥미로운 긴장감이 있습니다. 당신은 기본적으로 내부적으로 모델 등록 MCP 레지스트리(registry)를 가지고 있는 것 같네요, 그렇죠? 솔직히 말해서, 저는 당신이 그것을 노출해야 한다고 생각합니다. 저는 당신의 웹사이트에서 그것을 찾고 있었는데, 클라이언트(client)를 설치해야만 접근할 수 있는 것 같았습니다.
**사우드 (Saoud)**: 저는 그렇게 생각합니다. 저는 전체 생태계(ecosystem)가 그들이 하는 모든 것에 수렴할 것이라고 생각합니다. 그들은 배포(distribution)가 너무 좋고, 네, 그들이 그것을 고안했습니다.
**스윅스 (Swyx)**: 가장 인기 있는 MCP(Multi-Agent Communication Protocol) 및 사용 사례 분석
**스윅스 (Swyx)**: 그리고 저는 당신이 정말 많이 다운로드(download)된 MCP들을 가지고 있다는 것을 알았습니다. 저는 가장 많은 설치를 기준으로 보았습니다. 제가 그냥 읽어드리겠습니다. 언제든지 저를 멈추고 코멘트(comment)를 달아주셔도 됩니다. 그래서 가장 인기 있는 것은 파일 시스템 MCP(File System MCP)입니다. 이해가 됩니다. 에이전트-AI(agent-AI)의 브라우저 도구(Browser tools)요. 그게 뭔지는 모르겠습니다. 순차적 사고(Sequential thinking). 그것은 초기 MCP 릴리스(release)와 함께 나왔습니다. 컨텍스트 7(Context 7)요. 그건 모르겠습니다.
**파쉬 (Pash)**: 그건 큰 겁니다. 컨텍스트 7(Context 7)은 어디서든 문서를 가져오는 데 도움이 됩니다. 그리고 모든 인기 라이브러리(library)와 그 문서에 대한 큰 인덱스(index)를 가지고 있습니다. 당신의 에이전트(agent)는 자연어 쿼리(query)를 제출하고 어떤 문서든 검색할 수 있습니다.
**스윅스 (Swyx)**: 그리고 분명히 업스태시(Upstash)가 그것을 했는데, 업스태시(Upstash)는 보통 레디스(Redis)이기 때문에 이것도 특이합니다. 깃 도구(Git tools)는 원래 나왔던 것입니다. 페치(Fetch). 브라우저 사용. 브라우저 사용은 브라우저 도구와 경쟁한다고 생각합니다, 그렇죠? 제 생각엔요. 그리고 그 아래에 플레이라이트(Playwright)가 있습니다. 플레이라이트(Playwright), 맞죠? 그래서 많은 것들이 있습니다. 예를 들어, 브라우저(browser)를 자동화하고 작업을 수행합시다. 디버깅(debugging)을 위한 것이라고 가정합니다. 파이어크롤(Firecrawl), 퍼페티어(Puppeteer), 피그마(Figma). 여기 당신을 위한 것이 있습니다. 퍼플렉시티 리서치(Perplexity research). 당신 것입니까?
**파쉬 (Pash)**: 글쎄요, 네, 제가 그것을 포크(fork)해서 등록했습니다. 하지만 네, 그것은, 아시다시피, 무엇이든 연구할 수 있는 또 다른 매우 인기 있는 것입니다.
**스윅스 (Swyx)**: 그래서 사람들은 브라우저(browser)를 에뮬레이트(emulate)하고 싶어 합니다. 저는 사람들이 무엇을 하는지로부터 교훈을 얻으려고 합니다, 그렇죠? 그들은 브라우저(browser)를 자동화하고 싶어 합니다. 그들은 깃(Git)과 파일 시스템(file system)에 접근하고 싶어 합니다. 그들은 문서와 검색에 접근하고 싶어 합니다. 다른 것은 없습니까? 주목할 만하다고 생각하는 것이요?
**파쉬 (Pash)**: 온갖 종류의 것들이 있습니다. 예를 들어, 슬랙(Slack) MCP가 있는데, 그것으로 메시지를 보낼 수 있습니다. 아시다시피, 그것은 실제로 제가 설정한 워크플로우(workflow) 중 하나입니다. 클라이언트(Client)에서 반복 작업(repetitive task)을 자동화할 수 있습니다.

**MCP(Multi-Agent Communication Protocol) 수익화의 과제와 미래 전망**
**스윅스 (Swyx)**: 네. 알겠습니다. MCP 측면을 마무리하기 위해, MCP 세계에서 이야기해야 할 다른 흥미로운 점이 있습니까? MCP 오프(off)가 최근 비준되었습니다.
**파쉬 (Pash)**: 저는 수익화(monetization)가 현재 MCP 생태계(ecosystem)의 큰 질문이라고 생각합니다. 우리는 스트라이프(Stripe)와 많은 이야기를 나누었습니다. 그들은 MCP에 대해 매우 낙관적이며, 그것을 위한 수익화 계층을 알아내려고 노력하고 있습니다. 하지만 모든 것이 너무 초기 단계(early)여서 실제로 어디로 갈지 상상하기조차 어렵습니다.
**스윅스 (Swyx)**: 제가 허수아비 논증(straw man)을 제시할 테니, 무엇이 잘못되었는지 말씀해 주십시오. API 수익화(monetization)와 이것이 어떻게 다릅니까?
**파쉬 (Pash)**: 아니요, 지금은 그렇다고 생각합니다. 매직 MCP, 21세기 개발자들이 그렇게 했습니다. 하지만 우리는 에이전트(agent)가 스스로 사용할 수 있는 MCP 도구에 대해 비용을 지불하고, 각 도구 호출에 대해 비용을 지불하며, 다른 제품의 수백만 개의 다른 API 키(API key)를 처리하고 모든 것에 가입할 필요가 없는 세상을 구상하고 있습니다. 통합된 결제 계층이 필요합니다.
**스윅스 (Swyx)**: 저는 그들이 작년에, 몇 달 전에 에이전트 툴킷(toolkit)을 출시했을 때, 그것으로 충분했다고 말할 수 있습니다.
**알레시오 (Alessio)**: 코인베이스(Coinbase)의 X402를 사용하여 결제가 포함된 HTTP 요청(HTTP request)을 할 수 있는 것을 본 적이 있습니까?
**파쉬 (Pash)**: 네, 네, 그것은 오랫동안 존재했습니다. 402 오류는 '결제 거부'와 같은 것입니다.

**MCP(Multi-Agent Communication Protocol)의 보안 및 신뢰 문제와 해결 방안**
**스윅스 (Swyx)**: 흥미로운 MCP 스타트업(startup)을 만드는 사람들이 있습니까?
**알레시오 (Alessio)**: 대부분 로컬(local) 서버를 재호스팅(rehosting)하고 원격으로 전환한 다음, 기본적으로 10개의 MCP를 설정하는 대신, 모든 도구에 넣는 표준 URL(URL)을 가지고 모든 서버(server)에서 모든 도구를 노출하는 방식입니다.
**스윅스 (Swyx)**: 네, 하지만 저는 그것이 더 나은 MCP를 만들도록 사람들을 어떻게 장려할 것인가, 그리고 그것이 주로 퍼스트 파티(first party)일 것인가 서드 파티(third party)일 것인가 하는 동일한 문제를 가지고 있다고 생각합니다.
**파쉬 (Pash)**: MCP와 퍼플렉시티(perplexity)를 기기에 로컬로 설치하는 것은 항상 엄청난 위험을 수반합니다. 그리고 MCP가 누구인지 전혀 모르는 사람에 의해 생성될 때, 그들은 언제든지 깃허브(GitHub)를 업데이트(update)하여 어떤 종류의 악성 코드(malicious stuff)를 도입할 수 있습니다. 그래서 저는 그 버전을 고정하기 위해 몇 개를 포크(fork)해야 했습니다.
**스윅스 (Swyx)**: 아, 알겠습니다. 그래서 이것은 당신이 그것을 변경하지 않도록 그냥 포크(fork)하는 것이군요.

**MCP(Multi-Agent Communication Protocol) 없는 대체 역사: 오픈 표준의 가치**
**스윅스 (Swyx)**: 앤트로픽(Anthropic)이 MCP를 만들지 않았다면 어떻게 되었을까요? 대체 역사(alternative history)는 어땠을까요?
**사우드 (Saoud)**: 그래서 우리는 이러한 에이전트(agent)에 플러그 앤 플레이(plug and play) 도구를 자체적으로 개발해 온 경쟁사들을 보았습니다. 그들은 이러한 도구와 통합을 제품에 직접 기본적으로 생성해야 했습니다. 그래서 저는 앤트로픽(Anthropic)이 우리 모두에게 많은 수고를 덜어주고 오픈 소스(open source)와 커뮤니티(community) 주도 개발의 힘을 활용하여, 개별 기여자(individual contributor)들이 사람들이 생각할 수 있는 모든 것에 대한 MCP를 만들고 사람들의 상상력을 정말 활용할 수 있도록 했다고 생각합니다. 이는 지금 우리가 이런 종류의 것의 잠재력을 최대한 발휘하기 위해 필요하다고 생각하는 방식입니다.

**코딩 에이전트(Agent)의 시장 포지셔닝(Positioning) 및 IDE 통합 매트릭스(Matrix): 다양한 접근 방식**
**알레시오 (Alessio)**: 그래서 우리는 다른 코딩 제품(coding product)에 대한 에피소드를 12개 정도 가졌던 것 같습니다.
**스윅스 (Swyx)**: 코딩 에이전트(Agent)의 시장 포지셔닝(Positioning) 및 IDE 통합 매트릭스(Matrix)에 대해 사람들에게 설명해 주실 수 있습니까? 어떤 도구가 가장 적합한지, 그리고 당신들이 가장 잘하는 것은 무엇입니까?
**사우드 (Saoud)**: 저는 우리가 가장 잘하는 것과 처음부터 우리의 정신(ethos)은 개발자들이 현재 있는 곳에서 그들을 만나는 것이라고 생각합니다. IDE는 그런 것에 완벽한 통로입니다. 당신은 그것이 만드는 편집을 볼 수 있습니다. 당신은 그것이 실행하는 명령을 볼 수 있습니다. 당신은 그것이 호출하는 도구를 볼 수 있습니다. 그것은 당신이 오늘날 이 모델들의 한계(model limitations)와 함께 작업하기 위해 필요한 방식으로 통찰력(insight)과 제어 수준을 가지고 경로를 수정할 수 있는 완벽한 UX(User Experience)를 제공합니다. 하지만 모델이 더 좋아짐에 따라, 당신은 그것을 점점 덜 하게 되고, 초기 계획과 프롬프팅(prompting)을 점점 더 많이 하게 될 것이며, 모델이 당신이 원하는 대로 정확히 작업을 완료할 수 있을 것이라는 신뢰와 확신을 갖게 될 것이라는 것은 꽤 분명하다고 생각합니다.
**파쉬 (Pash)**: 에이전트(agent)가 무엇을 하는지에 대한 가시성(visibility)이 한 축입니다. 그리고 다른 하나는 자율성(autonomy)입니다. 얼마나 자동화되었는지 말이죠. 그리고 우리는 코드를 보려고 하지도 않는 사람들의 사용 사례(use case)에 더 집중하는 회사들의 범주를 가지고 있습니다. 예를 들어, 러버블스(lovables), 리플릿(replets)과 같은 곳이죠. 당신이 들어가서 앱(app)을 만들고, 기술적이지 않을 수도 있지만 결과에 만족합니다.

**코딩 에이전트(Agent)의 가시성 및 자율성: 개발자 통제와 AI 효율성**
**알레시오 (Alessio)**: 엔지니어(engineer)로서 제가 가진 문제는 우리 모두가 복잡한 일을 한다고 믿고 싶어 한다는 것입니다. 시간이 지남에 따라 복잡성의 정의는 어떻게 변했습니까?
**사우드 (Saoud)**: 저는 몇 년 전만 해도 복잡했던 것이 오늘날에는 완전히 다르다고 생각합니다. 이제 우리는 초기 단계에서 내리는 아키텍처 결정에 대해 더 의도적으로 접근해야 합니다. 당신이 명확한 방향을 가지고 있고 무엇을 원하는지 잘 알고 있다면, 기초를 어떻게 놓을지에 대한 좋은 아이디어를 가질 수 있습니다. 몇 년 전 복잡하다고 여겨졌던 알고리즘적 도전 과제들은 오늘날 모델에게는 매우 사소한 일입니다. 이제 우리는 원하는 것에 대한 특정 기대치나 단위 테스트를 제공하고, 모델은 완벽한 해결책을 제시합니다.

**프로그래밍 작업 복잡성의 진화하는 정의와 AI의 역할**
**파쉬 (Pash)**: 이는 선임 소프트웨어 엔지니어들이 더욱 아키텍처적인 사고를 할 수 있도록 해줍니다. 그들은 현재 저장소(repository)의 상태와 아키텍처를 잘 이해하고, 새로운 것을 도입할 때 진정으로 아키텍처 수준에서 생각합니다. 그리고 그들은 이를 에이전트(agent)에게 명확하게 전달합니다. 물론 여기에는 약간의 기술이 필요하며, 에이전트 측에서 후속 질문을 하거나 명확히 하는 방식으로 완화될 수 있습니다. 하지만 궁극적으로 이 새로운 아키텍처를 에이전트에게 명확히 전달해야 하며, 그러면 에이전트는 깊이 파고들어 모든 것을 구현할 수 있습니다. 이런 식으로 일하는 것이 더 재미있습니다. 개인적으로 저는 더 아키텍처적인 수준에서 생각하는 것이 훨씬 더 흥미롭고, 주니어 엔지니어들에게는 코드베이스(codebase)를 배우는 데 정말 좋은 패러다임입니다. 마치 주머니 속에 선임 엔지니어가 있는 것과 같습니다.

**클라인(Cline)의 포크(Fork) 및 오픈 소스(Open Source) 후회: 커뮤니티의 힘**
**알레시오 (Alessio)**: 경쟁에서 벗어나, 마지막 질문이 있습니다. 루코드(RooCode)와의 트위터 설전(beef)에 대해 알고 싶습니다. 어제 당신이 트윗(tweet)한 것을 봤는데, 누군가 루코드에게 Gemini CLI 지원을 추가해달라고 요청했고, 당신들은 "또 우리 것을 베끼는군요"라고 답했습니다. 그리고 그들은 "감사합니다. 출처를 밝히겠습니다"라고 말했습니다. 정말로 설전입니까?
**파쉬 (Pash)**: 우리는 모두 타임라인에서 즐거운 시간을 보내고 있다고 생각합니다. 포크(fork)가 많습니다.
**사우드 (Saoud)**: 6천 개 정도의 포크(fork)가 있습니다.
**파쉬 (Pash)**: 네, 클라인(Cline)을 VS Code 마켓플레이스(marketplace)에서 검색하면, 전체 페이지가 클라인(Cline)의 포크(fork)들로 가득합니다. 심지어 포크(fork)의 포크(fork)들도 나와서 엄청난 돈을 모으기도 했습니다.
**사우드 (Saoud)**: 오픈라우터(OpenRouter)의 상위 세 앱은 모두 클라인(Cline)과 클라인(Cline) 포크(fork)입니다.
**파쉬 (Pash)**: 재밌네요. 수십억 개의 토큰이 이 모든 포크(fork)들을 통해 전송되고 있습니다. 포크 전쟁이 벌어지고 있는데, 나이프 하나면 충분하죠. 흥미진진합니다. 저는 그들이 모두 정말 멋진 사람들이라고 생각합니다. 유럽에서 우리를 포크(fork)하는 사람들도 있고, 중국에서 작은 포크(fork)를 만드는 사람들도 있습니다.
**알레시오 (Alessio)**: 오픈 소스(open source)에 대해 후회하는 점은 없습니까?
**사우드 (Saoud)**: 전혀 없습니다. 클라인(Cline)은 코딩 에이전트(coding agent)가 어떤 모습이어야 하는지에 대한 정말 좋은 기반으로 시작했으며, 사람들은 그 위에 구축하고 싶은 자신만의 흥미로운 아이디어와 스핀오프, 개념을 많이 가지고 있었습니다. 이러한 현상은 이 분야 전반의 흥분을 보여주며, 우리에게 무엇이 효과적이고 무엇이 그렇지 않은지에 대한 통찰력을 주어 우리 제품에 반영할 수 있도록 도왔습니다.

**에이전트(Agent) 설계의 단순성 대 복잡성: 최적의 균형점 찾기**
**파쉬 (Pash)**: 여러 면에서, 우리와 포크(fork)들은 처음부터 단순성을 유지하고, 모델이 모든 것을 하도록 하며, 추론(inference)으로 돈을 벌려고 하지 않고, 컨텍스트(context)에 집중하며, 파일을 컨텍스트(context)로 적극적으로 읽어들이는 철학을 가진 유일한 존재였습니다. 클라우드 코드(Cloud Code)를 다시 살펴보면, 그들이 가능한 한 단순하게 유지하는 우리 철학을 검증해 주었다는 것이 정말 좋았습니다. 이는 래그(RAG)와도 연결됩니다. 래그는 2022년 초기에 등장한 것으로, 컨텍스트 윈도우(context window)가 매우 작았을 때 벡터 데이터베이스(vector database) 회사들이 "AI에게 무한한 메모리를 줄 수 있다"고 홍보하며 투자자들을 끌어모았습니다. 하지만 래그는 코드베이스(codebase)를 인덱싱하고 작은 조각으로 나누어 임의의 코드 스니펫(code snippet)을 검색하는 방식인데, 이는 모델을 혼란스럽게 하고 오히려 성능을 저하시킵니다. 시니어 소프트웨어 엔지니어가 새로운 저장소(repository)에 처음 접했을 때처럼, 폴더 구조를 보고 파일을 탐색하며 에이전트적으로 저장소를 탐색하는 방식이 훨씬 더 효과적이라는 것을 우리는 발견했습니다.

**패스트 어플라이(Fast Apply)가 비터 레슨(Bitter Lesson)을 얻은 방법: 기술 발전의 교훈**
**사우드 (Saoud)**: 래그(RAG)와 패스트 어플라이(Fast Apply)는 모델이 대규모 컨텍스트(context) 처리나 검색 및 대체(search and replace) 편집에 능숙하지 않았을 때 유용한 도구였습니다. 하지만 이제는 더 이상 필요 없는 추가적인 요소가 되어 문제를 일으킬 수 있습니다. 코그니션 랩스(Cognition Labs)의 흥미로운 기사에서 다중 에이전트 오케스트레이션(multi-agent orchestration)에 대해 이야기했습니다. 그들은 여러 모델과 에이전트가 함께 작업할 때 세부 사항에서 많은 것이 손실될 수 있다고 지적했습니다. 우리는 모델에 필요한 모든 컨텍스트(context)를 제공하고, 관련 컨텍스트를 가져오기 위한 비용 최적화된 접근 방식을 취하지 않는 것이 중요하다고 생각합니다.
**파쉬 (Pash)**: 추론(inference)으로 돈을 벌지 않는 것이 중요합니다. 인센티브(incentive)는 이 논의에서 매우 중요합니다. 만약 당신이 추론 비용을 청구한다면, 비용을 절감하기 위해 작은 모델을 사용하거나 래그(RAG)와 같은 방식으로 최적화하려고 할 것입니다. 하지만 우리가 추론으로 돈을 벌지 않고 사용자가 자신의 API 키(API key)를 가져오도록 한다면, 우리는 비용 절감에 인센티브를 받지 않고 최고의 에이전트(agent)를 구축하는 데 집중할 수 있습니다.

**클라인(Cline)의 비즈니스 모델(Business Model) 및 BYO-API 키(Bring-Your-Own-API-Key) 접근 방식: 투명성과 사용자 중심**
**알레시오 (Alessio)**: 클라인(Cline)의 가격 책정 비즈니스 모델(Business Model)은 무엇입니까?
**사우드 (Saoud)**: 현재는 API 키(API key)를 가져오는 방식입니다. 당신이 사용하는 추론 제공업체(inference provider)나 모델에 대한 사전 약정이 있다면, 당신의 앤트로픽(Anthropic)이나 오픈AI(OpenAI), 오픈라우터(OpenRouter) API 키(API key)를 클라인(Cline)에 연결하기만 하면 됩니다. 이러한 투명성 수준은 우리가 최고의 제품을 구축하는 데 집중할 수 있게 합니다. 우리는 비용을 낮추고 수익을 극대화하기 위한 가격 불투명성이나 모델 오케스트레이션(orchestration)의 영리한 속임수에 초점을 맞추지 않습니다.
**파쉬 (Pash)**: 하지만 그것이 지능의 비용입니다.
**사우드 (Saoud)**: 네, 그게 지능의 비용입니다. 그래서 현재 비즈니스 모델은 당신이 선택할 수 있는 오픈 소스(open source)이며, 당신의 데이터가 어디로 전송되는지, 누구에게 지불할지 선택할 수 있습니다. 우리가 대화한 많은 조직들은 이러한 제공업체(provider)들과 특정 볼륨 기반 할인(volume based discounts)을 받고 있으며, 클라인(Cline)을 통해 이를 활용할 수 있습니다.
**스윅스 (Swyx)**: 잠깐만요, 그럼 어떻게 돈을 버는 겁니까?
**파쉬 (Pash)**: 많은 사람들이 우리에게 묻는 질문인데, 저는 항상 그들에게 '왜 돈을 벌어야 하죠?'라고 되묻습니다. 하지만 진짜 답은 엔터프라이즈(enterprise)입니다.
**스윅스 (Swyx)**: 네, 우리가 출시할 때 이걸 말해도 된다고 했죠.
**파쉬 (Pash)**: 엔터프라이즈(enterprise)에 대해 이야기하고 싶습니까?
**사우드 (Saoud)**: 저는 오픈 소스(open source)이고 API 키(API key)를 가져오는 방식이 데이터 프라이버시(data privacy), 제어, 보안이 최우선인 조직들에서 쉽게 채택될 수 있도록 했다고 생각합니다. 우리는 아무것도 우리 서버를 통과하지 않으며, 당신은 전체 애플리케이션(application)과 데이터가 전송되는 곳에 대한 완전한 통제권을 가지고 있다고 말할 수 있는 기회를 얻었습니다.
**파쉬 (Pash)**: 클라인(Cline)을 오픈 소스(open source)로 공개했을 때, 사람들이 정말 좋아했습니다. 개발자들이 조직 내에서 클라인(Cline)을 사용했고, 조직들은 우리가 오픈 소스이고 데이터를 어디로도 보내지 않는다는 것을 알았기 때문에 마지못해 승인했습니다. 그리고 우리는 엔터프라이즈(enterprise)를 위한 연락 양식을 웹사이트에 올렸지만, 당시에는 실제 엔터프라이즈 제품이 없었습니다. 그런데 엄청난 수의 대기업들이 우리에게 연락해 왔습니다.

**오픈라우터(OpenRouter) 및 엔터프라이즈(Enterprise) 인프라(Infrastructure) 통합: 개방형 생태계의 가능성**
**스윅스 (Swyx)**: 우리는 이 문제를 나중에 다룰 수 있지만, 우리는 그들 중 일부와 이야기를 나누고 싶습니다. 그들이 팟캐스트에서 상사들에게 무엇을 말하는지 들어보고 싶습니다. 왜냐하면 우리는 종종 개발 도구의 창업자와 개발자들과만 이야기하지만, 최종 소비자들과는 이야기하지 않기 때문입니다.
**스윅스 (Swyx)**: 제가 더블 클릭하고 싶었던 한 가지는 오픈라우터(OpenRouter)와 당신의 엔터프라이즈(enterprise) 서비스 간의 관계입니다. 제 이해로는 현재 모든 것이 오픈라우터(OpenRouter)를 통해 실행됩니다.
**사우드 (Saoud)**: 모든 것이 그런 것은 아닙니다. 오픈AI(OpenAI), 앤트로픽(Anthropic), 베드락(Bedrock)에 API 키(API key)를 가져올 수 있습니다. 그리고 사용자에게 직접적인 연결이 있습니다.
**스윅스 (Swyx)**: 하지만 다른 모든 것은 오픈라우터(OpenRouter)를 통해 실행될 것입니다. 그래서 기본적으로 클라이언트(Client)의 엔터프라이즈(enterprise) 버전은 당신이 해당 엔터프라이즈(enterprise)에 가시성(visibility)과 제어권을 제공하는 자체 오픈라우터(OpenRouter)를 가질 것이라는 의미입니까?
**파쉬 (Pash)**: 네, 그것은 자체 호스팅(self-hosted) 옵션에 대한 것입니다. 자체 호스팅(self-hosted)을 하지 않아도 괜찮지만, 자신의 베드락(Bedrock) API 키(API key) 등을 사용하는 한, 많은 엔터프라이즈(enterprise)가 있습니다. 반면에 자체 호스팅(self-hosted)에 정말 관심이 있거나 팀을 관리하고 싶은 사람들을 위해서는 내부 라우터(router)가 있을 것입니다.

**모델 비용 감소의 영향: AI 서비스의 대중화 가속**
**스윅스 (Swyx)**: 여기서 궁금한 점은 모델 비용이 0으로 떨어진다면 어떻게 될까요? Gemini 코드가 나와서 "여러분, 무료입니다"라고 말한다면요?
**사우드 (Saoud)**: 네, 그러면 우리에게는 정말 좋을 겁니다. 우리의 가설은 추론(inference)이 비즈니스가 아니라는 것입니다.
**스윅스 (Swyx)**: 추론으로 돈을 벌지 않을 것이라는 말이죠?
**사우드 (Saoud)**: 우리는 최종 사용자에게 가격에 대한 완전한 투명성을 제공하고 싶습니다. 이 공간에서 가격 불투명성은 개발자들이 사용량 기반 요금제(usage-based plans)에 가입하는 것을 주저하게 만들었습니다. 우리는 많은 사람들이 '제품 사용을 위한 기본 요금제는 있지만, 추론은 방해하지 않고, 최종 개발자에게 비용뿐만 아니라 사용되는 모델에 대한 통찰력을 제공하여 작업을 완료하는 데 필요한 만큼 돈을 쓰는 데 더 자신감을 갖게 하자'는 개념에 수렴하고 있다고 봅니다.

**백그라운드 에이전트(Background Agent) 및 다중 에이전트 시스템(Multi-Agent System): 미래 AI 아키텍처의 핵심**
**스윅스 (Swyx)**: 이제 컨텍스트 엔지니어링(context engineering)과 메모리(memory) 등 다른 모든 것에 대해 이야기해 보겠습니다. 이 문제의 또 다른 변형은 백그라운드 에이전트(background agent)와 다중 에이전트(multi-agent)입니다. 현재 코덱스(Codex)와 같이 백그라운드 에이전트(background agent)는 1분당 하나의 PR을 생성하거나, 데빈(Devin)이나 코그니션(Cognition)처럼 작동합니다. 당신도 그런 방향으로 갈 것입니까?
**파쉬 (Pash)**: 우리는 클라인(Cline)의 CLI 버전(CLI version)을 출시할 예정이며, 이는 완전히 모듈식입니다. 그래서 클라인(Cline)에게 CLI를 실행하여 더 많은 클라인(Cline)을 스핀업(spin up)하도록 요청하거나, 깃허브 액션(GitHub action)에서 클라우드 프로세스(cloud process)로 클라인(Cline)을 실행할 수 있습니다. CLI는 이러한 완전히 자율적인 에이전트(agent)를 위한 형태입니다.
**사우드 (Saoud)**: 저는 이것이 '이것 아니면 저것'의 문제가 아니라고 생각합니다. 이 모든 다른 방식들이 서로를 정말 잘 보완한다고 생각합니다. 코덱스(Codex), 데빈(Devin), 커서(Cursor)의 백그라운드 에이전트(background agent)는 모두 같은 목표를 달성합니다. 우리가 자체 버전을 출시한다면, 그것은 다른 개발자들이 그 위에 구축할 수 있는 기반이 될 것입니다.
**파쉬 (Pash)**: 우리는 클라인(Cline)의 6천 개 포크(fork)에서 본 것처럼, 개발자 커뮤니티가 그 위에 구축하고 활용할 수 있는 기반을 마련했습니다.

**비전(Vision) 및 멀티모달리티(Multi-Modalities): AI의 감각 확장**
**스윅스 (Swyx)**: 컨텍스트 엔지니어링(context engineering)으로 넘어가겠습니다. RAG가 정신 바이러스(mind virus)라는 말처럼, 이 주제는 비슷한 맥락에 있다고 생각합니다. 문서에는 컨텍스트 관리(context management) 섹션이 있고, 메모리 뱅크(memory bank) 섹션도 있습니다. 컨텍스트 엔지니어링(context engineering)은 당신에게 무엇을 의미합니까?
**사우드 (Saoud)**: 컨텍스트 엔지니어링(context engineering)은 모델에 무엇이 들어가야 하는지에 대한 많은 예술적 요소를 포함합니다. 저는 그것이 정말 좋은 에이전트(agent)를 구축하는 데 있어 80-20 원칙이라고 생각합니다. 컨텍스트(context)에 무엇이 들어가야 하는지, 그리고 MCP와 시스템 클라이언트, 권장 프롬프트(prompt) 사이의 상호작용이 궁극적으로 좋은 에이전트(agent)를 만드는 요소입니다.
**파쉬 (Pash)**: 네, 컨텍스트 관리(context management)는 컨텍스트(context)에 무엇을 로드(load)하는가 하는 한 부분입니다. 다른 부분은 컨텍스트 윈도우(context window)에 도달했을 때 어떻게 정리하는가 하는 것입니다. 전체 라이프사이클(lifecycle)을 어떻게 관리하는가 하는 것입니다. RAG나 다른 종류의 검색과 같은 아이디어들도 있지만, 우리는 에이전트적 탐색(agentic exploration)이 훨씬 더 효과적이라는 것을 발견했습니다.

**컨텍스트 엔지니어링(Context Engineering)의 현황과 AI 상호작용의 심화**
**사우드 (Saoud)**: 컨텍스트 엔지니어링(context engineering)은 AI 시스템이 복잡한 정보를 효과적으로 처리하고 이해하도록 돕는 핵심 분야입니다. 이는 단순히 프롬프트(prompt)를 설계하는 것을 넘어, AI가 주어진 작업에 가장 적합한 정보를 선별하고, 불필요한 정보를 걸러내는 과정을 포함합니다. MCP와 같은 도구는 에이전트가 시스템의 다른 부분과 상호 작용하며 필요한 컨텍스트를 동적으로 가져올 수 있도록 합니다.
**스윅스 (Swyx)**: AST 언급에 대해 더 자세히 설명해 주십시오. 언제 그것을 사용합니까?
**사우드 (Saoud)**: 현재, 그것은 도구입니다. 클라이언트(client)가 관련 컨텍스트(context)를 가져오기 위해 에이전트적 탐색(agentic exploration)을 수행할 때, 예를 들어 특정 디렉토리(directory)에서 무엇이 진행되고 있는지 파악하려고 할 때 사용됩니다. 이 도구는 클래스 이름이나 함수 이름과 같은 디렉토리(directory)의 언어를 가져올 수 있도록 하여, 해당 폴더에서 무엇이 진행되고 있는지 파악하는 데 도움을 줍니다. 그리고 그것이 수행하려는 작업과 관련이 있다고 판단되면, 해당 파일 전체를 컨텍스트(context)로 읽어들입니다.
**파쉬 (Pash)**: 우리는 일부 회사들이 AST를 지식 그래프(knowledge graph)로 활용하는 것을 보았습니다. 이를 통해 결정론적인 작업을 수행할 수 있습니다. 예를 들어, 코드베이스(codebase)의 모든 함수를 찾고, 사용되지 않는 모든 함수를 찾아 삭제하는 것과 같이요. 에이전트(agent)는 거의 SQL과 같은 언어로 이 지식 그래프(knowledge graph)와 상호 작용하여 이러한 전역적인 작업을 수행할 수 있습니다.

**코딩 에이전트(Agent)의 메모리 시스템(Memory System): 지식 관리의 새로운 패러다임**
**알레시오 (Alessio)**: 메모리(memory) 측면을 마무리하기 위해, 메모리는 거의 요약의 결과물입니다. 코딩 에이전트(Agent)의 메모리 시스템(Memory System)에서 흥미로운 학습 내용은 없습니까?
**사우드 (Saoud)**: 저는 현재 메모리(memory)가 대부분 쓸모없다고 생각합니다. 당신이 코딩할 때 원하는 종류의 메모리는, 저는 사람들이 그런 것들에 대해 생각하고 싶어 하지 않는다고 생각합니다. 그래서 우리가 생각하고 있는 것은, 에이전트가 도중에 배우는 부족 지식(tribal knowledge)을 어떻게 유지할 수 있을까 하는 것입니다.
**파쉬 (Pash)**: 그것들은 작업 공간 규칙이나 부족 지식, 팀으로서 사용하는 일반적인 패턴과 같습니다. 하지만 우리는 내부 실험을 통해 할 일 목록 도구를 만들었습니다. 거기에는 할 일을 작성하는 도구 하나만 있었고, 매번 할 일을 처음부터 다시 작성할 수 있었습니다. 그리고 우리는 수동적으로, 모든 메시지는 아니지만, 가끔씩 이 할 일 목록의 최신 상태를 컨텍스트(context)로 전달했습니다. 그리고 우리는 이것이 여러 번의 컨텍스트 요약과 압축 후에도 에이전트(agent)를 계속 궤도에 올려놓는다는 것을 발견했습니다.

**에이전트(Agent) 도구 전반의 규칙 파일 표준화와 상호 운용성(interoperability) 증진**
**알레시오 (Alessio)**: CloudMD, AgentsMD, AgentMD에 대한 생각은 없습니까? 저는 Agents927이라는 오픈 소스 도구를 만들었는데, XKCD처럼 모든 파일 이름에 복사-붙여넣기하여 모든 파일이 접근할 수 있도록 했습니다. 단일 파일이 있어야 한다고 생각하십니까?
**사우드 (Saoud)**: 저는 각 도구가 자신만의 특정 지침을 가지고 있는 것이 괜찮다고 생각합니다. 왜냐하면 저는 커서(Cursor) 규칙과 클라인(Cline) 규칙을 따로 사용하기 때문입니다. 클라인(Cline)이라는 에이전트(agent)가 특정 방식으로 작동하기를 원하는데, 이는 커서(Cursor)가 제 코드베이스(codebase)와 상호 작용하기를 원하는 방식과는 다릅니다. 그래서 저는 각 도구가 제가 하는 작업의 종류에 특화되어 있다고 생각합니다.

**클라인(Cline)의 성격 및 의인화: 사용자 경험의 인간적 요소**
**스윅스 (Swyx)**: 그가 '그'라고 말하는 것을 들었습니다. 클라인(Cline)에게는 전체적인 배경 성격이 있습니까?
**사우드 (Saoud)**: 클라인(Cline)은 CLI와 에디터(editor)를 가지고 있습니다.
**스윅스 (Swyx)**: 이전에는 클로드 데브(Claude Dev)였고, 이제는 클라인(Cline)입니다.
**사우드 (Saoud)**: 저는 클라인(Cline)이 커서(Cursor) 에이전트(agent)나 코파일럿(Copilot)과는 달리 좀 더 인간적인 면모를 가지고 있다는 점에서 이 분야에서 돋보인다고 생각합니다.
**스윅스 (Swyx)**: 데빈(Devin)이라는 실제 이름도 있죠. 클로드(Claude)도 실제 이름이고요.
**사우드 (Saoud)**: 네. 그래서 저는 클라인(Cline)이 좀 더 자의식이 있다고 생각합니다.
**파쉬 (Pash)**: 그리고 이것은 내러티브 무결성(narrative integrity)으로 돌아갑니다. 에이전트(agent)를 의인화하는 것이 정말 중요하다고 생각합니다. 모든 행동은 작은 이야기와 같고, 뚜렷한 정체성이 없으면 결과가 좋지 않습니다.

**클라인(Cline) 채용 및 팀 문화: 혁신을 위한 인재 확보**
**스윅스 (Swyx)**: 클라인(Cline)은 채용 중이고, 현재 20명에서 100명을 목표로 하고 있으며, 멋진 새 사무실도 있습니다. 클라인(Cline)에서 일하는 것에 대한 최고의 홍보 문구는 무엇입니까?
**사우드 (Saoud)**: 현재 우리의 채용은 대부분 친구의 친구, 우리 네트워크의 사람들, 우리가 이전에 함께 일했고 신뢰하는 사람들로 이루어져 있습니다. 우리가 당면한 이 엄청나게 어려운 과제를 해결하기 위해 함께 일할 수 있는 사람들입니다. 앞으로 많은 도전 과제가 있습니다. 저는 문제 공간이 지금 당장 가장 흥미로운 분야라고 생각합니다. 엔지니어들은 일반적으로 자신의 삶을 더 쉽게 만드는 일에 열정적입니다. 그래서 코딩 에이전트(coding agent)보다 더 흥미로운 일은 상상할 수 없습니다. 이는 약간 편향된 의견일 수 있지만, 흥미로운 문제 공간이 큰 부분을 차지합니다. 우리는 앞으로 10년이 어떻게 될지 파악하고, 백그라운드 에이전트(background agent)나 다중 에이전트(multi-agent) 이후에 무엇이 올지, 그리고 이 모든 것이 어떻게 형성될지 정의하는 데 기여하고 싶은 정말 의욕적인 사람들을 찾고 있습니다.
**파쉬 (Pash)**: 네, 클라인(Cline)은 독특한 회사입니다. 우리는 모두 친구처럼 멋진 것을 만들고 있다는 느낌이 듭니다. 우리는 정말 열심히 일하고 있으며, 이 분야는 경쟁이 치열할 뿐만 아니라, 하이퍼 경쟁적입니다. 모든 경쟁자들에게 자본이 흘러 들어가고 있고, 제가 말했듯이 포크(fork)의 포크(fork)들도 수천만 달러를 모금하고 있습니다. 우리는 매우 빠르게 성장하고 있습니다. 현재 20명이며, 연말까지 100명을 목표로 하고 있습니다.