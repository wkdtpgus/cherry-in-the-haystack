# **데이터 과학자를 위한 효율적인 파이썬 강좌 [8/14]: Pandas DataFrame 반복문 처리를 멈추고 대신 이렇게 하세요**

Author: Youssef Hosni
URL: https://youssefh.substack.com/p/efficient-python-for-data-scientists-6a0

============================================================

**구독자 2만 명 할인**

Pandas DataFrame(데이터프레임)을 다루는 것은 특히 반복문(looping)을 사용할 때 지루하고 시간이 많이 소요되는 작업일 수 있습니다. 대부분의 파이썬(Python) 개발자들과 마찬가지로, 여러분도 DataFrame을 반복 처리하는 가장 효율적인 방법을 찾기 위해 상당한 시간을 보냈을 것입니다. 하지만 더 쉬운 방법이 있다면 어떨까요? 이 글에서는 반복문이 필요 없는 Pandas DataFrame을 다루는 더 나은 방법들을 보여드릴 것입니다. 이러한 접근 방식의 장점을 논하고, 시작하는 데 도움이 되는 몇 가지 실용적인 예시도 제공할 것입니다. 그러니 Pandas DataFrame 반복 처리를 멈추고 더 나은 방법을 시도할 준비가 되었다면 계속 읽어보세요!

**목차:**
*   왜 효율적인 코딩이 필요한가?
*   .iterrows()를 사용하여 효율적으로 반복 처리하기
*   .apply()를 사용하여 효율적으로 반복 처리하기
*   벡터화(vectorization)를 사용하여 효율적으로 반복 처리하기
*   모범 사례 요약

이 글 전체에서 우리는 포커(Poker) 카드 게임 데이터셋(dataset)을 사용할 것입니다. 먼저 데이터를 로드(load)하고 탐색해 봅시다:

```python
import pandas as pd
import time
import numpy as np

poker_data = pd.read_csv(’/kaggle/input/poker-hand/poker_hand.csv’)
poker_data.head()
```

각 포커 라운드에서 각 플레이어는 손에 다섯 장의 카드를 가지고 있으며, 각 카드는 하트(hearts), 다이아몬드(diamonds), 클로버(clubs), 스페이드(spades) 중 하나인 문양(symbol)과 1부터 13까지의 순위(rank)로 특징지어집니다. 이 데이터셋은 한 사람이 가질 수 있는 다섯 장의 카드에 대한 모든 가능한 조합으로 구성됩니다.

Sn: n번째 카드의 문양(symbol) (1: 하트, 2: 다이아몬드, 3: 클로버, 4: 스페이드)
Rn: n번째 카드의 순위(rank) (1: 에이스(Ace), 2–10, 11: 잭(Jack), 12: 퀸(Queen), 13: 킹(King))

**내 모든 책을 한 번의 클릭으로 40% 할인된 가격에 만나보세요**
유세프 호스니(Youssef Hosni) · 6월 17일

제 책과 로드맵(roadmap)을 묶어 번들(bundle)로 만들었으니, 한 번의 클릭으로 모든 것을 원가보다 40% 저렴하게 구매하실 수 있습니다. 이 번들에는 다음을 포함한 8권의 전자책(eBook)이 포함되어 있습니다:
전체 이야기 읽기

### 1. .iterrows()를 사용하여 효율적으로 반복 처리하기

**구독자 2만 명 할인**

.iterrows() 함수를 사용하여 반복 처리 과정을 개선하는 방법에 대해 이야기하기 전에, 제너레이터(generator) 함수의 개념을 다시 한번 살펴보겠습니다. 제너레이터는 이터레이터(iterator)를 생성하는 간단한 도구입니다. 제너레이터의 본문 안에는 return 문 대신 yield() 문만 있습니다. yield() 문은 하나만 있을 수도 있고 여러 개 있을 수도 있습니다.

여기서는 네 개의 도시 이름을 생성하는 제너레이터인 `city_name_generator()`를 볼 수 있습니다. 간단하게 설명하기 위해 이 제너레이터를 `city_names` 변수에 할당했습니다.

```python
def city_name_generator():
    yield(’New York’)
    yield(’London’)
    yield(’Tokyo’)
    yield(’Sao Paolo’)

city_names = city_name_generator()
```

제너레이터가 생성하는 요소에 접근하기 위해 파이썬(Python)의 `next()` 함수를 사용할 수 있습니다. `next()` 명령이 사용될 때마다 제너레이터는 더 이상 생성할 값이 없을 때까지 다음 값을 생성합니다. 우리는 4개의 도시를 가지고 있습니다. `next` 명령을 네 번 실행하여 무엇을 반환하는지 봅시다:

```python
next(city_names)
next(city_names)
next(city_names)
```

보시다시피 `next()` 함수를 실행할 때마다 새로운 도시 이름이 출력됩니다.

이제 `.iterrows()` 함수로 돌아가 봅시다. `.iterrows()` 함수는 모든 Pandas DataFrame의 속성(property)입니다. 이 함수가 호출되면 두 개의 요소를 가진 리스트(list)를 생성합니다. 우리는 이 제너레이터를 사용하여 포커 DataFrame의 각 행을 반복 처리할 것입니다. 첫 번째 요소는 행의 인덱스(index)이고, 두 번째 요소는 각 행의 각 특징(feature), 즉 다섯 장의 카드 각각의 문양(Symbol)과 순위(Rank)를 담고 있는 Pandas Series(시리즈)입니다. 이는 리스트에 적용될 때 각 요소와 해당 인덱스를 반환하는 `enumerate()` 함수의 개념과 매우 유사합니다.

Pandas DataFrame을 반복 처리하는 가장 직관적인 방법은 `range()` 함수를 사용하는 것인데, 이는 종종 '조잡한 반복(crude looping)'이라고 불립니다. 아래 코드에서 이를 보여줍니다:

```python
start_time = time.time()
for index in range(poker_data.shape[0]):
    next
print("Time using range(): {} sec".format(time.time() - start_time))
```

Pandas DataFrame을 반복 처리하는 더 현명한 방법은 이 작업에 최적화된 `.iterrows()` 함수를 사용하는 것입니다. 우리는 단순히 각 행의 번호에 대한 이터레이터 하나와 모든 값에 대한 이터레이터 하나, 이렇게 두 개의 이터레이터로 `for` 루프(loop)를 정의합니다. 루프 내부에서 `next()` 명령은 실제로 아무것도 하지 않고 루프가 이터레이터의 다음 값으로 이동함을 나타냅니다.

```python
data_generator = poker_data.iterrows()
start_time = time.time()
for index, values in data_generator:
    next
print("Time using .iterrows(): {} sec".format(time.time() - start_time))
```

두 계산 시간을 비교해 보면, `.iterrows()`를 사용하는 것이 Pandas DataFrame을 반복 처리하는 속도를 향상시키지 않는다는 것을 알 수 있습니다. 하지만 데이터셋을 반복 처리하면서 각 행의 값을 더 깔끔하게 사용해야 할 때 매우 유용합니다.

### 2. .apply()를 사용하여 효율적으로 반복 처리하기

**구독자 2만 명 할인**

이제 Pandas DataFrame을 반복 처리하면서 특정 작업을 수행할 수 있도록 `.apply()` 함수를 사용할 것입니다. `.apply()` 함수는 이름 그대로 작동합니다. 즉, 다른 함수를 전체 DataFrame에 적용합니다. `.apply()` 함수의 문법(syntax)은 간단합니다. 이 경우 람다(lambda) 함수를 사용하여 매핑(mapping)을 생성한 다음, 각 셀(cell)에 적용할 함수를 선언합니다. 여기서는 DataFrame의 모든 셀에 제곱근 함수를 적용하고 있습니다. 속도 면에서는 전체 DataFrame에 NumPy의 `sqrt()` 함수를 사용하는 것과 동일한 속도를 보입니다.

```python
data_sqrt = poker_data.apply(lambda x: np.sqrt(x))
data_sqrt.head()
```

이것은 이 함수를 DataFrame에 적용하고자 하는 간단한 예시입니다. 하지만 관심 있는 함수가 하나 이상의 셀을 입력으로 받을 때는 어떻게 될까요? 예를 들어, 각 손에 있는 모든 카드의 순위 합계를 계산하고 싶다면 어떨까요? 이 경우, 이전과 동일한 방식으로 `.apply()` 함수를 사용하겠지만, 함수를 각 행에 적용하고 있음을 지정하기 위해 줄 끝에 `‘axis=1’`을 추가해야 합니다.

```python
apply_start_time = time.time()
poker_data[[’R1’, ‘R2’, ‘R3’, ‘R4’, ‘R5’]].apply(lambda x: sum(x), axis=1)
apply_end_time = time.time()
apply_time = apply_end_time - apply_start_time
print("Time using .apply(): {} sec".format(time.time() - apply_start_time))
```

그런 다음, 이전에 보았던 `.iterrows()` 함수를 사용하여 효율성을 비교할 것입니다.

**내 모든 책을 40% 할인된 가격에 만나보세요**

```python
for_loop_start_time = time.time()
for ind, value in poker_data.iterrows():
    sum([value[1], value[3], value[5], value[7], value[9]])
for_loop_end_time = time.time()
for_loop_time = for_loop_end_time - for_loop_start_time
print("Time using .iterrows(): {} sec".format(for_loop_time))
```

.apply() 함수를 사용하는 것이 .iterrows() 함수보다 약 400% 정도 훨씬 더 빠르며, 이는 엄청난 개선입니다!

```python
print('The differnce: {} %'.format((for_loop_time - apply_time) / apply_time * 100))
```

행에 대해 했던 것처럼 열에 대해서도 동일한 작업을 할 수 있습니다. 즉, 각 열에 하나의 함수를 적용할 수 있습니다. `axis=1`을 `axis=0`으로 바꾸면 모든 열에 합계 함수를 적용할 수 있습니다.

```python
apply_start_time = time.time()
poker_data[[’R1’, ‘R2’, ‘R3’, ‘R4’, ‘R5’]].apply(lambda x: sum(x), axis=0)
apply_end_time = time.time()
apply_time = apply_end_time - apply_start_time
print("Time using .apply(): {} sec".format(apply_time))
```

.apply() 함수를 행에 대한 Pandas의 기본 함수와 비교하면, Pandas의 기본 `.sum()` 함수가 동일한 작업을 더 빠르게 수행한다는 것을 알 수 있습니다.

```python
pandas_start_time = time.time()
poker_data[[’R1’, ‘R1’, ‘R3’, ‘R4’, ‘R5’]].sum(axis=0)
pandas_end_time = time.time()
pandas_time = pandas_end_time - pandas_start_time
print("Time using pandas: {} sec".format(pandas_time))
print('The differnce: {} %'.format((apply_time - pandas_time) / pandas_time * 100))
```

결론적으로, `.apply()` 함수는 Pandas DataFrame의 모든 행을 반복 처리할 때 더 빠르게 작동하지만, 동일한 작업을 열을 통해 수행할 때는 더 느리다는 것을 알 수 있습니다.

### 3. 벡터화(vectorization)를 사용하여 효율적으로 반복 처리하기

**구독자 2만 명 할인**

함수가 수행하는 반복 처리의 양을 줄이는 방법을 이해하기 위해, Pandas의 기본 단위인 DataFrame과 Series가 모두 배열(array)을 기반으로 한다는 점을 상기해 봅시다. Pandas는 각 값을 개별적으로 또는 순차적으로 처리하는 것보다 전체 배열에 대해 연산이 수행될 때 더 효율적으로 작동합니다. 이는 벡터화(vectorization)를 통해 달성할 수 있습니다. 벡터화는 전체 배열에 대해 연산을 실행하는 과정입니다.

아래 코드에서는 각 손에 있는 모든 카드의 순위 합계를 계산하고자 합니다. 이를 위해 포커 데이터셋을 슬라이싱(slice)하여 각 카드의 순위를 포함하는 열만 유지합니다. 그런 다음, 각 행에 대한 합계를 원한다는 것을 나타내기 위해 `axis = 1` 매개변수(parameter)를 사용하여 DataFrame의 내장 `.sum()` 속성을 호출합니다. 마지막으로, 데이터의 첫 다섯 행의 합계를 출력합니다.

```python
start_time_vectorization = time.time()
poker_data[[’R1’, ‘R2’, ‘R3’, ‘R4’, ‘R5’]].sum(axis=1)
end_time_vectorization = time.time()
vectorization_time = end_time_vectorization - start_time_vectorization
print("Time using pandas vectorization: {} sec".format(vectorization_time))
```

이전에 DataFrame의 모든 행을 단순히 반복 처리하는 것보다 DataFrame에 적용된 함수를 더 빠르게 수행하는 다양한 방법들을 살펴보았습니다. 우리의 목표는 이 작업을 수행하는 가장 효율적인 방법을 찾는 것입니다.

.iterrows()를 사용하여 DataFrame 반복 처리하기:

```python
data_generator = poker_data.iterrows()
start_time_iterrows = time.time()
for index, value in data_generator:
    sum([value[1], value[3], value[5], value[7]])
end_time_iterrows = time.time()
iterrows_time = end_time_iterrows - start_time_iterrows
print("Time using .iterrows() {} seconds " .format(iterrows_time))
```

.apply() 메서드(method) 사용하기:

```python
start_time_apply = time.time()
poker_data[[’R1’, ‘R2’, ‘R3’, ‘R4’, ‘R5’]].apply(lambda x: sum(x),axis=1)
end_time_apply = time.time()
apply_time = end_time_apply - start_time_apply
print("Time using apply() {} seconds" .format(apply_time))
```

벡터화, `.iterrows()` 함수, 그리고 `.apply()` 함수를 사용하여 각 손에 있는 모든 카드의 순위를 합산하는 데 걸리는 시간을 비교해 보면, 벡터화 방법이 훨씬 더 나은 성능을 보인다는 것을 알 수 있습니다.

DataFrame을 효율적으로 반복 처리하기 위해 NumPy 배열을 사용하여 DataFrame을 벡터화하는 또 다른 벡터화 방법을 사용할 수도 있습니다. 자신을 "파이썬(Python) 과학 계산을 위한 기본 패키지(fundamental package)"라고 정의하는 NumPy 라이브러리(library)는 최적화되고 미리 컴파일(pre-compiled)된 C 코드(code)로 내부적으로 연산을 수행합니다. 배열을 다루는 Pandas와 유사하게, NumPy는 `ndarray`라고 불리는 배열에서 작동합니다. Series와 `ndarray`의 주요 차이점은 `ndarray`가 인덱싱(indexing), 데이터 타입(data type) 확인 등 많은 연산을 생략한다는 것입니다. 결과적으로 NumPy 배열에 대한 연산은 Pandas Series에 대한 연산보다 훨씬 빠를 수 있습니다. Pandas Series가 제공하는 추가 기능이 중요하지 않을 때는 Pandas Series 대신 NumPy 배열을 사용할 수 있습니다. 이 글에서 다루는 문제의 경우, Pandas Series 대신 NumPy `ndarray`를 사용할 수 있습니다. 문제는 이것이 더 효율적인지 아닌지입니다.

다시 한번, 각 손에 있는 모든 카드의 순위 합계를 계산할 것입니다. 우리는 Pandas Series의 `.values` 메서드를 사용하여 순위 배열을 Pandas Series에서 NumPy 배열로 간단히 변환하는데, 이 메서드는 Pandas Series를 NumPy `ndarray`로 반환합니다. Series에 대한 벡터화와 마찬가지로, NumPy 배열을 함수에 직접 전달하면 Pandas는 함수를 전체 벡터(vector)에 적용하게 됩니다.

**내 모든 책을 40% 할인된 가격에 만나보세요**

```python
start_time = time.time()
poker_data[[’R1’, ‘R2’, ‘R3’, ‘R4’, ‘R5’]].values.sum(axis=1)
print("Time using NumPy vectorization: {} sec" .format(time.time() - start_time))

start_time = time.time()
poker_data[[’R1’, ‘R2’, ‘R3’, ‘R4’, ‘R5’]].sum(axis=1)
print("Results from the above operation calculated in %s seconds" % (time.time() - start_time))
```

이 시점에서, Pandas Series에 대한 벡터화가 일상적인 계산에 필요한 최적화 요구 사항의 압도적인 대부분을 충족시킨다는 것을 알 수 있습니다. 하지만 속도가 최우선이라면, NumPy 파이썬(Python) 라이브러리(library)의 형태로 지원을 요청할 수 있습니다. 이전의 최첨단 방법인 Pandas의 최적화와 비교했을 때도, 여전히 작동 시간에서 개선을 얻을 수 있습니다.

### 4. DataFrame 반복 처리를 위한 모범 사례 요약

**구독자 2만 명 할인**

.iterrows()를 사용하는 것은 DataFrame을 반복 처리하는 속도를 향상시키지는 않지만, 더 효율적입니다. .apply() 함수는 Pandas DataFrame의 모든 행을 반복 처리할 때 더 빠르게 작동하지만, 동일한 작업을 열을 통해 수행할 때는 더 느립니다. Pandas Series에 대한 벡터화는 일상적인 계산에 필요한 최적화 요구 사항의 압도적인 대부분을 충족시킵니다. 하지만 속도가 최우선이라면, NumPy 파이썬(Python) 라이브러리(library)의 형태로 지원을 요청할 수 있습니다.

이 뉴스레터(newsletter)는 개인적인 열정 프로젝트(project)이며, 여러분의 지원이 이를 유지하는 데 도움이 됩니다. 기여하고 싶으시다면 몇 가지 좋은 방법이 있습니다: 구독하기. 유료 구독은 제 글쓰기를 지속 가능하게 하고 추가 콘텐츠(content)에 대한 접근 권한을 제공합니다.* 제 책 번들(bundle)을 구매하세요. 제 7권의 실용서와 로드맵(roadmap)을 40% 할인된 가격으로 만나보세요.

읽어주셔서 감사드리며, 독립적인 글쓰기와 연구를 지원해 주셔서 감사합니다!